<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Lists: Products, Lists and Options</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Lists<span class="subtitle">Products, Lists and Options</span></h1>

<div class="code code-tight">
</div>

<div class="doc">

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;$Date:&nbsp;2011-06-22&nbsp;10:06:32&nbsp;-0400&nbsp;(Wed,&nbsp;22&nbsp;Jun&nbsp;2011)&nbsp;$&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
The next line imports all of our definitions from the
    previous chapter. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="Basics.html#"><span class="id" type="library">Basics</span></a>.<br/>

<br/>
</div>

<div class="doc">
For it to work, you need to use <span class="inlinecode"><span class="id" type="var">coqc</span></span> to compile <span class="inlinecode"><span class="id" type="var">Basics.v</span></span>
    into <span class="inlinecode"><span class="id" type="var">Basics.vo</span></span>.  (This is like making a .class file from a .java
    file, or a .o file from a .c file.)

<div class="paragraph"> </div>

    Here are two ways to compile your code:

<div class="paragraph"> </div>

<ul class="doclist">
<li> CoqIDE:

<div class="paragraph"> </div>

         Open Basics.v.
         In the "Compile" menu, click on "Compile Buffer".

<div class="paragraph"> </div>


</li>
<li> Command line:

<div class="paragraph"> </div>

         Run <span class="inlinecode"><span class="id" type="var">coqc</span></span> <span class="inlinecode"><span class="id" type="var">Basics.v</span></span>

</li>
</ul>

<div class="paragraph"> </div>

    In this file, we again use the <span class="inlinecode"><span class="id" type="keyword">Module</span></span> feature to wrap all of the
    definitions for pairs and lists of numbers in a module so that,
    later, we can reuse the same names for improved (generic) versions
    of the same operations. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Module</span> <a name="NatList"><span class="id" type="module">NatList</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab47"></a><h1 class="section">Pairs of Numbers</h1>

<div class="paragraph"> </div>

 In an <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> type definition, each constructor can take
    any number of parameters &mdash; none (as with <span class="inlinecode"><span class="id" type="var">true</span></span> and <span class="inlinecode"><span class="id" type="var">O</span></span>), one (as
    with <span class="inlinecode"><span class="id" type="var">S</span></span>), or more than one, as in this definition: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="NatList.natprod"><span class="id" type="inductive">natprod</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<a name="NatList.pair"><span class="id" type="constructor">pair</span></a> : <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Lists.html#natprod"><span class="id" type="inductive">natprod</span></a>.<br/>

<br/>
</div>

<div class="doc">
This declaration can be read: "There is just one way to
    construct a pair of numbers: by applying the constructor <span class="inlinecode"><span class="id" type="var">pair</span></span> to
    two arguments of type <span class="inlinecode"><span class="id" type="var">nat</span></span>."

<div class="paragraph"> </div>

    Here are some simple function definitions illustrating pattern
    matching on two-argument constructors: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="NatList.fst"><span class="id" type="definition">fst</span></a> (<span class="id" type="var">p</span> : <a class="idref" href="Lists.html#NatList.natprod"><span class="id" type="inductive">natprod</span></a>) : <span class="id" type="inductive">nat</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Lists.html#NatList.pair"><span class="id" type="constructor">pair</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <span class="id" type="var">x</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
<span class="id" type="keyword">Definition</span> <a name="NatList.snd"><span class="id" type="definition">snd</span></a> (<span class="id" type="var">p</span> : <a class="idref" href="Lists.html#NatList.natprod"><span class="id" type="inductive">natprod</span></a>) : <span class="id" type="inductive">nat</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Lists.html#NatList.pair"><span class="id" type="constructor">pair</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span> =&gt; <span class="id" type="var">y</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Since pairs are used quite a bit, it is nice to be able to
    write them with the standard mathematical notation <span class="inlinecode">(<span class="id" type="var">x</span>,<span class="id" type="var">y</span>)</span> instead
    of <span class="inlinecode"><span class="id" type="var">pair</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span>.  We can tell Coq to allow this with a <span class="inlinecode"><span class="id" type="keyword">Notation</span></span>
    declaration. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> "( x , y )" := (<a class="idref" href="Lists.html#NatList.pair"><span class="id" type="constructor">pair</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>).<br/>

<br/>
</div>

<div class="doc">
The new notation can be used both in expressions and in
    pattern matches (indeed, we've seen it already in the previous
    chapter &mdash; this notation is provided as part of the standard
    library): 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Eval</span> <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> (<a class="idref" href="Lists.html#NatList.fst"><span class="id" type="definition">fst</span></a> (3,4)).<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="NatList.fst'"><span class="id" type="definition">fst'</span></a> (<span class="id" type="var">p</span> : <a class="idref" href="Lists.html#NatList.natprod"><span class="id" type="inductive">natprod</span></a>) : <span class="id" type="inductive">nat</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">x</span>,<span class="id" type="var">y</span>) =&gt; <span class="id" type="var">x</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
<span class="id" type="keyword">Definition</span> <a name="NatList.snd'"><span class="id" type="definition">snd'</span></a> (<span class="id" type="var">p</span> : <a class="idref" href="Lists.html#NatList.natprod"><span class="id" type="inductive">natprod</span></a>) : <span class="id" type="inductive">nat</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">x</span>,<span class="id" type="var">y</span>) =&gt; <span class="id" type="var">y</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="NatList.swap_pair"><span class="id" type="definition">swap_pair</span></a> (<span class="id" type="var">p</span> : <a class="idref" href="Lists.html#NatList.natprod"><span class="id" type="inductive">natprod</span></a>) : <a class="idref" href="Lists.html#NatList.natprod"><span class="id" type="inductive">natprod</span></a> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">x</span>,<span class="id" type="var">y</span>) =&gt; (<span class="id" type="var">y</span>,<span class="id" type="var">x</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Let's try and prove a few simple facts about pairs.  If we
    state the lemmas in a particular (and slightly peculiar) way, we
    can prove them with just reflexivity (and its built-in
    simplification): 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.surjective_pairing'"><span class="id" type="lemma">surjective_pairing'</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;(<span class="id" type="var">n</span>,<span class="id" type="var">m</span>) = (<a class="idref" href="Lists.html#NatList.fst"><span class="id" type="definition">fst</span></a> (<span class="id" type="var">n</span>,<span class="id" type="var">m</span>), <a class="idref" href="Lists.html#NatList.snd"><span class="id" type="definition">snd</span></a> (<span class="id" type="var">n</span>,<span class="id" type="var">m</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
But reflexivity is not enough if we state the lemma in a more
    natural way: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.surjective_pairing_stuck"><span class="id" type="lemma">surjective_pairing_stuck</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">p</span> : <a class="idref" href="Lists.html#NatList.natprod"><span class="id" type="inductive">natprod</span></a>),<br/>
&nbsp;&nbsp;<span class="id" type="var">p</span> = (<a class="idref" href="Lists.html#NatList.fst"><span class="id" type="definition">fst</span></a> <span class="id" type="var">p</span>, <a class="idref" href="Lists.html#NatList.snd"><span class="id" type="definition">snd</span></a> <span class="id" type="var">p</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="comment">(*&nbsp;Doesn't&nbsp;reduce&nbsp;anything!&nbsp;*)</span><br/>
<span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
We have to expose the structure of <span class="inlinecode"><span class="id" type="var">p</span></span> so that <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> can
    perform the pattern match in <span class="inlinecode"><span class="id" type="var">fst</span></span> and <span class="inlinecode"><span class="id" type="var">snd</span></span>.  We can do this with
    <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>.

<div class="paragraph"> </div>

    Notice that, unlike for <span class="inlinecode"><span class="id" type="var">nat</span></span>s, <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> doesn't generate an
    extra subgoal here.  That's because <span class="inlinecode"><span class="id" type="var">natprod</span></span>s can only be
    constructed in one way.  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.surjective_pairing"><span class="id" type="lemma">surjective_pairing</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">p</span> : <a class="idref" href="Lists.html#NatList.natprod"><span class="id" type="inductive">natprod</span></a>),<br/>
&nbsp;&nbsp;<span class="id" type="var">p</span> = (<a class="idref" href="Lists.html#NatList.fst"><span class="id" type="definition">fst</span></a> <span class="id" type="var">p</span>, <a class="idref" href="Lists.html#NatList.snd"><span class="id" type="definition">snd</span></a> <span class="id" type="var">p</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">p</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">p</span> <span class="id" type="keyword">as</span> (<span class="id" type="var">n</span>,<span class="id" type="var">m</span>). <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Notice that Coq allows us to use the notation we introduced
    for pairs in the "<span class="inlinecode"><span class="id" type="keyword">as</span></span>..." pattern telling it what variables to
    bind. 
<div class="paragraph"> </div>

<a name="lab48"></a><h4 class="section">Exercise: 1 star (snd_fst_is_swap)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="NatList.snd_fst_is_swap"><span class="id" type="lemma">snd_fst_is_swap</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">p</span> : <a class="idref" href="Lists.html#NatList.natprod"><span class="id" type="inductive">natprod</span></a>),<br/>
&nbsp;&nbsp;(<a class="idref" href="Lists.html#NatList.snd"><span class="id" type="definition">snd</span></a> <span class="id" type="var">p</span>, <a class="idref" href="Lists.html#NatList.fst"><span class="id" type="definition">fst</span></a> <span class="id" type="var">p</span>) = <a class="idref" href="Lists.html#NatList.swap_pair"><span class="id" type="definition">swap_pair</span></a> <span class="id" type="var">p</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab49"></a><h4 class="section">Exercise: 1 star, optional (fst_swap_is_snd)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="NatList.fst_swap_is_snd"><span class="id" type="lemma">fst_swap_is_snd</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">p</span> : <a class="idref" href="Lists.html#NatList.natprod"><span class="id" type="inductive">natprod</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Lists.html#NatList.fst"><span class="id" type="definition">fst</span></a> (<a class="idref" href="Lists.html#NatList.swap_pair"><span class="id" type="definition">swap_pair</span></a> <span class="id" type="var">p</span>) = <a class="idref" href="Lists.html#NatList.snd"><span class="id" type="definition">snd</span></a> <span class="id" type="var">p</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab50"></a><h1 class="section">Lists of Numbers</h1>

<div class="paragraph"> </div>

 Generalizing the definition of pairs a little, we can
    describe the type of <i>lists</i> of numbers like this: "A list is
    either the empty list or else a pair of a number and another
    list." 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="NatList.natlist"><span class="id" type="inductive">natlist</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="NatList.nil"><span class="id" type="constructor">nil</span></a> : <a class="idref" href="Lists.html#natlist"><span class="id" type="inductive">natlist</span></a><br/>
&nbsp;&nbsp;| <a name="NatList.cons"><span class="id" type="constructor">cons</span></a> : <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Lists.html#natlist"><span class="id" type="inductive">natlist</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Lists.html#natlist"><span class="id" type="inductive">natlist</span></a>.<br/>

<br/>
</div>

<div class="doc">
For example, here is a three-element list: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="NatList.l_123"><span class="id" type="definition">l_123</span></a> := <a class="idref" href="Lists.html#NatList.cons"><span class="id" type="constructor">cons</span></a> 1 (<a class="idref" href="Lists.html#NatList.cons"><span class="id" type="constructor">cons</span></a> 2 (<a class="idref" href="Lists.html#NatList.cons"><span class="id" type="constructor">cons</span></a> 3 <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a>)).<br/>

<br/>
</div>

<div class="doc">
As with pairs, it is more convenient to write lists in
    familiar programming notation.  The following two declarations
    allow us to use <span class="inlinecode">::</span> as an infix <span class="inlinecode"><span class="id" type="var">cons</span></span> operator and square
    brackets as an "outfix" notation for constructing lists. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> "x :: l" := (<a class="idref" href="Lists.html#NatList.cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">x</span> <span class="id" type="var">l</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 60, <span class="id" type="var">right</span> <span class="id" type="var">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> "[ ]" := <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a>.<br/>
<span class="id" type="keyword">Notation</span> "[ x , .. , y ]" := (<a class="idref" href="Lists.html#NatList.cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">x</span> .. (<a class="idref" href="Lists.html#NatList.cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">y</span> <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a>) ..).<br/>

<br/>
</div>

<div class="doc">
It is not necessary to fully understand these declarations,
    but in case you are interested, here is roughly what's going on.

<div class="paragraph"> </div>

    The <span class="inlinecode"><span class="id" type="var">right</span></span> <span class="inlinecode"><span class="id" type="var">associativity</span></span> annotation tells Coq how to parenthesize
    expressions involving several uses of <span class="inlinecode">::</span> so that, for example,
    the next three declarations mean exactly the same thing: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="NatList.l_123'"><span class="id" type="definition">l_123'</span></a>   := 1 :: (2 :: (3 :: <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a>)).<br/>
<span class="id" type="keyword">Definition</span> <a name="NatList.l_123''"><span class="id" type="definition">l_123''</span></a>  := 1 :: 2 :: 3 :: <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a>.<br/>
<span class="id" type="keyword">Definition</span> <a name="NatList.l_123'''"><span class="id" type="definition">l_123'''</span></a> := [1,2,3].<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="tactic">at</span></span> <span class="inlinecode"><span class="id" type="var">level</span></span> <span class="inlinecode">60</span> part tells Coq how to parenthesize
    expressions that involve both <span class="inlinecode">::</span> and some other infix operator.
    For example, since we defined <span class="inlinecode">+</span> as infix notation for the <span class="inlinecode"><span class="id" type="var">plus</span></span>
    function at level 50,

<div class="paragraph"> </div>

<div class="code code-tight">
<span class="id" type="keyword">Notation</span>&nbsp;"x + y"&nbsp;:=&nbsp;(<span class="id" type="var">plus</span>&nbsp;<span class="id" type="var">x</span>&nbsp;<span class="id" type="var">y</span>)&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span>&nbsp;<span class="id" type="var">level</span>&nbsp;50,&nbsp;<span class="id" type="var">left</span>&nbsp;<span class="id" type="var">associativity</span>).
<div class="paragraph"> </div>

</div>
   The <span class="inlinecode">+</span> operator will bind tighter than <span class="inlinecode">::</span>, so <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">::</span> <span class="inlinecode">[3]</span>
   will be parsed, as we'd expect, as <span class="inlinecode">(1</span> <span class="inlinecode">+</span> <span class="inlinecode">2)</span> <span class="inlinecode">::</span> <span class="inlinecode">[3]</span> rather than <span class="inlinecode">1</span>
   <span class="inlinecode">+</span> <span class="inlinecode">(2</span> <span class="inlinecode">::</span> <span class="inlinecode">[3])</span>.

<div class="paragraph"> </div>

   (By the way, it's worth noting in passing that expressions like "<span class="inlinecode">1</span>
   <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">::</span> <span class="inlinecode">[3]</span>" can be a little confusing when you read them in a .v
   file.  The inner brackets, around 3, indicate a list, but the outer
   brackets are there to instruct the "coqdoc" tool that the bracketed
   part should be displayed as Coq code rather than running text.
   These brackets don't appear in the generated HTML.)

<div class="paragraph"> </div>

   The second and third <span class="inlinecode"><span class="id" type="keyword">Notation</span></span> declarations above introduce the
   standard square-bracket notation for lists; the right-hand side of
   the third one illustrates Coq's syntax for declaring n-ary
   notations and translating them to nested sequences of binary
   constructors. 
<div class="paragraph"> </div>

 A number of functions are useful for manipulating lists.
    For example, the <span class="inlinecode"><span class="id" type="tactic">repeat</span></span> function takes a number <span class="inlinecode"><span class="id" type="var">n</span></span> and a
    <span class="inlinecode"><span class="id" type="var">count</span></span> and returns a list of length <span class="inlinecode"><span class="id" type="var">count</span></span> where every element
    is <span class="inlinecode"><span class="id" type="var">n</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="NatList.repeat"><span class="id" type="definition">repeat</span></a> (<span class="id" type="var">n</span> <span class="id" type="var">count</span> : <span class="id" type="inductive">nat</span>) : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">count</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="constructor">O</span> =&gt; <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a><br/>
&nbsp;&nbsp;| <span class="id" type="constructor">S</span> <span class="id" type="var">count'</span> =&gt; <span class="id" type="var">n</span> :: (<a class="idref" href="Lists.html#repeat"><span class="id" type="definition">repeat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">count'</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="var">length</span></span> function calculates the length of a list. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="NatList.length"><span class="id" type="definition">length</span></a> (<span class="id" type="var">l</span>:<a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>) : <span class="id" type="inductive">nat</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a> =&gt; <span class="id" type="constructor">O</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">h</span> :: <span class="id" type="var">t</span> =&gt; <span class="id" type="constructor">S</span> (<a class="idref" href="Lists.html#length"><span class="id" type="definition">length</span></a> <span class="id" type="var">t</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="var">app</span></span> ("append") function concatenates two lists. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="NatList.app"><span class="id" type="definition">app</span></a> (<span class="id" type="var">l1</span> <span class="id" type="var">l2</span> : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>) : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l1</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a>    =&gt; <span class="id" type="var">l2</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">h</span> :: <span class="id" type="var">t</span> =&gt; <span class="id" type="var">h</span> :: (<a class="idref" href="Lists.html#app"><span class="id" type="definition">app</span></a> <span class="id" type="var">t</span> <span class="id" type="var">l2</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Actually, <span class="inlinecode"><span class="id" type="var">app</span></span> will be used a lot in some parts of what
    follows, so it is convenient to have an infix operator for it. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> "x ++ y" := (<a class="idref" href="Lists.html#NatList.app"><span class="id" type="definition">app</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">right</span> <span class="id" type="var">associativity</span>, <span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 60).<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_app1"><span class="id" type="definition">test_app1</span></a>:             [1,2,3] ++ [4,5] = [1,2,3,4,5].<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_app2"><span class="id" type="definition">test_app2</span></a>:             <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a> ++ [4,5] = [4,5].<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_app3"><span class="id" type="definition">test_app3</span></a>:             [1,2,3] ++ <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a> = [1,2,3].<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Here are two more small examples of programming with lists.
    The <span class="inlinecode"><span class="id" type="var">hd</span></span> function returns the first element (the "head") of the
    list, while <span class="inlinecode"><span class="id" type="var">tail</span></span> returns everything but the first
    element.  Of course, the empty list has no first element, so we
    must pass a default value to be returned in that case.  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="NatList.hd"><span class="id" type="definition">hd</span></a> (<span class="id" type="var">default</span>:<span class="id" type="inductive">nat</span>) (<span class="id" type="var">l</span>:<a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>) : <span class="id" type="inductive">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a> =&gt; <span class="id" type="var">default</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">h</span> :: <span class="id" type="var">t</span> =&gt; <span class="id" type="var">h</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="NatList.tail"><span class="id" type="definition">tail</span></a> (<span class="id" type="var">l</span>:<a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>) : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a> =&gt; <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a>  <br/>
&nbsp;&nbsp;| <span class="id" type="var">h</span> :: <span class="id" type="var">t</span> =&gt; <span class="id" type="var">t</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_hd1"><span class="id" type="definition">test_hd1</span></a>:             <a class="idref" href="Lists.html#NatList.hd"><span class="id" type="definition">hd</span></a> 0 [1,2,3] = 1.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_hd2"><span class="id" type="definition">test_hd2</span></a>:             <a class="idref" href="Lists.html#NatList.hd"><span class="id" type="definition">hd</span></a> 0 [] = 0.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_tail"><span class="id" type="definition">test_tail</span></a>:            <a class="idref" href="Lists.html#NatList.tail"><span class="id" type="definition">tail</span></a> [1,2,3] = [2,3].<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab51"></a><h4 class="section">Exercise: 2 stars, recommended (list_funs)</h4>
 Complete the definitions of <span class="inlinecode"><span class="id" type="var">nonzeros</span></span>, <span class="inlinecode"><span class="id" type="var">oddmembers</span></span> and
    <span class="inlinecode"><span class="id" type="var">countoddmembers</span></span> below.  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="NatList.nonzeros"><span class="id" type="definition">nonzeros</span></a> (<span class="id" type="var">l</span>:<a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>) : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_nonzeros"><span class="id" type="definition">test_nonzeros</span></a>:            <a class="idref" href="Lists.html#NatList.nonzeros"><span class="id" type="definition">nonzeros</span></a> [0,1,0,2,3,0,0] = [1,2,3].<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="NatList.oddmembers"><span class="id" type="definition">oddmembers</span></a> (<span class="id" type="var">l</span>:<a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>) : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_oddmembers"><span class="id" type="definition">test_oddmembers</span></a>:            <a class="idref" href="Lists.html#NatList.oddmembers"><span class="id" type="definition">oddmembers</span></a> [0,1,0,2,3,0,0] = [1,3].<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="NatList.countoddmembers"><span class="id" type="definition">countoddmembers</span></a> (<span class="id" type="var">l</span>:<a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>) : <span class="id" type="inductive">nat</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_countoddmembers1"><span class="id" type="definition">test_countoddmembers1</span></a>:    <a class="idref" href="Lists.html#NatList.countoddmembers"><span class="id" type="definition">countoddmembers</span></a> [1,0,3,1,4,5] = 4.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_countoddmembers2"><span class="id" type="definition">test_countoddmembers2</span></a>:    <a class="idref" href="Lists.html#NatList.countoddmembers"><span class="id" type="definition">countoddmembers</span></a> [0,2,4] = 0.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_countoddmembers3"><span class="id" type="definition">test_countoddmembers3</span></a>:    <a class="idref" href="Lists.html#NatList.countoddmembers"><span class="id" type="definition">countoddmembers</span></a> <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a> = 0.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab52"></a><h4 class="section">Exercise: 2 stars (alternate)</h4>
 Complete the definition of <span class="inlinecode"><span class="id" type="var">alternate</span></span>, which "zips up" two lists
    into one, alternating between elements taken from the first list
    and elements from the second.  See the tests below for more
    specific examples.

<div class="paragraph"> </div>

    Note: one natural way of writing <span class="inlinecode"><span class="id" type="var">alternate</span></span> will fail to satisfy
    Coq's requirement that all <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span> definitions be "obviously
    terminating."  If you find yourself in this rut, look for a
    slightly more verbose solution that considers elements of both
    lists at the same time. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="NatList.alternate"><span class="id" type="definition">alternate</span></a> (<span class="id" type="var">l1</span> <span class="id" type="var">l2</span> : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>) : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_alternate1"><span class="id" type="definition">test_alternate1</span></a>:        <a class="idref" href="Lists.html#NatList.alternate"><span class="id" type="definition">alternate</span></a> [1,2,3] [4,5,6] = [1,4,2,5,3,6].<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_alternate2"><span class="id" type="definition">test_alternate2</span></a>:        <a class="idref" href="Lists.html#NatList.alternate"><span class="id" type="definition">alternate</span></a> [1] [4,5,6] = [1,4,5,6].<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_alternate3"><span class="id" type="definition">test_alternate3</span></a>:        <a class="idref" href="Lists.html#NatList.alternate"><span class="id" type="definition">alternate</span></a> [1,2,3] [4] = [1,4,2,3].<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_alternate4"><span class="id" type="definition">test_alternate4</span></a>:        <a class="idref" href="Lists.html#NatList.alternate"><span class="id" type="definition">alternate</span></a> [] [20,30] = [20,30].<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab53"></a><h2 class="section">Bags via Lists</h2>

<div class="paragraph"> </div>

 A <span class="inlinecode"><span class="id" type="var">bag</span></span> (or <span class="inlinecode"><span class="id" type="var">multiset</span></span>) is like a set, but each element can appear
    multiple times instead of just once.  One reasonable
    implementation of bags is to represent a bag of numbers as a
    list. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="NatList.bag"><span class="id" type="definition">bag</span></a> := <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab54"></a><h4 class="section">Exercise: 3 stars (bag_functions)</h4>
 Complete the following definitions for the functions
    <span class="inlinecode"><span class="id" type="var">count</span></span>, <span class="inlinecode"><span class="id" type="var">sum</span></span>, <span class="inlinecode"><span class="id" type="var">add</span></span>, and <span class="inlinecode"><span class="id" type="var">member</span></span> for bags. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="NatList.count"><span class="id" type="definition">count</span></a> (<span class="id" type="var">v</span>:<span class="id" type="inductive">nat</span>) (<span class="id" type="var">s</span>:<a class="idref" href="Lists.html#NatList.bag"><span class="id" type="definition">bag</span></a>) : <span class="id" type="inductive">nat</span> := <br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
</div>

<div class="doc">
All these proofs can be done just by <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_count1"><span class="id" type="definition">test_count1</span></a>:              <a class="idref" href="Lists.html#NatList.count"><span class="id" type="definition">count</span></a> 1 [1,2,3,1,4,1] = 3.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_count2"><span class="id" type="definition">test_count2</span></a>:              <a class="idref" href="Lists.html#NatList.count"><span class="id" type="definition">count</span></a> 6 [1,2,3,1,4,1] = 0.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Multiset <span class="inlinecode"><span class="id" type="var">sum</span></span> is similar to set <span class="inlinecode"><span class="id" type="var">union</span></span>: <span class="inlinecode"><span class="id" type="var">sum</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode"><span class="id" type="var">b</span></span> contains
    all the elements of <span class="inlinecode"><span class="id" type="var">a</span></span> and of <span class="inlinecode"><span class="id" type="var">b</span></span>.  (Mathematicians usually
    define <span class="inlinecode"><span class="id" type="var">union</span></span> on multisets a little bit differently, which
    is why we don't use that name for this operation.)
    For <span class="inlinecode"><span class="id" type="var">sum</span></span> we're giving you a header that does not give explicit
    names to the arguments.  Moreover, it uses the keyword
    <span class="inlinecode"><span class="id" type="keyword">Definition</span></span> instead of <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>, so even if you had names for
    the arguments, you wouldn't be able to process them recursively.
    The point of stating the question this way is to encourage you to
    think about whether <span class="inlinecode"><span class="id" type="var">sum</span></span> can be implemented in another way &mdash;
    perhaps by using functions that have already been defined.  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="NatList.sum"><span class="id" type="definition">sum</span></a> : <a class="idref" href="Lists.html#NatList.bag"><span class="id" type="definition">bag</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Lists.html#NatList.bag"><span class="id" type="definition">bag</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Lists.html#NatList.bag"><span class="id" type="definition">bag</span></a> := <br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_sum1"><span class="id" type="definition">test_sum1</span></a>:              <a class="idref" href="Lists.html#NatList.count"><span class="id" type="definition">count</span></a> 1 (<a class="idref" href="Lists.html#NatList.sum"><span class="id" type="definition">sum</span></a> [1,2,3] [1,4,1]) = 3.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="NatList.add"><span class="id" type="definition">add</span></a> (<span class="id" type="var">v</span>:<span class="id" type="inductive">nat</span>) (<span class="id" type="var">s</span>:<a class="idref" href="Lists.html#NatList.bag"><span class="id" type="definition">bag</span></a>) : <a class="idref" href="Lists.html#NatList.bag"><span class="id" type="definition">bag</span></a> := <br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_add1"><span class="id" type="definition">test_add1</span></a>:                <a class="idref" href="Lists.html#NatList.count"><span class="id" type="definition">count</span></a> 1 (<a class="idref" href="Lists.html#NatList.add"><span class="id" type="definition">add</span></a> 1 [1,4,1]) = 3.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_add2"><span class="id" type="definition">test_add2</span></a>:                <a class="idref" href="Lists.html#NatList.count"><span class="id" type="definition">count</span></a> 5 (<a class="idref" href="Lists.html#NatList.add"><span class="id" type="definition">add</span></a> 1 [1,4,1]) = 0.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="NatList.member"><span class="id" type="definition">member</span></a> (<span class="id" type="var">v</span>:<span class="id" type="inductive">nat</span>) (<span class="id" type="var">s</span>:<a class="idref" href="Lists.html#NatList.bag"><span class="id" type="definition">bag</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a> := <br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_member1"><span class="id" type="definition">test_member1</span></a>:             <a class="idref" href="Lists.html#NatList.member"><span class="id" type="definition">member</span></a> 1 [1,4,1] = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_member2"><span class="id" type="definition">test_member2</span></a>:             <a class="idref" href="Lists.html#NatList.member"><span class="id" type="definition">member</span></a> 2 [1,4,1] = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab55"></a><h4 class="section">Exercise: 3 stars, optional (bag_more_functions)</h4>
 Here are some more bag functions for you to practice with. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="NatList.remove_one"><span class="id" type="definition">remove_one</span></a> (<span class="id" type="var">v</span>:<span class="id" type="inductive">nat</span>) (<span class="id" type="var">s</span>:<a class="idref" href="Lists.html#NatList.bag"><span class="id" type="definition">bag</span></a>) : <a class="idref" href="Lists.html#NatList.bag"><span class="id" type="definition">bag</span></a> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;When&nbsp;remove_one&nbsp;is&nbsp;applied&nbsp;to&nbsp;a&nbsp;bag&nbsp;without&nbsp;the&nbsp;number&nbsp;to&nbsp;remove,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it&nbsp;should&nbsp;return&nbsp;the&nbsp;same&nbsp;bag&nbsp;unchanged.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_remove_one1"><span class="id" type="definition">test_remove_one1</span></a>:         <a class="idref" href="Lists.html#NatList.count"><span class="id" type="definition">count</span></a> 5 (<a class="idref" href="Lists.html#NatList.remove_one"><span class="id" type="definition">remove_one</span></a> 5 [2,1,5,4,1]) = 0.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_remove_one2"><span class="id" type="definition">test_remove_one2</span></a>:         <a class="idref" href="Lists.html#NatList.count"><span class="id" type="definition">count</span></a> 5 (<a class="idref" href="Lists.html#NatList.remove_one"><span class="id" type="definition">remove_one</span></a> 5 [2,1,4,1]) = 0.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_remove_one3"><span class="id" type="definition">test_remove_one3</span></a>:         <a class="idref" href="Lists.html#NatList.count"><span class="id" type="definition">count</span></a> 4 (<a class="idref" href="Lists.html#NatList.remove_one"><span class="id" type="definition">remove_one</span></a> 5 [2,1,4,5,1,4]) = 2.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_remove_one4"><span class="id" type="definition">test_remove_one4</span></a>: <br/>
&nbsp;&nbsp;<a class="idref" href="Lists.html#NatList.count"><span class="id" type="definition">count</span></a> 5 (<a class="idref" href="Lists.html#NatList.remove_one"><span class="id" type="definition">remove_one</span></a> 5 [2,1,5,4,5,1,4]) = 1.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="NatList.remove_all"><span class="id" type="definition">remove_all</span></a> (<span class="id" type="var">v</span>:<span class="id" type="inductive">nat</span>) (<span class="id" type="var">s</span>:<a class="idref" href="Lists.html#NatList.bag"><span class="id" type="definition">bag</span></a>) : <a class="idref" href="Lists.html#NatList.bag"><span class="id" type="definition">bag</span></a> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_remove_all1"><span class="id" type="definition">test_remove_all1</span></a>:          <a class="idref" href="Lists.html#NatList.count"><span class="id" type="definition">count</span></a> 5 (<a class="idref" href="Lists.html#NatList.remove_all"><span class="id" type="definition">remove_all</span></a> 5 [2,1,5,4,1]) = 0.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_remove_all2"><span class="id" type="definition">test_remove_all2</span></a>:          <a class="idref" href="Lists.html#NatList.count"><span class="id" type="definition">count</span></a> 5 (<a class="idref" href="Lists.html#NatList.remove_all"><span class="id" type="definition">remove_all</span></a> 5 [2,1,4,1]) = 0.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_remove_all3"><span class="id" type="definition">test_remove_all3</span></a>:          <a class="idref" href="Lists.html#NatList.count"><span class="id" type="definition">count</span></a> 4 (<a class="idref" href="Lists.html#NatList.remove_all"><span class="id" type="definition">remove_all</span></a> 5 [2,1,4,5,1,4]) = 2.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_remove_all4"><span class="id" type="definition">test_remove_all4</span></a>:          <a class="idref" href="Lists.html#NatList.count"><span class="id" type="definition">count</span></a> 5 (<a class="idref" href="Lists.html#NatList.remove_all"><span class="id" type="definition">remove_all</span></a> 5 [2,1,5,4,5,1,4,5,1,4]) = 0.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="NatList.subset"><span class="id" type="definition">subset</span></a> (<span class="id" type="var">s1</span>:<a class="idref" href="Lists.html#NatList.bag"><span class="id" type="definition">bag</span></a>) (<span class="id" type="var">s2</span>:<a class="idref" href="Lists.html#NatList.bag"><span class="id" type="definition">bag</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_subset1"><span class="id" type="definition">test_subset1</span></a>:              <a class="idref" href="Lists.html#NatList.subset"><span class="id" type="definition">subset</span></a> [1,2] [2,1,4,1] = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_subset2"><span class="id" type="definition">test_subset2</span></a>:              <a class="idref" href="Lists.html#NatList.subset"><span class="id" type="definition">subset</span></a> [1,2,2] [2,1,4,1] = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab56"></a><h4 class="section">Exercise: 3 stars, recommended (bag_theorem)</h4>
 Write down an interesting theorem about bags involving the
    functions <span class="inlinecode"><span class="id" type="var">count</span></span> and <span class="inlinecode"><span class="id" type="var">add</span></span>, and prove it.  Note that, since this
    problem is somewhat open-ended, it's possible that you may come up
    with a theorem which is true, but whose proof requires techniques
    you haven't learned yet.  Feel free to ask for help if you get
    stuck!

<div class="paragraph"> </div>

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
 
<div class="paragraph"> </div>

<a name="lab57"></a><h1 class="section">Reasoning About Lists</h1>

<div class="paragraph"> </div>

 Just as with numbers, simple facts about list-processing
    functions can sometimes be proved entirely by simplification. For
    example, the simplification performed by <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> is enough
    for this theorem... 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.nil_app"><span class="id" type="lemma">nil_app</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">l</span>:<a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>,<br/>
&nbsp;&nbsp;[] ++ <span class="id" type="var">l</span> = <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
... because the <span class="inlinecode">[]</span> is substituted into the match position
    in the definition of <span class="inlinecode"><span class="id" type="var">app</span></span>, allowing the match itself to be
    simplified. 
<div class="paragraph"> </div>

 Also, as with numbers, it is sometimes helpful to perform case
    analysis on the possible shapes (empty or non-empty) of an unknown
    list. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.tl_length_pred"><span class="id" type="lemma">tl_length_pred</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">l</span>:<a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>,<br/>
&nbsp;&nbsp;<span class="id" type="definition">pred</span> (<a class="idref" href="Lists.html#NatList.length"><span class="id" type="definition">length</span></a> <span class="id" type="var">l</span>) = <a class="idref" href="Lists.html#NatList.length"><span class="id" type="definition">length</span></a> (<a class="idref" href="Lists.html#NatList.tail"><span class="id" type="definition">tail</span></a> <span class="id" type="var">l</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">l</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n</span> <span class="id" type="var">l'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "l = nil".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "l = cons n l'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Here, the <span class="inlinecode"><span class="id" type="var">nil</span></span> case works because we've chosen to define
    <span class="inlinecode"><span class="id" type="var">tl</span></span> <span class="inlinecode"><span class="id" type="var">nil</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">nil</span></span>. Notice that the <span class="inlinecode"><span class="id" type="keyword">as</span></span> annotation on the <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>
    tactic here introduces two names, <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">l'</span></span>, corresponding to
    the fact that the <span class="inlinecode"><span class="id" type="var">cons</span></span> constructor for lists takes two
    arguments (the head and tail of the list it is constructing). 
<div class="paragraph"> </div>

 Usually, though, interesting theorems about lists require
    induction for their proofs. 
<div class="paragraph"> </div>

<a name="lab58"></a><h2 class="section">Micro-Sermon</h2>

<div class="paragraph"> </div>

 Simply reading example proofs will not get you very far!  It is
    very important to work through the details of each one, using Coq
    and thinking about what each step of the proof achieves.
    Otherwise it is more or less guaranteed that the exercises will
    make no sense. 
<div class="paragraph"> </div>

<a name="lab59"></a><h2 class="section">Induction on Lists</h2>

<div class="paragraph"> </div>

 Proofs by induction over datatypes like <span class="inlinecode"><span class="id" type="var">natlist</span></span> are
    perhaps a little less familiar than standard natural number
    induction, but the basic idea is equally simple.  Each <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span>
    declaration defines a set of data values that can be built up from
    the declared constructors: a boolean can be either <span class="inlinecode"><span class="id" type="var">true</span></span> or
    <span class="inlinecode"><span class="id" type="var">false</span></span>; a number can be either <span class="inlinecode"><span class="id" type="var">O</span></span> or <span class="inlinecode"><span class="id" type="var">S</span></span> applied to a number; a
    list can be either <span class="inlinecode"><span class="id" type="var">nil</span></span> or <span class="inlinecode"><span class="id" type="var">cons</span></span> applied to a number and a list.

<div class="paragraph"> </div>

    Moreover, applications of the declared constructors to one another
    are the <i>only</i> possible shapes that elements of an inductively
    defined set can have, and this fact directly gives rise to a way
    of reasoning about inductively defined sets: a number is either
    <span class="inlinecode"><span class="id" type="var">O</span></span> or else it is <span class="inlinecode"><span class="id" type="var">S</span></span> applied to some <i>smaller</i> number; a list is
    either <span class="inlinecode"><span class="id" type="var">nil</span></span> or else it is <span class="inlinecode"><span class="id" type="var">cons</span></span> applied to some number and some
    <i>smaller</i> list; etc. So, if we have in mind some proposition <span class="inlinecode"><span class="id" type="var">P</span></span>
    that mentions a list <span class="inlinecode"><span class="id" type="var">l</span></span> and we want to argue that <span class="inlinecode"><span class="id" type="var">P</span></span> holds for
    <i>all</i> lists, we can reason as follows:

<div class="paragraph"> </div>

<ul class="doclist">
<li> First, show that <span class="inlinecode"><span class="id" type="var">P</span></span> is true of <span class="inlinecode"><span class="id" type="var">l</span></span> when <span class="inlinecode"><span class="id" type="var">l</span></span> is <span class="inlinecode"><span class="id" type="var">nil</span></span>.

<div class="paragraph"> </div>


</li>
<li> Then show that <span class="inlinecode"><span class="id" type="var">P</span></span> is true of <span class="inlinecode"><span class="id" type="var">l</span></span> when <span class="inlinecode"><span class="id" type="var">l</span></span> is <span class="inlinecode"><span class="id" type="var">cons</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">l'</span></span> for
        some number <span class="inlinecode"><span class="id" type="var">n</span></span> and some smaller list <span class="inlinecode"><span class="id" type="var">l'</span></span>, asssuming that <span class="inlinecode"><span class="id" type="var">P</span></span>
        is true for <span class="inlinecode"><span class="id" type="var">l'</span></span>.

</li>
</ul>

<div class="paragraph"> </div>

    Since larger lists can only be built up from smaller ones,
    eventually reaching <span class="inlinecode"><span class="id" type="var">nil</span></span>, these two things together establish the
    truth of <span class="inlinecode"><span class="id" type="var">P</span></span> for all lists <span class="inlinecode"><span class="id" type="var">l</span></span>.  Here's a concrete example: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.app_ass"><span class="id" type="lemma">app_ass</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">l1</span> <span class="id" type="var">l2</span> <span class="id" type="var">l3</span> : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>, <br/>
&nbsp;&nbsp;(<span class="id" type="var">l1</span> ++ <span class="id" type="var">l2</span>) ++ <span class="id" type="var">l3</span> = <span class="id" type="var">l1</span> ++ (<span class="id" type="var">l2</span> ++ <span class="id" type="var">l3</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">l1</span> <span class="id" type="var">l2</span> <span class="id" type="var">l3</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l1</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n</span> <span class="id" type="var">l1'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "l1 = nil".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "l1 = cons n l1'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">IHl1'</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Again, this Coq proof is not especially illuminating as a
    static written document &mdash; it is easy to see what's going on if
    you are reading the proof in an interactive Coq session and you
    can see the current goal and context at each point, but this state
    is not visible in the written-down parts of the Coq proof.  So a
    natural-language proof &mdash; one written for human readers &mdash; will
    need to include more explicit signposts; in particular, it will
    help the reader stay oriented if we remind them exactly what the
    induction hypothesis is in the second case.  
<div class="paragraph"> </div>

 <i>Theorem</i>: For all lists <span class="inlinecode"><span class="id" type="var">l1</span></span>, <span class="inlinecode"><span class="id" type="var">l2</span></span>, and <span class="inlinecode"><span class="id" type="var">l3</span></span>, 
   <span class="inlinecode">(<span class="id" type="var">l1</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">l2</span>)</span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">l3</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">l1</span></span> <span class="inlinecode">++</span> <span class="inlinecode">(<span class="id" type="var">l2</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">l3</span>)</span>.

<div class="paragraph"> </div>

   <i>Proof</i>: By induction on <span class="inlinecode"><span class="id" type="var">l1</span></span>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> First, suppose <span class="inlinecode"><span class="id" type="var">l1</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>.  We must show

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;([]&nbsp;++&nbsp;<span class="id" type="var">l2</span>)&nbsp;++&nbsp;<span class="id" type="var">l3</span>&nbsp;=&nbsp;[]&nbsp;++&nbsp;(<span class="id" type="var">l2</span>&nbsp;++&nbsp;<span class="id" type="var">l3</span>),
<div class="paragraph"> </div>

</div>
     which follows directly from the definition of <span class="inlinecode">++</span>.

<div class="paragraph"> </div>


</li>
<li> Next, suppose <span class="inlinecode"><span class="id" type="var">l1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">n</span>::<span class="id" type="var">l1'</span></span>, with

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;(<span class="id" type="var">l1'</span>&nbsp;++&nbsp;<span class="id" type="var">l2</span>)&nbsp;++&nbsp;<span class="id" type="var">l3</span>&nbsp;=&nbsp;<span class="id" type="var">l1'</span>&nbsp;++&nbsp;(<span class="id" type="var">l2</span>&nbsp;++&nbsp;<span class="id" type="var">l3</span>)
<div class="paragraph"> </div>

</div>
     (the induction hypothesis). We must show

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;((<span class="id" type="var">n</span>&nbsp;::&nbsp;<span class="id" type="var">l1'</span>)&nbsp;++&nbsp;<span class="id" type="var">l2</span>)&nbsp;++&nbsp;<span class="id" type="var">l3</span>&nbsp;=&nbsp;(<span class="id" type="var">n</span>&nbsp;::&nbsp;<span class="id" type="var">l1'</span>)&nbsp;++&nbsp;(<span class="id" type="var">l2</span>&nbsp;++&nbsp;<span class="id" type="var">l3</span>).
<div class="paragraph"> </div>

</div>
     By the definition of <span class="inlinecode">++</span>, this follows from

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">n</span>&nbsp;::&nbsp;((<span class="id" type="var">l1'</span>&nbsp;++&nbsp;<span class="id" type="var">l2</span>)&nbsp;++&nbsp;<span class="id" type="var">l3</span>)&nbsp;=&nbsp;<span class="id" type="var">n</span>&nbsp;::&nbsp;(<span class="id" type="var">l1'</span>&nbsp;++&nbsp;(<span class="id" type="var">l2</span>&nbsp;++&nbsp;<span class="id" type="var">l3</span>)),
<div class="paragraph"> </div>

</div>
     which is immediate from the induction hypothesis.  <font size=-2>&#9744;</font>

</li>
</ul>

<div class="paragraph"> </div>

  Here is an exercise to be worked together in class: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.app_length"><span class="id" type="lemma">app_length</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">l1</span> <span class="id" type="var">l2</span> : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Lists.html#NatList.length"><span class="id" type="definition">length</span></a> (<span class="id" type="var">l1</span> ++ <span class="id" type="var">l2</span>) = (<a class="idref" href="Lists.html#NatList.length"><span class="id" type="definition">length</span></a> <span class="id" type="var">l1</span>) + (<a class="idref" href="Lists.html#NatList.length"><span class="id" type="definition">length</span></a> <span class="id" type="var">l2</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">l1</span> <span class="id" type="var">l2</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l1</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n</span> <span class="id" type="var">l1'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "l1 = nil".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "l1 = cons".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">IHl1'</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
For a slightly more involved example of an inductive proof
    over lists, suppose we define a "cons on the right" function
    <span class="inlinecode"><span class="id" type="var">snoc</span></span> like this... 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="NatList.snoc"><span class="id" type="definition">snoc</span></a> (<span class="id" type="var">l</span>:<a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>) (<span class="id" type="var">v</span>:<span class="id" type="inductive">nat</span>) : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a>    =&gt; [<span class="id" type="var">v</span>]<br/>
&nbsp;&nbsp;| <span class="id" type="var">h</span> :: <span class="id" type="var">t</span> =&gt; <span class="id" type="var">h</span> :: (<a class="idref" href="Lists.html#snoc"><span class="id" type="definition">snoc</span></a> <span class="id" type="var">t</span> <span class="id" type="var">v</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
... and use it to define a list-reversing function <span class="inlinecode"><span class="id" type="var">rev</span></span>
    like this: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="NatList.rev"><span class="id" type="definition">rev</span></a> (<span class="id" type="var">l</span>:<a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>) : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a>    =&gt; <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a><br/>
&nbsp;&nbsp;| <span class="id" type="var">h</span> :: <span class="id" type="var">t</span> =&gt; <a class="idref" href="Lists.html#NatList.snoc"><span class="id" type="definition">snoc</span></a> (<a class="idref" href="Lists.html#rev"><span class="id" type="definition">rev</span></a> <span class="id" type="var">t</span>) <span class="id" type="var">h</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_rev1"><span class="id" type="definition">test_rev1</span></a>:            <a class="idref" href="Lists.html#NatList.rev"><span class="id" type="definition">rev</span></a> [1,2,3] = [3,2,1].<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_rev2"><span class="id" type="definition">test_rev2</span></a>:            <a class="idref" href="Lists.html#NatList.rev"><span class="id" type="definition">rev</span></a> <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a> = <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Now let's prove some more list theorems using our newly
    defined <span class="inlinecode"><span class="id" type="var">snoc</span></span> and <span class="inlinecode"><span class="id" type="var">rev</span></span>.  For something a little more challenging
    than the inductive proofs we've seen so far, let's prove that
    reversing a list does not change its length.  Our first attempt at
    this proof gets stuck in the successor case... 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.rev_length_firsttry"><span class="id" type="lemma">rev_length_firsttry</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">l</span> : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Lists.html#NatList.length"><span class="id" type="definition">length</span></a> (<a class="idref" href="Lists.html#NatList.rev"><span class="id" type="definition">rev</span></a> <span class="id" type="var">l</span>) = <a class="idref" href="Lists.html#NatList.length"><span class="id" type="definition">length</span></a> <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">l</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n</span> <span class="id" type="var">l'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "l = []".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "l = n :: l'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="comment">(*&nbsp;Here&nbsp;we&nbsp;are&nbsp;stuck:&nbsp;the&nbsp;goal&nbsp;is&nbsp;an&nbsp;equality&nbsp;involving<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="var">snoc</span></span>,&nbsp;but&nbsp;we&nbsp;don't&nbsp;have&nbsp;any&nbsp;equations&nbsp;in&nbsp;either&nbsp;the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;immediate&nbsp;context&nbsp;or&nbsp;the&nbsp;global&nbsp;environment&nbsp;that&nbsp;have<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;anything&nbsp;to&nbsp;do&nbsp;with&nbsp;<span class="inlinecode"><span class="id" type="var">snoc</span></span>!&nbsp;*)</span><br/>
<span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
So let's take the equation about <span class="inlinecode"><span class="id" type="var">snoc</span></span> that would have
    enabled us to make progress and prove it as a separate lemma. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.length_snoc"><span class="id" type="lemma">length_snoc</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> : <span class="id" type="inductive">nat</span>, <span style="font-family: arial;">&forall;</span> <span class="id" type="var">l</span> : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Lists.html#NatList.length"><span class="id" type="definition">length</span></a> (<a class="idref" href="Lists.html#NatList.snoc"><span class="id" type="definition">snoc</span></a> <span class="id" type="var">l</span> <span class="id" type="var">n</span>) = <span class="id" type="constructor">S</span> (<a class="idref" href="Lists.html#NatList.length"><span class="id" type="definition">length</span></a> <span class="id" type="var">l</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">l</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">l'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "l = nil".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "l = cons n' l'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">IHl'</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Now we can complete the original proof. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.rev_length"><span class="id" type="lemma">rev_length</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">l</span> : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Lists.html#NatList.length"><span class="id" type="definition">length</span></a> (<a class="idref" href="Lists.html#NatList.rev"><span class="id" type="definition">rev</span></a> <span class="id" type="var">l</span>) = <a class="idref" href="Lists.html#NatList.length"><span class="id" type="definition">length</span></a> <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">l</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n</span> <span class="id" type="var">l'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "l = nil".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "l = cons".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Lists.html#NatList.length_snoc"><span class="id" type="lemma">length_snoc</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">IHl'</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
For comparison, here are <i>informal</i> proofs of these two theorems: 

<div class="paragraph"> </div>

    <i>Theorem</i>: For all numbers <span class="inlinecode"><span class="id" type="var">n</span></span> and lists <span class="inlinecode"><span class="id" type="var">l</span></span>,
       <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode">(<span class="id" type="var">snoc</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">length</span></span> <span class="inlinecode"><span class="id" type="var">l</span>)</span>.

<div class="paragraph"> </div>

    <i>Proof</i>: By induction on <span class="inlinecode"><span class="id" type="var">l</span></span>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> First, suppose <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>.  We must show

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">snoc</span>&nbsp;[]&nbsp;<span class="id" type="var">n</span>)&nbsp;=&nbsp;<span class="id" type="var">S</span>&nbsp;(<span class="id" type="var">length</span>&nbsp;[]),
<div class="paragraph"> </div>

</div>
      which follows directly from the definitions of
      <span class="inlinecode"><span class="id" type="var">length</span></span> and <span class="inlinecode"><span class="id" type="var">snoc</span></span>.

<div class="paragraph"> </div>


</li>
<li> Next, suppose <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">n'</span>::<span class="id" type="var">l'</span></span>, with

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">snoc</span>&nbsp;<span class="id" type="var">l'</span>&nbsp;<span class="id" type="var">n</span>)&nbsp;=&nbsp;<span class="id" type="var">S</span>&nbsp;(<span class="id" type="var">length</span>&nbsp;<span class="id" type="var">l'</span>).
<div class="paragraph"> </div>

</div>
      We must show

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">snoc</span>&nbsp;(<span class="id" type="var">n'</span>&nbsp;::&nbsp;<span class="id" type="var">l'</span>)&nbsp;<span class="id" type="var">n</span>)&nbsp;=&nbsp;<span class="id" type="var">S</span>&nbsp;(<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">n'</span>&nbsp;::&nbsp;<span class="id" type="var">l'</span>)).
<div class="paragraph"> </div>

</div>
      By the definitions of <span class="inlinecode"><span class="id" type="var">length</span></span> and <span class="inlinecode"><span class="id" type="var">snoc</span></span>, this
      follows from

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">S</span>&nbsp;(<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">snoc</span>&nbsp;<span class="id" type="var">l'</span>&nbsp;<span class="id" type="var">n</span>))&nbsp;=&nbsp;<span class="id" type="var">S</span>&nbsp;(<span class="id" type="var">S</span>&nbsp;(<span class="id" type="var">length</span>&nbsp;<span class="id" type="var">l'</span>)),
<div class="paragraph"> </div>

</div>
      which is immediate from the induction hypothesis. <font size=-2>&#9744;</font> 
</li>
</ul>

<div class="paragraph"> </div>

 <i>Theorem</i>: For all lists <span class="inlinecode"><span class="id" type="var">l</span></span>, <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode">(<span class="id" type="var">rev</span></span> <span class="inlinecode"><span class="id" type="var">l</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span>.

<div class="paragraph"> </div>

    <i>Proof</i>: By induction on <span class="inlinecode"><span class="id" type="var">l</span></span>.  

<div class="paragraph"> </div>

<ul class="doclist">
<li> First, suppose <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>.  We must show

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">rev</span>&nbsp;[])&nbsp;=&nbsp;<span class="id" type="var">length</span>&nbsp;[],
<div class="paragraph"> </div>

</div>
        which follows directly from the definitions of <span class="inlinecode"><span class="id" type="var">length</span></span> 
        and <span class="inlinecode"><span class="id" type="var">rev</span></span>.

<div class="paragraph"> </div>


</li>
<li> Next, suppose <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">n</span>::<span class="id" type="var">l'</span></span>, with

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l'</span>)&nbsp;=&nbsp;<span class="id" type="var">length</span>&nbsp;<span class="id" type="var">l'</span>.
<div class="paragraph"> </div>

</div>
        We must show

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">rev</span>&nbsp;(<span class="id" type="var">n</span>&nbsp;::&nbsp;<span class="id" type="var">l'</span>))&nbsp;=&nbsp;<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">n</span>&nbsp;::&nbsp;<span class="id" type="var">l'</span>).
<div class="paragraph"> </div>

</div>
        By the definition of <span class="inlinecode"><span class="id" type="var">rev</span></span>, this follows from

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">snoc</span>&nbsp;(<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l'</span>)&nbsp;<span class="id" type="var">n</span>)&nbsp;=&nbsp;<span class="id" type="var">S</span>&nbsp;(<span class="id" type="var">length</span>&nbsp;<span class="id" type="var">l'</span>)
<div class="paragraph"> </div>

</div>
        which, by the previous lemma, is the same as

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">S</span>&nbsp;(<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l'</span>))&nbsp;=&nbsp;<span class="id" type="var">S</span>&nbsp;(<span class="id" type="var">length</span>&nbsp;<span class="id" type="var">l'</span>).
<div class="paragraph"> </div>

</div>
        This is immediate from the induction hypothesis. <font size=-2>&#9744;</font> 
</li>
</ul>

<div class="paragraph"> </div>

 Obviously, the style of these proofs is rather longwinded
    and pedantic.  After the first few, we might find it easier to
    follow proofs that give a little less detail overall (since we can
    easily work them out in our own minds or on scratch paper if
    necessary) and just highlight the non-obvious steps.  In this more
    compressed style, the above proof might look more like this: 
<div class="paragraph"> </div>

 <i>Theorem</i>:
     For all lists <span class="inlinecode"><span class="id" type="var">l</span></span>, <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode">(<span class="id" type="var">rev</span></span> <span class="inlinecode"><span class="id" type="var">l</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span>.

<div class="paragraph"> </div>

    <i>Proof</i>: First, observe that

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">snoc</span>&nbsp;<span class="id" type="var">l</span>&nbsp;<span class="id" type="var">n</span>)&nbsp;=&nbsp;<span class="id" type="var">S</span>&nbsp;(<span class="id" type="var">length</span>&nbsp;<span class="id" type="var">l</span>)
<div class="paragraph"> </div>

</div>
     for any <span class="inlinecode"><span class="id" type="var">l</span></span>.  This follows by a straightforward induction on <span class="inlinecode"><span class="id" type="var">l</span></span>.
     The main property now follows by another straightforward
     induction on <span class="inlinecode"><span class="id" type="var">l</span></span>, using the observation together with the
     induction hypothesis in the case where <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">n'</span>::<span class="id" type="var">l'</span></span>. <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Which style is preferable in a given situation depends on
    the sophistication of the expected audience and on how similar the
    proof at hand is to ones that the audience will already be
    familiar with.  The more pedantic style is a good default for
    present purposes. 
<div class="paragraph"> </div>

<a name="lab60"></a><h2 class="section"><span class="inlinecode"><span class="id" type="var">SearchAbout</span></span></h2>

<div class="paragraph"> </div>

 We've seen that proofs can make use of other theorems we've
    already proved, using <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>, and later we will see other ways
    of reusing previous theorems.  But in order to refer to a theorem,
    we need to know its name, and remembering the names of all the
    theorems we might ever want to use can become quite difficult!  It
    is often hard even to remember what theorems have been proven,
    much less what they are named.

<div class="paragraph"> </div>

    Coq's <span class="inlinecode"><span class="id" type="var">SearchAbout</span></span> command is quite helpful with this.  Typing
    <span class="inlinecode"><span class="id" type="var">SearchAbout</span></span> <span class="inlinecode"><span class="id" type="var">foo</span></span> will cause Coq to display a list of all theorems
    involving <span class="inlinecode"><span class="id" type="var">foo</span></span>.  For example, try uncommenting the following to
    see a list of theorems that we have proved about <span class="inlinecode"><span class="id" type="var">rev</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;SearchAbout&nbsp;rev.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Keep <span class="inlinecode"><span class="id" type="var">SearchAbout</span></span> in mind as you do the following exercises and
    throughout the rest of the course; it can save you a lot of time! 
<div class="paragraph"> </div>

 Also, if you are using ProofGeneral, you can run <span class="inlinecode"><span class="id" type="var">SearchAbout</span></span>
    with <span class="inlinecode"><span class="id" type="var">C</span>-<span class="id" type="var">c</span></span> <span class="inlinecode"><span class="id" type="var">C</span>-<span class="id" type="var">f</span></span>. Pasting its response into your buffer can be
    accomplished with <span class="inlinecode"><span class="id" type="var">C</span>-<span class="id" type="var">c</span></span> <span class="inlinecode"><span class="id" type="var">C</span>-;</span>. 
<div class="paragraph"> </div>

<a name="lab61"></a><h2 class="section">List Exercises, Part 1</h2>

<div class="paragraph"> </div>

<a name="lab62"></a><h4 class="section">Exercise: 3 stars, recommended (list_exercises)</h4>
 More practice with lists. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.app_nil_end"><span class="id" type="lemma">app_nil_end</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">l</span> : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>, <br/>
&nbsp;&nbsp;<span class="id" type="var">l</span> ++ [] = <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.rev_involutive"><span class="id" type="lemma">rev_involutive</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">l</span> : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Lists.html#NatList.rev"><span class="id" type="definition">rev</span></a> (<a class="idref" href="Lists.html#NatList.rev"><span class="id" type="definition">rev</span></a> <span class="id" type="var">l</span>) = <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.distr_rev"><span class="id" type="lemma">distr_rev</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">l1</span> <span class="id" type="var">l2</span> : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Lists.html#NatList.rev"><span class="id" type="definition">rev</span></a> (<span class="id" type="var">l1</span> ++ <span class="id" type="var">l2</span>) = (<a class="idref" href="Lists.html#NatList.rev"><span class="id" type="definition">rev</span></a> <span class="id" type="var">l2</span>) ++ (<a class="idref" href="Lists.html#NatList.rev"><span class="id" type="definition">rev</span></a> <span class="id" type="var">l1</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
There is a short solution to the next exercise.  If you find
    yourself getting tangled up, step back and try to look for a
    simpler way. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.app_ass4"><span class="id" type="lemma">app_ass4</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">l1</span> <span class="id" type="var">l2</span> <span class="id" type="var">l3</span> <span class="id" type="var">l4</span> : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>,<br/>
&nbsp;&nbsp;<span class="id" type="var">l1</span> ++ (<span class="id" type="var">l2</span> ++ (<span class="id" type="var">l3</span> ++ <span class="id" type="var">l4</span>)) = ((<span class="id" type="var">l1</span> ++ <span class="id" type="var">l2</span>) ++ <span class="id" type="var">l3</span>) ++ <span class="id" type="var">l4</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.snoc_append"><span class="id" type="lemma">snoc_append</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">l</span>:<a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>) (<span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Lists.html#NatList.snoc"><span class="id" type="definition">snoc</span></a> <span class="id" type="var">l</span> <span class="id" type="var">n</span> = <span class="id" type="var">l</span> ++ [<span class="id" type="var">n</span>].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
An exercise about your implementation of <span class="inlinecode"><span class="id" type="var">nonzeros</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="NatList.nonzeros_length"><span class="id" type="lemma">nonzeros_length</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">l1</span> <span class="id" type="var">l2</span> : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Lists.html#NatList.nonzeros"><span class="id" type="definition">nonzeros</span></a> (<span class="id" type="var">l1</span> ++ <span class="id" type="var">l2</span>) = (<a class="idref" href="Lists.html#NatList.nonzeros"><span class="id" type="definition">nonzeros</span></a> <span class="id" type="var">l1</span>) ++ (<a class="idref" href="Lists.html#NatList.nonzeros"><span class="id" type="definition">nonzeros</span></a> <span class="id" type="var">l2</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab63"></a><h2 class="section">List Exercises, Part 2</h2>

<div class="paragraph"> </div>

<a name="lab64"></a><h4 class="section">Exercise: 2 stars, recommended (list_design)</h4>
 Design exercise: 

<div class="paragraph"> </div>

<ul class="doclist">
<li> Write down a non-trivial theorem involving <span class="inlinecode"><span class="id" type="var">cons</span></span>
       (<span class="inlinecode">::</span>), <span class="inlinecode"><span class="id" type="var">snoc</span></span>, and <span class="inlinecode"><span class="id" type="var">append</span></span> (<span class="inlinecode">++</span>).  

</li>
<li> Prove it.

</li>
</ul>

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab65"></a><h4 class="section">Exercise: 2 stars, optional (bag_proofs)</h4>
 If you did the optional exercise about bags above, here are a
    couple of little theorems to prove about your definitions. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.count_member_nonzero"><span class="id" type="lemma">count_member_nonzero</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">s</span> : <a class="idref" href="Lists.html#NatList.bag"><span class="id" type="definition">bag</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> 1 (<a class="idref" href="Lists.html#NatList.count"><span class="id" type="definition">count</span></a> 1 (1 :: <span class="id" type="var">s</span>)) = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
The following lemma about <span class="inlinecode"><span class="id" type="var">ble_nat</span></span> might help you in the next proof. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.ble_n_Sn"><span class="id" type="lemma">ble_n_Sn</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> <span class="id" type="var">n</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>) = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "0".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "S n'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHn'</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.remove_decreases_count"><span class="id" type="lemma">remove_decreases_count</span></a>: <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">s</span> : <a class="idref" href="Lists.html#NatList.bag"><span class="id" type="definition">bag</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> (<a class="idref" href="Lists.html#NatList.count"><span class="id" type="definition">count</span></a> 0 (<a class="idref" href="Lists.html#NatList.remove_one"><span class="id" type="definition">remove_one</span></a> 0 <span class="id" type="var">s</span>)) (<a class="idref" href="Lists.html#NatList.count"><span class="id" type="definition">count</span></a> 0 <span class="id" type="var">s</span>) = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab66"></a><h4 class="section">Exercise: 3 stars, optional (bag_count_sum)</h4>
 Write down an interesting theorem about bags involving the
    functions <span class="inlinecode"><span class="id" type="var">count</span></span> and <span class="inlinecode"><span class="id" type="var">sum</span></span>, and prove it.

<div class="paragraph"> </div>

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
 
<div class="paragraph"> </div>

<a name="lab67"></a><h4 class="section">Exercise: 4 stars, optional (rev_injective)</h4>
 Prove that the <span class="inlinecode"><span class="id" type="var">rev</span></span> function is injective, that is,

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">X</span>&nbsp;(<span class="id" type="var">l1</span>&nbsp;<span class="id" type="var">l2</span>&nbsp;:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">X</span>),&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l1</span>&nbsp;=&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l2</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">l1</span>&nbsp;=&nbsp;<span class="id" type="var">l2</span>.
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

There is a hard way and an easy way to solve this exercise.

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab68"></a><h1 class="section">Options</h1>

<div class="paragraph"> </div>

 Here is another type definition that is often useful in
    day-to-day programming: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="NatList.natoption"><span class="id" type="inductive">natoption</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="NatList.Some"><span class="id" type="constructor">Some</span></a> : <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Lists.html#natoption"><span class="id" type="inductive">natoption</span></a><br/>
&nbsp;&nbsp;| <a name="NatList.None"><span class="id" type="constructor">None</span></a> : <a class="idref" href="Lists.html#natoption"><span class="id" type="inductive">natoption</span></a>.<br/>

<br/>
</div>

<div class="doc">
One use of <span class="inlinecode"><span class="id" type="var">natoption</span></span> is as a way of returning "error
    codes" from functions.  For example, suppose we want to write a
    function that returns the <span class="inlinecode"><span class="id" type="var">n</span></span>th element of some list.  If we give
    it type <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">natlist</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span>, then we'll have to return some
    number when the list is too short! 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="NatList.index_bad"><span class="id" type="definition">index_bad</span></a> (<span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>) (<span class="id" type="var">l</span>:<a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>) : <span class="id" type="inductive">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a> =&gt; 42  <span class="comment">(*&nbsp;arbitrary!&nbsp;*)</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">a</span> :: <span class="id" type="var">l'</span> =&gt; <span class="id" type="keyword">match</span> <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="constructor">O</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> =&gt; <span class="id" type="var">a</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a> =&gt; <a class="idref" href="Lists.html#index_bad"><span class="id" type="definition">index_bad</span></a> (<span class="id" type="definition">pred</span> <span class="id" type="var">n</span>) <span class="id" type="var">l'</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
On the other hand, if we give it type <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">natlist</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span>
    <span class="inlinecode"><span class="id" type="var">natoption</span></span>, then we can return <span class="inlinecode"><span class="id" type="var">None</span></span> when the list is too short
    and <span class="inlinecode"><span class="id" type="var">Some</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span> when the list has enough members and <span class="inlinecode"><span class="id" type="var">a</span></span> appears at
    position <span class="inlinecode"><span class="id" type="var">n</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="NatList.index"><span class="id" type="definition">index</span></a> (<span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>) (<span class="id" type="var">l</span>:<a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>) : <a class="idref" href="Lists.html#NatList.natoption"><span class="id" type="inductive">natoption</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a> =&gt; <a class="idref" href="Lists.html#NatList.None"><span class="id" type="constructor">None</span></a> <br/>
&nbsp;&nbsp;| <span class="id" type="var">a</span> :: <span class="id" type="var">l'</span> =&gt; <span class="id" type="keyword">match</span> <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="constructor">O</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> =&gt; <a class="idref" href="Lists.html#NatList.Some"><span class="id" type="constructor">Some</span></a> <span class="id" type="var">a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a> =&gt; <a class="idref" href="Lists.html#index"><span class="id" type="definition">index</span></a> (<span class="id" type="definition">pred</span> <span class="id" type="var">n</span>) <span class="id" type="var">l'</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_index1"><span class="id" type="definition">test_index1</span></a> :    <a class="idref" href="Lists.html#NatList.index"><span class="id" type="definition">index</span></a> 0 [4,5,6,7]  = <a class="idref" href="Lists.html#NatList.Some"><span class="id" type="constructor">Some</span></a> 4.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_index2"><span class="id" type="definition">test_index2</span></a> :    <a class="idref" href="Lists.html#NatList.index"><span class="id" type="definition">index</span></a> 3 [4,5,6,7]  = <a class="idref" href="Lists.html#NatList.Some"><span class="id" type="constructor">Some</span></a> 7.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_index3"><span class="id" type="definition">test_index3</span></a> :    <a class="idref" href="Lists.html#NatList.index"><span class="id" type="definition">index</span></a> 10 [4,5,6,7] = <a class="idref" href="Lists.html#NatList.None"><span class="id" type="constructor">None</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
This example is also an opportunity to introduce one more
    small feature of Coq's programming language: conditional
    expressions... 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="NatList.index'"><span class="id" type="definition">index'</span></a> (<span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>) (<span class="id" type="var">l</span>:<a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>) : <a class="idref" href="Lists.html#NatList.natoption"><span class="id" type="inductive">natoption</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a> =&gt; <a class="idref" href="Lists.html#NatList.None"><span class="id" type="constructor">None</span></a> <br/>
&nbsp;&nbsp;| <span class="id" type="var">a</span> :: <span class="id" type="var">l'</span> =&gt; <span class="id" type="keyword">if</span> <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="constructor">O</span> <span class="id" type="keyword">then</span> <a class="idref" href="Lists.html#NatList.Some"><span class="id" type="constructor">Some</span></a> <span class="id" type="var">a</span> <span class="id" type="keyword">else</span> <a class="idref" href="Lists.html#NatList.index"><span class="id" type="definition">index</span></a> (<span class="id" type="definition">pred</span> <span class="id" type="var">n</span>) <span class="id" type="var">l'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Coq's conditionals are exactly like those found in any other
    language, with one small generalization.  Since the boolean type
    is not built in, Coq actually allows conditional expressions over
    <i>any</i> inductively defined type with exactly two constructors.  The
    guard is considered true if it evaluates to the first constructor
    in the <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> definition and false if it evaluates to the
    second. 
<div class="paragraph"> </div>

 The function below pulls the <span class="inlinecode"><span class="id" type="var">nat</span></span> out of a <span class="inlinecode"><span class="id" type="var">natoption</span></span>, returning
    a supplied default in the <span class="inlinecode"><span class="id" type="var">None</span></span> case. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="NatList.option_elim"><span class="id" type="definition">option_elim</span></a> (<span class="id" type="var">o</span> : <a class="idref" href="Lists.html#NatList.natoption"><span class="id" type="inductive">natoption</span></a>) (<span class="id" type="var">d</span> : <span class="id" type="inductive">nat</span>) : <span class="id" type="inductive">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">o</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Lists.html#NatList.Some"><span class="id" type="constructor">Some</span></a> <span class="id" type="var">n'</span> =&gt; <span class="id" type="var">n'</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Lists.html#NatList.None"><span class="id" type="constructor">None</span></a> =&gt; <span class="id" type="var">d</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab69"></a><h4 class="section">Exercise: 2 stars (hd_opt)</h4>
 Using the same idea, fix the <span class="inlinecode"><span class="id" type="var">hd</span></span> function from earlier so we don't
   have to pass a default element for the <span class="inlinecode"><span class="id" type="var">nil</span></span> case.  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="NatList.hd_opt"><span class="id" type="definition">hd_opt</span></a> (<span class="id" type="var">l</span> : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>) : <a class="idref" href="Lists.html#NatList.natoption"><span class="id" type="inductive">natoption</span></a> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_hd_opt1"><span class="id" type="definition">test_hd_opt1</span></a> : <a class="idref" href="Lists.html#NatList.hd_opt"><span class="id" type="definition">hd_opt</span></a> [] = <a class="idref" href="Lists.html#NatList.None"><span class="id" type="constructor">None</span></a>.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_hd_opt2"><span class="id" type="definition">test_hd_opt2</span></a> : <a class="idref" href="Lists.html#NatList.hd_opt"><span class="id" type="definition">hd_opt</span></a> [1] = <a class="idref" href="Lists.html#NatList.Some"><span class="id" type="constructor">Some</span></a> 1.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_hd_opt3"><span class="id" type="definition">test_hd_opt3</span></a> : <a class="idref" href="Lists.html#NatList.hd_opt"><span class="id" type="definition">hd_opt</span></a> [5,6] = <a class="idref" href="Lists.html#NatList.Some"><span class="id" type="constructor">Some</span></a> 5.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab70"></a><h4 class="section">Exercise: 2 stars, optional (option_elim_hd)</h4>
 This exercise relates your new <span class="inlinecode"><span class="id" type="var">hd_opt</span></span> to the old <span class="inlinecode"><span class="id" type="var">hd</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.option_elim_hd"><span class="id" type="lemma">option_elim_hd</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">l</span>:<a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>) (<span class="id" type="var">default</span>:<span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Lists.html#NatList.hd"><span class="id" type="definition">hd</span></a> <span class="id" type="var">default</span> <span class="id" type="var">l</span> = <a class="idref" href="Lists.html#NatList.option_elim"><span class="id" type="definition">option_elim</span></a> (<a class="idref" href="Lists.html#NatList.hd_opt"><span class="id" type="definition">hd_opt</span></a> <span class="id" type="var">l</span>) <span class="id" type="var">default</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab71"></a><h4 class="section">Exercise: 2 stars, recommended (beq_natlist)</h4>
 Fill in the definition of <span class="inlinecode"><span class="id" type="var">beq_natlist</span></span>, which compares
    lists of numbers for equality.  Prove that <span class="inlinecode"><span class="id" type="var">beq_natlist</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span>
    yields <span class="inlinecode"><span class="id" type="var">true</span></span> for every list <span class="inlinecode"><span class="id" type="var">l</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="NatList.beq_natlist"><span class="id" type="definition">beq_natlist</span></a> (<span class="id" type="var">l1</span> <span class="id" type="var">l2</span> : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_beq_natlist1"><span class="id" type="definition">test_beq_natlist1</span></a> :   (<a class="idref" href="Lists.html#NatList.beq_natlist"><span class="id" type="definition">beq_natlist</span></a> <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a> <a class="idref" href="Lists.html#NatList.nil"><span class="id" type="constructor">nil</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>).<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_beq_natlist2"><span class="id" type="definition">test_beq_natlist2</span></a> :   <a class="idref" href="Lists.html#NatList.beq_natlist"><span class="id" type="definition">beq_natlist</span></a> [1,2,3] [1,2,3] = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="NatList.test_beq_natlist3"><span class="id" type="definition">test_beq_natlist3</span></a> :   <a class="idref" href="Lists.html#NatList.beq_natlist"><span class="id" type="definition">beq_natlist</span></a> [1,2,3] [1,2,4] = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.beq_natlist_refl"><span class="id" type="lemma">beq_natlist_refl</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">l</span>:<a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> = <a class="idref" href="Lists.html#NatList.beq_natlist"><span class="id" type="definition">beq_natlist</span></a> <span class="id" type="var">l</span> <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab72"></a><h1 class="section">The <span class="inlinecode"><span class="id" type="tactic">apply</span></span> Tactic</h1>

<div class="paragraph"> </div>

 We often encounter situations where the goal to be proved is
    exactly the same as some hypothesis in the context or some
    previously proved lemma. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.silly1"><span class="id" type="lemma">silly1</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> <span class="id" type="var">p</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span>  <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">n</span>,<span class="id" type="var">o</span>] = [<span class="id" type="var">n</span>,<span class="id" type="var">p</span>] <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">n</span>,<span class="id" type="var">o</span>] = [<span class="id" type="var">m</span>,<span class="id" type="var">p</span>].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> <span class="id" type="var">p</span> <span class="id" type="var">eq1</span> <span class="id" type="var">eq2</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&larr;</span> <span class="id" type="var">eq1</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;At&nbsp;this&nbsp;point,&nbsp;we&nbsp;could&nbsp;finish&nbsp;with&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"<span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">eq2</span>.</span> <span class="inlinecode"><span class="id" type="tactic">reflexivity</span>.</span>"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;we&nbsp;have&nbsp;done&nbsp;several&nbsp;times&nbsp;above.&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;But&nbsp;we&nbsp;can&nbsp;achieve&nbsp;the&nbsp;same&nbsp;effect&nbsp;in&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;single&nbsp;step&nbsp;by&nbsp;using&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="tactic">apply</span></span>&nbsp;tactic&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instead:&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">eq2</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="tactic">apply</span></span> tactic also works with <i>conditional</i> hypotheses
    and lemmas: if the statement being applied is an implication, then
    the premises of this implication will be added to the list of
    subgoals needing to be proved. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.silly2"><span class="id" type="lemma">silly2</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> <span class="id" type="var">p</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span>  <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span> (<span class="id" type="var">q</span> <span class="id" type="var">r</span> : <span class="id" type="inductive">nat</span>), <span class="id" type="var">q</span> = <span class="id" type="var">r</span> <span style="font-family: arial;">&rarr;</span> [<span class="id" type="var">q</span>,<span class="id" type="var">o</span>] = [<span class="id" type="var">r</span>,<span class="id" type="var">p</span>]) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">n</span>,<span class="id" type="var">o</span>] = [<span class="id" type="var">m</span>,<span class="id" type="var">p</span>].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> <span class="id" type="var">p</span> <span class="id" type="var">eq1</span> <span class="id" type="var">eq2</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">eq2</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">eq1</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
You may find it instructive to experiment with this proof
    and see if there is a way to complete it using just <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>
    instead of <span class="inlinecode"><span class="id" type="tactic">apply</span></span>. 
<div class="paragraph"> </div>

 Typically, when we use <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span>, the statement <span class="inlinecode"><span class="id" type="var">H</span></span> will
    begin with a <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> binding some <i>universal variables</i>.  When
    Coq matches the current goal against the conclusion of <span class="inlinecode"><span class="id" type="var">H</span></span>, it
    will try to find appropriate values for these variables.  For
    example, when we do <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">eq2</span></span> in the following proof, the
    universal variable <span class="inlinecode"><span class="id" type="var">q</span></span> in <span class="inlinecode"><span class="id" type="var">eq2</span></span> gets instantiated with <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">r</span></span>
    gets instantiated with <span class="inlinecode"><span class="id" type="var">m</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.silly2a"><span class="id" type="lemma">silly2a</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">n</span>,<span class="id" type="var">n</span>) = (<span class="id" type="var">m</span>,<span class="id" type="var">m</span>)  <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span> (<span class="id" type="var">q</span> <span class="id" type="var">r</span> : <span class="id" type="inductive">nat</span>), (<span class="id" type="var">q</span>,<span class="id" type="var">q</span>) = (<span class="id" type="var">r</span>,<span class="id" type="var">r</span>) <span style="font-family: arial;">&rarr;</span> [<span class="id" type="var">q</span>] = [<span class="id" type="var">r</span>]) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">n</span>] = [<span class="id" type="var">m</span>].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">eq1</span> <span class="id" type="var">eq2</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">eq2</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">eq1</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab73"></a><h4 class="section">Exercise: 2 stars, optional (silly_ex)</h4>
 Complete the following proof without using <span class="inlinecode"><span class="id" type="tactic">simpl</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.silly_ex"><span class="id" type="lemma">silly_ex</span></a> : <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="Basics.html#evenb"><span class="id" type="definition">evenb</span></a> <span class="id" type="var">n</span> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Basics.html#oddb"><span class="id" type="definition">oddb</span></a> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>) = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basics.html#evenb"><span class="id" type="definition">evenb</span></a> 3 = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basics.html#oddb"><span class="id" type="definition">oddb</span></a> 4 = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 To use the <span class="inlinecode"><span class="id" type="tactic">apply</span></span> tactic, the (conclusion of the) fact
    being applied must match the goal <i>exactly</i> &mdash; for example, <span class="inlinecode"><span class="id" type="tactic">apply</span></span>
    will not work if the left and right sides of the equality are
    swapped. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.silly3_firsttry"><span class="id" type="lemma">silly3_firsttry</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">n</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> = <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> 5  <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> (<span class="id" type="constructor">S</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>)) 7 = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;here&nbsp;we&nbsp;cannot&nbsp;use&nbsp;<span class="inlinecode"><span class="id" type="tactic">apply</span></span>&nbsp;directly&nbsp;*)</span><br/>
<span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
In this case we can use the <span class="inlinecode"><span class="id" type="tactic">symmetry</span></span> tactic, which
    switches the left and right sides of an equality in the goal. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.silly3"><span class="id" type="lemma">silly3</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">n</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> = <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> 5  <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> (<span class="id" type="constructor">S</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>)) 7 = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">symmetry</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="comment">(*&nbsp;Actually,&nbsp;this&nbsp;<span class="inlinecode"><span class="id" type="tactic">simpl</span></span>&nbsp;is&nbsp;unnecessary,&nbsp;since&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="tactic">apply</span></span>&nbsp;will&nbsp;do&nbsp;a&nbsp;<span class="inlinecode"><span class="id" type="tactic">simpl</span></span>&nbsp;step&nbsp;first.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab74"></a><h4 class="section">Exercise: 3 stars, recommended (apply_exercise1)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="NatList.rev_exercise1"><span class="id" type="lemma">rev_exercise1</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">l</span> <span class="id" type="var">l'</span> : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">l</span> = <a class="idref" href="Lists.html#NatList.rev"><span class="id" type="definition">rev</span></a> <span class="id" type="var">l'</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">l'</span> = <a class="idref" href="Lists.html#NatList.rev"><span class="id" type="definition">rev</span></a> <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Hint:&nbsp;you&nbsp;can&nbsp;use&nbsp;<span class="inlinecode"><span class="id" type="tactic">apply</span></span>&nbsp;with&nbsp;previously&nbsp;defined&nbsp;lemmas,&nbsp;not<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;just&nbsp;hypotheses&nbsp;in&nbsp;the&nbsp;context.&nbsp;&nbsp;Remember&nbsp;that&nbsp;<span class="inlinecode"><span class="id" type="var">SearchAbout</span></span>&nbsp;is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;your&nbsp;friend.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab75"></a><h4 class="section">Exercise: 1 star (apply_rewrite)</h4>
 Briefly explain the difference between the tactics <span class="inlinecode"><span class="id" type="tactic">apply</span></span> and
    <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>.  Are there situations where both can usefully be
    applied?

<div class="paragraph"> </div>

  <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
 <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab76"></a><h1 class="section">Varying the Induction Hypothesis</h1>

<div class="paragraph"> </div>

 One subtlety in these inductive proofs is worth noticing here.
    For example, look back at the proof of the <span class="inlinecode"><span class="id" type="var">app_ass</span></span> theorem.  The
    induction hypothesis (in the second subgoal generated by the
    <span class="inlinecode"><span class="id" type="tactic">induction</span></span> tactic) is

<div class="paragraph"> </div>

      <span class="inlinecode"></span> <span class="inlinecode">(<span class="id" type="var">l1'</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">l2</span>)</span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">l3</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">l1'</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">l2</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">l3</span></span> <span class="inlinecode"></span>.

<div class="paragraph"> </div>

    (Note that, because we've defined <span class="inlinecode">++</span> to be right associative,
    the expression on the right of the <span class="inlinecode">=</span> is the same as writing <span class="inlinecode"><span class="id" type="var">l1'</span></span>
    <span class="inlinecode">++</span> <span class="inlinecode">(<span class="id" type="var">l2</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">l3</span>)</span>.)

<div class="paragraph"> </div>

    This hypothesis makes a statement about <span class="inlinecode"><span class="id" type="var">l1'</span></span> together with the
    <i>particular</i> lists <span class="inlinecode"><span class="id" type="var">l2</span></span> and <span class="inlinecode"><span class="id" type="var">l3</span></span>.  The lists <span class="inlinecode"><span class="id" type="var">l2</span></span> and <span class="inlinecode"><span class="id" type="var">l3</span></span>, which
    were introduced into the context by the <span class="inlinecode"><span class="id" type="tactic">intros</span></span> at the top of the
    proof, are "held constant" in the induction hypothesis.  If we set
    up the proof slightly differently by introducing just <span class="inlinecode"><span class="id" type="var">n</span></span> into the
    context at the top, then we get an induction hypothesis that makes
    a stronger claim:

<div class="paragraph"> </div>

     <span class="inlinecode"></span> <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">l2</span></span> <span class="inlinecode"><span class="id" type="var">l3</span>,</span>  <span class="inlinecode">(<span class="id" type="var">l1'</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">l2</span>)</span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">l3</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">l1'</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">l2</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">l3</span></span> <span class="inlinecode"></span>

<div class="paragraph"> </div>

    Use Coq to see the difference for yourself.

<div class="paragraph"> </div>

    In the present case, the difference between the two proofs is
    minor, since the definition of the <span class="inlinecode">++</span> function just examines its
    first argument and doesn't do anything interesting with its second
    argument.  But we'll soon come to situations where setting up the
    induction hypothesis one way or the other can make the difference
    between a proof working and failing. 
<div class="paragraph"> </div>

<a name="lab77"></a><h4 class="section">Exercise: 2 stars, optional (app_ass')</h4>
 Give an alternate proof of the associativity of <span class="inlinecode">++</span> with a more
    general induction hypothesis.  Complete the following (leaving the
    first line unchanged). 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.app_ass'"><span class="id" type="lemma">app_ass'</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">l1</span> <span class="id" type="var">l2</span> <span class="id" type="var">l3</span> : <a class="idref" href="Lists.html#NatList.natlist"><span class="id" type="inductive">natlist</span></a>, <br/>
&nbsp;&nbsp;(<span class="id" type="var">l1</span> ++ <span class="id" type="var">l2</span>) ++ <span class="id" type="var">l3</span> = <span class="id" type="var">l1</span> ++ (<span class="id" type="var">l2</span> ++ <span class="id" type="var">l3</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">l1</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l1</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">n</span> <span class="id" type="var">l1'</span>].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab78"></a><h4 class="section">Exercise: 3 stars (apply_exercise2)</h4>
 Notice that we don't introduce <span class="inlinecode"><span class="id" type="var">m</span></span> before performing induction.
    This leaves it general, so that the IH doesn't specify a
    particular <span class="inlinecode"><span class="id" type="var">m</span></span>, but lets us pick. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="NatList.beq_nat_sym"><span class="id" type="lemma">beq_nat_sym</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">m</span> = <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">m</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab79"></a><h4 class="section">Exercise: 3 stars, recommended (beq_nat_sym_informal)</h4>
 Provide an informal proof of this lemma that corresponds
    to your formal proof above:

<div class="paragraph"> </div>

   Theorem: For any <span class="inlinecode"><span class="id" type="var">nat</span></span>s <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span>, <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>.

<div class="paragraph"> </div>

   Proof:
   <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Lists.html#"><span class="id" type="module">NatList</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab80"></a><h1 class="section">Exercise: Dictionaries</h1>

</div>
<div class="code code-space">

<br/>
<span class="id" type="keyword">Module</span> <a name="Dictionary"><span class="id" type="module">Dictionary</span></a>.<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <a name="Dictionary.dictionary"><span class="id" type="inductive">dictionary</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="Dictionary.empty"><span class="id" type="constructor">empty</span></a>  : <a class="idref" href="Lists.html#dictionary"><span class="id" type="inductive">dictionary</span></a> <br/>
&nbsp;&nbsp;| <a name="Dictionary.record"><span class="id" type="constructor">record</span></a> : <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Lists.html#dictionary"><span class="id" type="inductive">dictionary</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Lists.html#dictionary"><span class="id" type="inductive">dictionary</span></a>.<br/>

<br/>
</div>

<div class="doc">
This declaration can be read: "There are two ways to construct a
    <span class="inlinecode"><span class="id" type="var">dictionary</span></span>: either using the constructor <span class="inlinecode"><span class="id" type="var">empty</span></span> to represent an
    empty dictionary, or by applying the constructor <span class="inlinecode"><span class="id" type="var">record</span></span> to
    a key, a value, and an existing <span class="inlinecode"><span class="id" type="var">dictionary</span></span> to construct a
    <span class="inlinecode"><span class="id" type="var">dictionary</span></span> with an additional key to value mapping." 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="Dictionary.insert"><span class="id" type="definition">insert</span></a> (<span class="id" type="var">key</span> <span class="id" type="var">value</span> : <span class="id" type="inductive">nat</span>) (<span class="id" type="var">d</span> : <a class="idref" href="Lists.html#Dictionary.dictionary"><span class="id" type="inductive">dictionary</span></a>) : <a class="idref" href="Lists.html#Dictionary.dictionary"><span class="id" type="inductive">dictionary</span></a> :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Lists.html#Dictionary.record"><span class="id" type="constructor">record</span></a> <span class="id" type="var">key</span> <span class="id" type="var">value</span> <span class="id" type="var">d</span>).<br/>

<br/>
</div>

<div class="doc">
Below is a function <span class="inlinecode"><span class="id" type="var">find</span></span> that searches a <span class="inlinecode"><span class="id" type="var">dictionary</span></span> for a
    given key.  It evaluates evaluates to <span class="inlinecode"><span class="id" type="var">None</span></span> if the key was not
    found and <span class="inlinecode"><span class="id" type="var">Some</span></span> <span class="inlinecode"><span class="id" type="var">val</span></span> if the key was mapped to <span class="inlinecode"><span class="id" type="var">val</span></span> in the
    dictionary. If the same key is mapped to multiple values, <span class="inlinecode"><span class="id" type="var">find</span></span>
    will return the first one it finds. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="Dictionary.find"><span class="id" type="definition">find</span></a> (<span class="id" type="var">key</span> : <span class="id" type="inductive">nat</span>) (<span class="id" type="var">d</span> : <a class="idref" href="Lists.html#Dictionary.dictionary"><span class="id" type="inductive">dictionary</span></a>) : <span class="id" type="inductive">option</span> <span class="id" type="inductive">nat</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">d</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| <a class="idref" href="Lists.html#Dictionary.empty"><span class="id" type="constructor">empty</span></a>         =&gt; <span class="id" type="constructor">None</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Lists.html#Dictionary.record"><span class="id" type="constructor">record</span></a> <span class="id" type="var">k</span> <span class="id" type="var">v</span> <span class="id" type="var">d'</span> =&gt; <span class="id" type="keyword">if</span> (<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">key</span> <span class="id" type="var">k</span>) <span class="id" type="keyword">then</span> (<span class="id" type="constructor">Some</span> <span class="id" type="var">v</span>) <span class="id" type="keyword">else</span> (<a class="idref" href="Lists.html#find"><span class="id" type="definition">find</span></a> <span class="id" type="var">key</span> <span class="id" type="var">d'</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab81"></a><h4 class="section">Exercise: 1 star (dictionary_invariant1)</h4>

</div>
<div class="code code-space">
<span class="comment">(*&nbsp;Complete&nbsp;the&nbsp;following&nbsp;proof.&nbsp;*)</span><br/>
<span class="id" type="keyword">Theorem</span> <a name="Dictionary.dictionary_invariant1"><span class="id" type="lemma">dictionary_invariant1</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">d</span> : <a class="idref" href="Lists.html#Dictionary.dictionary"><span class="id" type="inductive">dictionary</span></a>) (<span class="id" type="var">k</span> <span class="id" type="var">v</span>: <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;(<a class="idref" href="Lists.html#Dictionary.find"><span class="id" type="definition">find</span></a> <span class="id" type="var">k</span> (<a class="idref" href="Lists.html#Dictionary.insert"><span class="id" type="definition">insert</span></a> <span class="id" type="var">k</span> <span class="id" type="var">v</span> <span class="id" type="var">d</span>)) = <span class="id" type="constructor">Some</span> <span class="id" type="var">v</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab82"></a><h4 class="section">Exercise: 1 star (dictionary_invariant2)</h4>

</div>
<div class="code code-space">
<span class="comment">(*&nbsp;Complete&nbsp;the&nbsp;following&nbsp;proof.&nbsp;*)</span><br/>
<span class="id" type="keyword">Theorem</span> <a name="Dictionary.dictionary_invariant2"><span class="id" type="lemma">dictionary_invariant2</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">d</span> : <a class="idref" href="Lists.html#Dictionary.dictionary"><span class="id" type="inductive">dictionary</span></a>) (<span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>: <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;(<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">m</span> <span class="id" type="var">n</span>) = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a> <span style="font-family: arial;">&rarr;</span> (<a class="idref" href="Lists.html#Dictionary.find"><span class="id" type="definition">find</span></a> <span class="id" type="var">m</span> <span class="id" type="var">d</span>) = (<a class="idref" href="Lists.html#Dictionary.find"><span class="id" type="definition">find</span></a> <span class="id" type="var">m</span> (<a class="idref" href="Lists.html#Dictionary.insert"><span class="id" type="definition">insert</span></a> <span class="id" type="var">n</span> <span class="id" type="var">o</span> <span class="id" type="var">d</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Lists.html#"><span class="id" type="module">Dictionary</span></a>.<br/>

<br/>
</div>

<div class="doc">
The following declaration puts <span class="inlinecode"><span class="id" type="var">beq_nat_sym</span></span> into the
    top-level namespace, so that we can use it later without having to
    write <span class="inlinecode"><span class="id" type="var">NatList.beq_nat_sym</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="beq_nat_sym"><span class="id" type="definition">beq_nat_sym</span></a> := <a class="idref" href="Lists.html#NatList.beq_nat_sym"><span class="id" type="axiom">NatList.beq_nat_sym</span></a>.<br/>

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://www.lix.polytechnique.fr/coq/">coqdoc</a>
</div>

</div>

</body>
</html>