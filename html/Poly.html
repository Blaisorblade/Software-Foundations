<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Poly: Polymorphism and Higher-Order Functions</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Poly<span class="subtitle">Polymorphism and Higher-Order Functions</span></h1>

<div class="code code-tight">
</div>

<div class="doc">

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;$Date:&nbsp;2011-06-22&nbsp;10:06:32&nbsp;-0400&nbsp;(Wed,&nbsp;22&nbsp;Jun&nbsp;2011)&nbsp;$&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="Lists.html#"><span class="id" type="library">Lists</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab83"></a><h1 class="section">Polymorphism</h1>

<div class="paragraph"> </div>

<a name="lab84"></a><h2 class="section">Polymorphic Lists</h2>

<div class="paragraph"> </div>

 Up to this point, we've been working with lists of numbers.
    Of course, interesting programs also need to be able to manipulate
    lists whose elements are drawn from other types &mdash; lists of
    strings, lists of booleans, lists of lists, etc.  We <i>could</i> just
    define a new inductive datatype for each of these, for
    example... 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="boollist"><span class="id" type="inductive">boollist</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="bool_nil"><span class="id" type="constructor">bool_nil</span></a> : <a class="idref" href="Poly.html#boollist"><span class="id" type="inductive">boollist</span></a><br/>
&nbsp;&nbsp;| <a name="bool_cons"><span class="id" type="constructor">bool_cons</span></a> : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Poly.html#boollist"><span class="id" type="inductive">boollist</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Poly.html#boollist"><span class="id" type="inductive">boollist</span></a>.<br/>

<br/>
</div>

<div class="doc">
... but this would quickly become tedious, partly because we
    have to make up different constructor names for each datatype, but
    mostly because we would also need to define new versions of all
    our list manipulating functions (<span class="inlinecode"><span class="id" type="var">length</span></span>, <span class="inlinecode"><span class="id" type="var">rev</span></span>, etc.)  for each
    new datatype definition. 
<div class="paragraph"> </div>

 To avoid all this repetition, Coq supports <i>polymorphic</i>
    inductive type definitions.  For example, here is a polymorphic
    list datatype. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="list"><span class="id" type="inductive">list</span></a> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="nil"><span class="id" type="constructor">nil</span></a> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span><br/>
&nbsp;&nbsp;| <a name="cons"><span class="id" type="constructor">cons</span></a> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>.<br/>

<br/>
</div>

<div class="doc">
This is exactly like the definition of <span class="inlinecode"><span class="id" type="var">natlist</span></span> from the
    previous chapter, except that the <span class="inlinecode"><span class="id" type="var">nat</span></span> argument to the <span class="inlinecode"><span class="id" type="var">cons</span></span>
    constructor has been replaced by an arbitrary type <span class="inlinecode"><span class="id" type="var">X</span></span>, a binding
    for <span class="inlinecode"><span class="id" type="var">X</span></span> has been added to the header, and the occurrences of
    <span class="inlinecode"><span class="id" type="var">natlist</span></span> in the types of the constructors have been replaced by
    <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span>.  (We can re-use the constructor names <span class="inlinecode"><span class="id" type="var">nil</span></span> and <span class="inlinecode"><span class="id" type="var">cons</span></span>
    because the earlier definition of <span class="inlinecode"><span class="id" type="var">natlist</span></span> was inside of a
    <span class="inlinecode"><span class="id" type="keyword">Module</span></span> definition that is now out of scope.) 
<div class="paragraph"> </div>

 So what, exactly, is <span class="inlinecode"><span class="id" type="var">list</span></span>?  One good way to think about it
    is that <span class="inlinecode"><span class="id" type="var">list</span></span> is a <i>function</i> from <span class="inlinecode"><span class="id" type="keyword">Type</span></span>s to <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span>
    definitions; or, to put it another way, <span class="inlinecode"><span class="id" type="var">list</span></span> is a function from
    <span class="inlinecode"><span class="id" type="keyword">Type</span></span>s to <span class="inlinecode"><span class="id" type="keyword">Type</span></span>s.  For any particular type <span class="inlinecode"><span class="id" type="var">X</span></span>, the type <span class="inlinecode"><span class="id" type="var">list</span></span>
    <span class="inlinecode"><span class="id" type="var">X</span></span> is an <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span>ly defined set of lists whose elements are
    things of type <span class="inlinecode"><span class="id" type="var">X</span></span>. 
<div class="paragraph"> </div>

 With this definition, when we use the constructors <span class="inlinecode"><span class="id" type="var">nil</span></span> and
    <span class="inlinecode"><span class="id" type="var">cons</span></span> to build lists, we need to specify what type of lists we
    are building &mdash; that is, <span class="inlinecode"><span class="id" type="var">nil</span></span> and <span class="inlinecode"><span class="id" type="var">cons</span></span> are now <i>polymorphic
    constructors</i>.  Observe the types of these constructors: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;nil&nbsp;:&nbsp;forall&nbsp;X&nbsp;:&nbsp;Type,&nbsp;list&nbsp;X&nbsp;*)</span><br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;cons&nbsp;:&nbsp;forall&nbsp;X&nbsp;:&nbsp;Type,&nbsp;X&nbsp;-&gt;&nbsp;list&nbsp;X&nbsp;-&gt;&nbsp;list&nbsp;X&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
The "<span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span>" in these types should be read as an
    additional argument to the constructors that determines the
    expected types of the arguments that follow.  When <span class="inlinecode"><span class="id" type="var">nil</span></span> and
    <span class="inlinecode"><span class="id" type="var">cons</span></span> are used, these arguments are supplied in the same way as
    the others.  For example, the list containing <span class="inlinecode">2</span> and <span class="inlinecode">1</span> is
    written like this: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> (<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="inductive">nat</span> 2 (<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="inductive">nat</span> 1 (<a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a> <span class="id" type="inductive">nat</span>))).<br/>

<br/>
</div>

<div class="doc">
(We are writing <span class="inlinecode"><span class="id" type="var">nil</span></span> and <span class="inlinecode"><span class="id" type="var">cons</span></span> explicitly here because we
    haven't yet defined the <span class="inlinecode"></span> <span class="inlinecode">[]</span> <span class="inlinecode"></span> and <span class="inlinecode">::</span> notations.  We'll do that
    in a bit.) 
<div class="paragraph"> </div>

 We can now go back and make polymorphic (or "generic")
    versions of all the list-processing functions that we wrote
    before.  Here is <span class="inlinecode"><span class="id" type="var">length</span></span>, for example: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="length"><span class="id" type="definition">length</span></a> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">l</span>:<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) : <span class="id" type="inductive">nat</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a>      =&gt; 0<br/>
&nbsp;&nbsp;| <a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">h</span> <span class="id" type="var">t</span> =&gt; <span class="id" type="constructor">S</span> (<a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> <span class="id" type="var">X</span> <span class="id" type="var">t</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Note that the uses of <span class="inlinecode"><span class="id" type="var">nil</span></span> and <span class="inlinecode"><span class="id" type="var">cons</span></span> in <span class="inlinecode"><span class="id" type="keyword">match</span></span> patterns
    do not require any type annotations: we already know that the list
    <span class="inlinecode"><span class="id" type="var">l</span></span> contains elements of type <span class="inlinecode"><span class="id" type="var">X</span></span>, so there's no reason to include
    <span class="inlinecode"><span class="id" type="var">X</span></span> in the pattern.  More formally, the type <span class="inlinecode"><span class="id" type="var">X</span></span> is a parameter
    of the whole definition of <span class="inlinecode"><span class="id" type="var">list</span></span>, not of the individual
    constructors.

<div class="paragraph"> </div>

    As with <span class="inlinecode"><span class="id" type="var">nil</span></span> and <span class="inlinecode"><span class="id" type="var">cons</span></span>, we can use <span class="inlinecode"><span class="id" type="var">length</span></span> by applying it first
    to a type and then to its list argument: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="test_length1"><span class="id" type="definition">test_length1</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> <span class="id" type="inductive">nat</span> (<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="inductive">nat</span> 1 (<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="inductive">nat</span> 2 (<a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a> <span class="id" type="inductive">nat</span>))) = 2.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
To use our length with other kinds of lists, we simply
    instantiate it with an appropriate type parameter: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="test_length2"><span class="id" type="definition">test_length2</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a> (<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a> <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> (<a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a> <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a>)) = 1.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Let's close this subsection by re-implementing a few other
    standard list functions on our new polymorphic lists: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="app"><span class="id" type="definition">app</span></a> (<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">l1</span> <span class="id" type="var">l2</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: (<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l1</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a>      =&gt; <span class="id" type="var">l2</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">h</span> <span class="id" type="var">t</span> =&gt; <a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">X</span> <span class="id" type="var">h</span> (<a class="idref" href="Poly.html#app"><span class="id" type="definition">app</span></a> <span class="id" type="var">X</span> <span class="id" type="var">t</span> <span class="id" type="var">l2</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="snoc"><span class="id" type="definition">snoc</span></a> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">l</span>:<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) (<span class="id" type="var">v</span>:<span class="id" type="var">X</span>) : (<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a>      =&gt; <a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">X</span> <span class="id" type="var">v</span> (<a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a> <span class="id" type="var">X</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">h</span> <span class="id" type="var">t</span> =&gt; <a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">X</span> <span class="id" type="var">h</span> (<a class="idref" href="Poly.html#snoc"><span class="id" type="definition">snoc</span></a> <span class="id" type="var">X</span> <span class="id" type="var">t</span> <span class="id" type="var">v</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="rev"><span class="id" type="definition">rev</span></a> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">l</span>:<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a>      =&gt; <a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a> <span class="id" type="var">X</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">h</span> <span class="id" type="var">t</span> =&gt; <a class="idref" href="Poly.html#snoc"><span class="id" type="definition">snoc</span></a> <span class="id" type="var">X</span> (<a class="idref" href="Poly.html#rev"><span class="id" type="definition">rev</span></a> <span class="id" type="var">X</span> <span class="id" type="var">t</span>) <span class="id" type="var">h</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="test_rev1"><span class="id" type="definition">test_rev1</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Poly.html#rev"><span class="id" type="definition">rev</span></a> <span class="id" type="inductive">nat</span> (<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="inductive">nat</span> 1 (<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="inductive">nat</span> 2 (<a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a> <span class="id" type="inductive">nat</span>))) <br/>
&nbsp;&nbsp;= (<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="inductive">nat</span> 2 (<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="inductive">nat</span> 1 (<a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a> <span class="id" type="inductive">nat</span>))).<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="test_rev2"><span class="id" type="definition">test_rev2</span></a>: <br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#rev"><span class="id" type="definition">rev</span></a> <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a> (<a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a> <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a>) = <a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a> <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab85"></a><h3 class="section">Type Inference</h3>

<div class="paragraph"> </div>

 Let's write the definition of <span class="inlinecode"><span class="id" type="var">app</span></span> again, but this time we won't
    specify the types of any of the arguments. Will Coq still accept
    it? 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="app'"><span class="id" type="definition">app'</span></a> <span class="id" type="var">X</span> <span class="id" type="var">l1</span> <span class="id" type="var">l2</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l1</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a>      =&gt; <span class="id" type="var">l2</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">h</span> <span class="id" type="var">t</span> =&gt; <a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">X</span> <span class="id" type="var">h</span> (<a class="idref" href="Poly.html#app'"><span class="id" type="definition">app'</span></a> <span class="id" type="var">X</span> <span class="id" type="var">t</span> <span class="id" type="var">l2</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Indeed it will.  Let's see what type Coq has assigned to <span class="inlinecode"><span class="id" type="var">app'</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Poly.html#app'"><span class="id" type="definition">app'</span></a>.<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Poly.html#app"><span class="id" type="definition">app</span></a>.<br/>

<br/>
</div>

<div class="doc">
It has exactly the same type type as <span class="inlinecode"><span class="id" type="var">app</span></span>.  Coq was able to
    use a procedure called <i>type inference</i> to deduce what the types
    of <span class="inlinecode"><span class="id" type="var">X</span></span>, <span class="inlinecode"><span class="id" type="var">l1</span></span>, and <span class="inlinecode"><span class="id" type="var">l2</span></span> must be, based on how they are used.  For
    example, since <span class="inlinecode"><span class="id" type="var">X</span></span> is used as an argument to <span class="inlinecode"><span class="id" type="var">cons</span></span>, it must be a
    <span class="inlinecode"><span class="id" type="keyword">Type</span></span>, since <span class="inlinecode"><span class="id" type="var">cons</span></span> expects a <span class="inlinecode"><span class="id" type="keyword">Type</span></span> as its first argument;
    matching <span class="inlinecode"><span class="id" type="var">l1</span></span> with <span class="inlinecode"><span class="id" type="var">nil</span></span> and <span class="inlinecode"><span class="id" type="var">cons</span></span> means it must be a <span class="inlinecode"><span class="id" type="var">list</span></span>; and
    so on.

<div class="paragraph"> </div>

    This powerful facility means we don't always have to write
    explicit type annotations everywhere, although explicit type
    annotations are still quite useful as documentation and sanity
    checks.  You should try to strike a balance in your own code
    between too many type annotations (which serve only to clutter and
    distract) and too few (which force the reader to perform type
    inference in their head in order to understand your code).

<div class="paragraph"> </div>

<a name="lab86"></a><h3 class="section">Argument Synthesis</h3>

<div class="paragraph"> </div>

 Whenever we use a polymorphic function, we need to pass it
    one or more types in addition to its other arguments.  For
    example, the recursive call in the body of the <span class="inlinecode"><span class="id" type="var">length</span></span> function
    above must pass along the type <span class="inlinecode"><span class="id" type="var">X</span></span>.  But just like providing
    explicit type annotations everywhere, this is heavy and verbose.
    Since the second argument to <span class="inlinecode"><span class="id" type="var">length</span></span> is a list of <span class="inlinecode"><span class="id" type="var">X</span></span>s, it seems
    entirely obvious that the first argument can only be <span class="inlinecode"><span class="id" type="var">X</span></span> &mdash; why
    should we have to write it explicitly?

<div class="paragraph"> </div>

    Fortunately, Coq permits us to avoid this kind of redundancy.  In
    place of any type argument we can write the "implicit argument"
    <span class="inlinecode"><span class="id" type="var">_</span></span>, which can be read as "Please figure out for yourself what
    type belongs here."  More precisely, when Coq encounters a <span class="inlinecode"><span class="id" type="var">_</span></span>, it
    will attempt to <i>unify</i> all locally available information &mdash; the
    type of the function being applied, the types of the other
    arguments, and the type expected by the context in which the
    application appears &mdash; to determine what concrete type should
    replace the <span class="inlinecode"><span class="id" type="var">_</span></span>.

<div class="paragraph"> </div>

    This may sound similar to type inference &mdash; in fact, the two
    procedures rely on the same underlying mechanisms.  Instead of
    simply omitting the types of some arguments to a function, like

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">app'</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">l1</span>&nbsp;<span class="id" type="var">l2</span>&nbsp;:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">X</span>&nbsp;:=&nbsp;
<div class="paragraph"> </div>

</div>
    we can also replace the types with <span class="inlinecode"><span class="id" type="var">_</span></span>, like

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">app'</span>&nbsp;(<span class="id" type="var">X</span>&nbsp;:&nbsp;<span class="id" type="var">_</span>)&nbsp;(<span class="id" type="var">l1</span>&nbsp;<span class="id" type="var">l2</span>&nbsp;:&nbsp;<span class="id" type="var">_</span>)&nbsp;:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">X</span>&nbsp;:=
<div class="paragraph"> </div>

</div>
    which tells Coq to attempt to infer the missing information, just
    as with argument synthesis.

<div class="paragraph"> </div>

    Using implicit arguments, the <span class="inlinecode"><span class="id" type="var">length</span></span> function can be written
    like this: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="length'"><span class="id" type="definition">length'</span></a> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">l</span>:<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) : <span class="id" type="inductive">nat</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a>      =&gt; 0<br/>
&nbsp;&nbsp;| <a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">h</span> <span class="id" type="var">t</span> =&gt; <span class="id" type="constructor">S</span> (<a class="idref" href="Poly.html#length'"><span class="id" type="definition">length'</span></a> <span class="id" type="var">_</span> <span class="id" type="var">t</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
In this instance, we don't save much by writing <span class="inlinecode"><span class="id" type="var">_</span></span> instead of
    <span class="inlinecode"><span class="id" type="var">X</span></span>.  But in many cases the difference can be significant.  For
    example, suppose we want to write down a list containing the
    numbers <span class="inlinecode">1</span>, <span class="inlinecode">2</span>, and <span class="inlinecode">3</span>.  Instead of writing this... 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="list123"><span class="id" type="definition">list123</span></a> := <br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="inductive">nat</span> 1 (<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="inductive">nat</span> 2 (<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="inductive">nat</span> 3 (<a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a> <span class="id" type="inductive">nat</span>))).<br/>

<br/>
</div>

<div class="doc">
...we can use argument synthesis to write this: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="list123'"><span class="id" type="definition">list123'</span></a> := <a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">_</span> 1 (<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">_</span> 2 (<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">_</span> 3 (<a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a> <span class="id" type="var">_</span>))).<br/>

<br/>
</div>

<div class="doc">
<a name="lab87"></a><h3 class="section">Implicit Arguments</h3>

<div class="paragraph"> </div>

 If fact, we can go further.  To avoid having to sprinkle <span class="inlinecode"><span class="id" type="var">_</span></span>'s
    throughout our programs, we can tell Coq <i>always</i> to infer the
    type argument(s) of a given function. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Implicit Arguments</span> <a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a> [[<span class="id" type="var">X</span>]].<br/>
<span class="id" type="keyword">Implicit Arguments</span> <a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> [[<span class="id" type="var">X</span>]].<br/>
<span class="id" type="keyword">Implicit Arguments</span> <a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> [[<span class="id" type="var">X</span>]].<br/>
<span class="id" type="keyword">Implicit Arguments</span> <a class="idref" href="Poly.html#app"><span class="id" type="definition">app</span></a> [[<span class="id" type="var">X</span>]].<br/>
<span class="id" type="keyword">Implicit Arguments</span> <a class="idref" href="Poly.html#rev"><span class="id" type="definition">rev</span></a> [[<span class="id" type="var">X</span>]].<br/>
<span class="id" type="keyword">Implicit Arguments</span> <a class="idref" href="Poly.html#snoc"><span class="id" type="definition">snoc</span></a> [[<span class="id" type="var">X</span>]].<br/>

<br/>
<span class="comment">(*&nbsp;note:&nbsp;no&nbsp;_&nbsp;arguments&nbsp;required...&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <a name="list123''"><span class="id" type="definition">list123''</span></a> := <a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> 1 (<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> 2 (<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> 3 <a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a>)).<br/>
<span class="id" type="keyword">Check</span> (<a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="Poly.html#list123''"><span class="id" type="definition">list123''</span></a>).<br/>

<br/>
</div>

<div class="doc">
We can also declare an argument to be implicit while
    defining the function itself, by surrounding the argument in curly
    braces.  For example: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="length''"><span class="id" type="definition">length''</span></a> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} (<span class="id" type="var">l</span>:<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) : <span class="id" type="inductive">nat</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a>      =&gt; 0<br/>
&nbsp;&nbsp;| <a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">h</span> <span class="id" type="var">t</span> =&gt; <span class="id" type="constructor">S</span> (<a class="idref" href="Poly.html#length''"><span class="id" type="definition">length''</span></a> <span class="id" type="var">t</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
(Note that we didn't even have to provide a type argument to
    the recursive call to <span class="inlinecode"><span class="id" type="var">length''</span></span>.)  We will use this style
    whenever possible, although we will continue to use use explicit
    <span class="inlinecode"><span class="id" type="keyword">Implicit</span></span> <span class="inlinecode"><span class="id" type="var">Argument</span></span> declarations for <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> constructors. 
<div class="paragraph"> </div>

 One small problem with declaring arguments <span class="inlinecode"><span class="id" type="keyword">Implicit</span></span> is
    that, occasionally, Coq does not have enough local information to
    determine a type argument; in such cases, we need to tell Coq that
    we want to give the argument explicitly this time, even though
    we've globally declared it to be <span class="inlinecode"><span class="id" type="keyword">Implicit</span></span>.  For example, if we
    write: 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;Definition&nbsp;mynil&nbsp;:=&nbsp;nil.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
If we uncomment this definition, Coq will give us an error,
    because it doesn't know what type argument to supply to <span class="inlinecode"><span class="id" type="var">nil</span></span>.  We
    can help it by providing an explicit type declaration (so that Coq
    has more information available when it gets to the "application"
    of <span class="inlinecode"><span class="id" type="var">nil</span></span>): 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="mynil"><span class="id" type="definition">mynil</span></a> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="inductive">nat</span> := <a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a>.<br/>

<br/>
</div>

<div class="doc">
Alternatively, we can force the implicit arguments to be explicit by
   prefixing the function name with <span class="inlinecode">@</span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> @<a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="mynil'"><span class="id" type="definition">mynil'</span></a> := @<a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a> <span class="id" type="inductive">nat</span>.<br/>

<br/>
</div>

<div class="doc">
Using argument synthesis and implicit arguments, we can
    define convenient notation for lists, as before.  Since we have
    made the constructor type arguments implicit, Coq will know to
    automatically infer these when we use the notations. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> "x :: y" := (<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 60, <span class="id" type="var">right</span> <span class="id" type="var">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> "[ ]" := <a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a>.<br/>
<span class="id" type="keyword">Notation</span> "[ x , .. , y ]" := (<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">x</span> .. (<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <span class="id" type="var">y</span> []) ..).<br/>
<span class="id" type="keyword">Notation</span> "x ++ y" := (<a class="idref" href="Poly.html#app"><span class="id" type="definition">app</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 60, <span class="id" type="var">right</span> <span class="id" type="var">associativity</span>).<br/>

<br/>
</div>

<div class="doc">
Now lists can be written just the way we'd hope: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="list123'''"><span class="id" type="definition">list123'''</span></a> := [1, 2, 3].<br/>

<br/>
</div>

<div class="doc">
<a name="lab88"></a><h3 class="section">Exercises: Polymorphic Lists</h3>

<div class="paragraph"> </div>

<a name="lab89"></a><h4 class="section">Exercise: 2 stars, optional (poly_exercises)</h4>
 Here are a few simple exercises, just like ones in Lists.v, for
    practice with polymorphism.  Fill in the definitions and complete
    the proofs below. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="repeat"><span class="id" type="definition">repeat</span></a> (<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">n</span> : <span class="id" type="var">X</span>) (<span class="id" type="var">count</span> : <span class="id" type="inductive">nat</span>) : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span> := <br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="test_repeat1"><span class="id" type="definition">test_repeat1</span></a>: <br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#repeat"><span class="id" type="definition">repeat</span></a> <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a> <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> 2 = <a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> (<a class="idref" href="Poly.html#cons"><span class="id" type="constructor">cons</span></a> <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a>).<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="nil_app"><span class="id" type="lemma">nil_app</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>, <span style="font-family: arial;">&forall;</span> <span class="id" type="var">l</span>:<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>, <br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#app"><span class="id" type="definition">app</span></a> [] <span class="id" type="var">l</span> = <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="rev_snoc"><span class="id" type="lemma">rev_snoc</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span> <span class="id" type="var">v</span> : <span class="id" type="var">X</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span> <span class="id" type="var">s</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#rev"><span class="id" type="definition">rev</span></a> (<a class="idref" href="Poly.html#snoc"><span class="id" type="definition">snoc</span></a> <span class="id" type="var">s</span> <span class="id" type="var">v</span>) = <span class="id" type="var">v</span> :: (<a class="idref" href="Poly.html#rev"><span class="id" type="definition">rev</span></a> <span class="id" type="var">s</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="snoc_with_append"><span class="id" type="lemma">snoc_with_append</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span> <span class="id" type="var">l1</span> <span class="id" type="var">l2</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span> <span class="id" type="var">v</span> : <span class="id" type="var">X</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#snoc"><span class="id" type="definition">snoc</span></a> (<span class="id" type="var">l1</span> ++ <span class="id" type="var">l2</span>) <span class="id" type="var">v</span> = <span class="id" type="var">l1</span> ++ (<a class="idref" href="Poly.html#snoc"><span class="id" type="definition">snoc</span></a> <span class="id" type="var">l2</span> <span class="id" type="var">v</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab90"></a><h2 class="section">Polymorphic Pairs</h2>

<div class="paragraph"> </div>

 Following the same pattern, the type definition we gave in
    the last chapter for pairs of numbers can be generalized to
    <i>polymorphic pairs</i> (or <i>products</i>): 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="prod"><span class="id" type="inductive">prod</span></a> (<span class="id" type="var">X</span> <span class="id" type="var">Y</span> : <span class="id" type="keyword">Type</span>) : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<a name="pair"><span class="id" type="constructor">pair</span></a> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Y</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Poly.html#prod"><span class="id" type="inductive">prod</span></a> <span class="id" type="var">X</span> <span class="id" type="var">Y</span>.<br/>

<br/>
<span class="id" type="keyword">Implicit Arguments</span> <a class="idref" href="Poly.html#pair"><span class="id" type="constructor">pair</span></a> [[<span class="id" type="var">X</span>] [<span class="id" type="var">Y</span>]].<br/>

<br/>
</div>

<div class="doc">
As with lists, we make the type arguments implicit and define the
    familiar concrete notation. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> "( x , y )" := (<a class="idref" href="Poly.html#pair"><span class="id" type="constructor">pair</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>).<br/>

<br/>
</div>

<div class="doc">
We can also use the <span class="inlinecode"><span class="id" type="keyword">Notation</span></span> mechanism to define the standard
    notation for pair <i>types</i>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> "X * Y" := (<a class="idref" href="Poly.html#prod"><span class="id" type="inductive">prod</span></a> <span class="id" type="var">X</span> <span class="id" type="var">Y</span>) : <span class="id" type="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
(The annotation <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">type_scope</span></span> tells Coq that this abbreviation
    should be used when parsing types.  This avoids a clash with the
    multiplication symbol.) 
<div class="paragraph"> </div>

 A note of caution: it is easy at first to get <span class="inlinecode">(<span class="id" type="var">x</span>,<span class="id" type="var">y</span>)</span> and
    <span class="inlinecode"><span class="id" type="var">X</span>*<span class="id" type="var">Y</span></span> confused.  Remember that <span class="inlinecode">(<span class="id" type="var">x</span>,<span class="id" type="var">y</span>)</span> is a <i>value</i> consisting of a
    pair of values; <span class="inlinecode"><span class="id" type="var">X</span>*<span class="id" type="var">Y</span></span> is a <i>type</i> consisting of a pair of types.  If
    <span class="inlinecode"><span class="id" type="var">x</span></span> has type <span class="inlinecode"><span class="id" type="var">X</span></span> and <span class="inlinecode"><span class="id" type="var">y</span></span> has type <span class="inlinecode"><span class="id" type="var">Y</span></span>, then <span class="inlinecode">(<span class="id" type="var">x</span>,<span class="id" type="var">y</span>)</span> has type <span class="inlinecode"><span class="id" type="var">X</span>*<span class="id" type="var">Y</span></span>. 
<div class="paragraph"> </div>

 The first and second projection functions now look pretty
    much as they would in any functional programming language. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="fst"><span class="id" type="definition">fst</span></a> {<span class="id" type="var">X</span> <span class="id" type="var">Y</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">p</span> : <span class="id" type="var">X</span> * <span class="id" type="var">Y</span>) : <span class="id" type="var">X</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span> (<span class="id" type="var">x</span>,<span class="id" type="var">y</span>) =&gt; <span class="id" type="var">x</span> <span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="snd"><span class="id" type="definition">snd</span></a> {<span class="id" type="var">X</span> <span class="id" type="var">Y</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">p</span> : <span class="id" type="var">X</span> * <span class="id" type="var">Y</span>) : <span class="id" type="var">Y</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span> (<span class="id" type="var">x</span>,<span class="id" type="var">y</span>) =&gt; <span class="id" type="var">y</span> <span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The following function takes two lists and combines them
    into a list of pairs.  In many functional programming languages,
    it is called <span class="inlinecode"><span class="id" type="var">zip</span></span>.  We call it <span class="inlinecode"><span class="id" type="var">combine</span></span> for consistency with
    Coq's standard library.  Note that the pair notation can be used both in expressions and in
    patterns... 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="combine"><span class="id" type="definition">combine</span></a> {<span class="id" type="var">X</span> <span class="id" type="var">Y</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">lx</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) (<span class="id" type="var">ly</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">Y</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> (<span class="id" type="var">X</span>*<span class="id" type="var">Y</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> (<span class="id" type="var">lx</span>,<span class="id" type="var">ly</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| ([],_) =&gt; []<br/>
&nbsp;&nbsp;| (<span class="id" type="var">_</span>,[]) =&gt; []<br/>
&nbsp;&nbsp;| (<span class="id" type="var">x</span>::<span class="id" type="var">tx</span>, <span class="id" type="var">y</span>::<span class="id" type="var">ty</span>) =&gt; (<span class="id" type="var">x</span>,<span class="id" type="var">y</span>) :: (<a class="idref" href="Poly.html#combine"><span class="id" type="definition">combine</span></a> <span class="id" type="var">tx</span> <span class="id" type="var">ty</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Indeed, when no ambiguity results, we can even drop the enclosing
    parens: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="combine'"><span class="id" type="definition">combine'</span></a> {<span class="id" type="var">X</span> <span class="id" type="var">Y</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">lx</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) (<span class="id" type="var">ly</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">Y</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> (<span class="id" type="var">X</span>*<span class="id" type="var">Y</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">lx</span>,<span class="id" type="var">ly</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [],_ =&gt; []<br/>
&nbsp;&nbsp;| <span class="id" type="var">_</span>,[] =&gt; []<br/>
&nbsp;&nbsp;| <span class="id" type="var">x</span>::<span class="id" type="var">tx</span>, <span class="id" type="var">y</span>::<span class="id" type="var">ty</span> =&gt; (<span class="id" type="var">x</span>,<span class="id" type="var">y</span>) :: (<a class="idref" href="Poly.html#combine'"><span class="id" type="definition">combine'</span></a> <span class="id" type="var">tx</span> <span class="id" type="var">ty</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab91"></a><h4 class="section">Exercise: 1 star (combine_checks)</h4>
 Try answering the following questions on paper and
    checking your answers in coq:

<div class="paragraph"> </div>

<ul class="doclist">
<li> What is the type of <span class="inlinecode"><span class="id" type="var">combine</span></span> (i.e., what does <span class="inlinecode"><span class="id" type="keyword">Check</span></span> 
      <span class="inlinecode">@<span class="id" type="var">combine</span></span> print?)

</li>
<li> What does

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="keyword">Eval</span>&nbsp;<span class="id" type="tactic">simpl</span>&nbsp;<span class="id" type="keyword">in</span>&nbsp;(<span class="id" type="var">combine</span>&nbsp;[1,2]&nbsp;[<span class="id" type="var">false</span>,<span class="id" type="var">false</span>,<span class="id" type="var">true</span>,<span class="id" type="var">true</span>]).
<div class="paragraph"> </div>

</div>
      print?   <font size=-2>&#9744;</font>

</li>
</ul>

<div class="paragraph"> </div>

<a name="lab92"></a><h4 class="section">Exercise: 2 stars, recommended (split)</h4>
 The function <span class="inlinecode"><span class="id" type="tactic">split</span></span> is the right inverse of combine: it takes a
    list of pairs and returns a pair of lists.  In many functional
    programing languages, this function is called <span class="inlinecode"><span class="id" type="var">unzip</span></span>.

<div class="paragraph"> </div>

    Uncomment the material below and fill in the definition of
    <span class="inlinecode"><span class="id" type="tactic">split</span></span>.  Make sure it passes the given unit tests. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;<br/>
Fixpoint&nbsp;split&nbsp;<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<br/>
Example&nbsp;test_split:<br/>
&nbsp;&nbsp;split&nbsp;<span class="inlinecode">(1,<span class="id" type="var">false</span>),(2,<span class="id" type="var">false</span>)</span>&nbsp;=&nbsp;(<span class="inlinecode">1,2</span>,<span class="inlinecode"><span class="id" type="var">false</span>,<span class="id" type="var">false</span></span>).<br/>
Proof.&nbsp;reflexivity.&nbsp;&nbsp;Qed.<br/>
*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab93"></a><h2 class="section">Polymorphic Options</h2>

<div class="paragraph"> </div>

 One last polymorphic type for now: <i>polymorphic options</i>.
    The type declaration generalizes the one for <span class="inlinecode"><span class="id" type="var">natoption</span></span> in the
    previous chapter: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="option"><span class="id" type="inductive">option</span></a> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="Some"><span class="id" type="constructor">Some</span></a> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Poly.html#option"><span class="id" type="inductive">option</span></a> <span class="id" type="var">X</span><br/>
&nbsp;&nbsp;| <a name="None"><span class="id" type="constructor">None</span></a> : <a class="idref" href="Poly.html#option"><span class="id" type="inductive">option</span></a> <span class="id" type="var">X</span>.<br/>

<br/>
<span class="id" type="keyword">Implicit Arguments</span> <a class="idref" href="Poly.html#Some"><span class="id" type="constructor">Some</span></a> [[<span class="id" type="var">X</span>]].<br/>
<span class="id" type="keyword">Implicit Arguments</span> <a class="idref" href="Poly.html#None"><span class="id" type="constructor">None</span></a> [[<span class="id" type="var">X</span>]].<br/>

<br/>
</div>

<div class="doc">
We can now rewrite the <span class="inlinecode"><span class="id" type="var">index</span></span> function so that it works
    with any type of lists. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="index"><span class="id" type="definition">index</span></a> {<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">n</span> : <span class="id" type="inductive">nat</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) : <a class="idref" href="Poly.html#option"><span class="id" type="inductive">option</span></a> <span class="id" type="var">X</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] =&gt; <a class="idref" href="Poly.html#None"><span class="id" type="constructor">None</span></a> <br/>
&nbsp;&nbsp;| <span class="id" type="var">a</span> :: <span class="id" type="var">l'</span> =&gt; <span class="id" type="keyword">if</span> <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="constructor">O</span> <span class="id" type="keyword">then</span> <a class="idref" href="Poly.html#Some"><span class="id" type="constructor">Some</span></a> <span class="id" type="var">a</span> <span class="id" type="keyword">else</span> <a class="idref" href="Poly.html#index"><span class="id" type="definition">index</span></a> (<span class="id" type="definition">pred</span> <span class="id" type="var">n</span>) <span class="id" type="var">l'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="test_index1"><span class="id" type="definition">test_index1</span></a> :    <a class="idref" href="Poly.html#index"><span class="id" type="definition">index</span></a> 0 [4,5,6,7]  = <a class="idref" href="Poly.html#Some"><span class="id" type="constructor">Some</span></a> 4.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="test_index2"><span class="id" type="definition">test_index2</span></a> :    <a class="idref" href="Poly.html#index"><span class="id" type="definition">index</span></a>  1 [[1],[2]]  = <a class="idref" href="Poly.html#Some"><span class="id" type="constructor">Some</span></a> [2].<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="test_index3"><span class="id" type="definition">test_index3</span></a> :    <a class="idref" href="Poly.html#index"><span class="id" type="definition">index</span></a>  2 [<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>]  = <a class="idref" href="Poly.html#None"><span class="id" type="constructor">None</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab94"></a><h4 class="section">Exercise: 1 star, optional (hd_opt_poly)</h4>
 Complete the definition of a polymorphic version of the
    <span class="inlinecode"><span class="id" type="var">hd_opt</span></span> function from the last chapter. Be sure that it
    passes the unit tests below. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="hd_opt"><span class="id" type="definition">hd_opt</span></a> {<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>)  : <a class="idref" href="Poly.html#option"><span class="id" type="inductive">option</span></a> <span class="id" type="var">X</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
</div>

<div class="doc">
Once again, to force the implicit arguments to be explicit, 
    we can use <span class="inlinecode">@</span> before the name of the function. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> @<a class="idref" href="Poly.html#hd_opt"><span class="id" type="definition">hd_opt</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="test_hd_opt1"><span class="id" type="definition">test_hd_opt1</span></a> :  <a class="idref" href="Poly.html#hd_opt"><span class="id" type="definition">hd_opt</span></a> [1,2] = <a class="idref" href="Poly.html#Some"><span class="id" type="constructor">Some</span></a> 1.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="test_hd_opt2"><span class="id" type="definition">test_hd_opt2</span></a> :   <a class="idref" href="Poly.html#hd_opt"><span class="id" type="definition">hd_opt</span></a>  [[1],[2]]  = <a class="idref" href="Poly.html#Some"><span class="id" type="constructor">Some</span></a> [1].<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab95"></a><h1 class="section">Functions as Data</h1>

<div class="paragraph"> </div>

<a name="lab96"></a><h2 class="section">Higher-Order Functions</h2>

<div class="paragraph"> </div>

 Like many other modern programming languages &mdash; including,
    of course, all <i>functional languages</i> &mdash; Coq treats functions as
    first-class citizens, allowing functions to be passed as arguments
    to other functions, returned as results, stored in data
    structures, etc.

<div class="paragraph"> </div>

    Functions that manipulate other functions are often called
    <i>higher-order</i> functions.  Here's a simple one: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="doit3times"><span class="id" type="definition">doit3times</span></a> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} (<span class="id" type="var">f</span>:<span class="id" type="var">X</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">X</span>) (<span class="id" type="var">n</span>:<span class="id" type="var">X</span>) : <span class="id" type="var">X</span> := <br/>
&nbsp;&nbsp;<span class="id" type="var">f</span> (<span class="id" type="var">f</span> (<span class="id" type="var">f</span> <span class="id" type="var">n</span>)).<br/>

<br/>
</div>

<div class="doc">
The argument <span class="inlinecode"><span class="id" type="var">f</span></span> here is itself a function (from <span class="inlinecode"><span class="id" type="var">X</span></span> to
    <span class="inlinecode"><span class="id" type="var">X</span></span>); the body of <span class="inlinecode"><span class="id" type="var">doit3times</span></span> applies <span class="inlinecode"><span class="id" type="var">f</span></span> three times to some
    value <span class="inlinecode"><span class="id" type="var">n</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> @<a class="idref" href="Poly.html#doit3times"><span class="id" type="definition">doit3times</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;doit3times&nbsp;:&nbsp;forall&nbsp;X&nbsp;:&nbsp;Type,&nbsp;(X&nbsp;-&gt;&nbsp;X)&nbsp;-&gt;&nbsp;X&nbsp;-&gt;&nbsp;X&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="test_doit3times"><span class="id" type="definition">test_doit3times</span></a>: <a class="idref" href="Poly.html#doit3times"><span class="id" type="definition">doit3times</span></a> <a class="idref" href="Basics.html#minustwo"><span class="id" type="definition">minustwo</span></a> 9 = 3.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="test_doit3times'"><span class="id" type="definition">test_doit3times'</span></a>: <a class="idref" href="Poly.html#doit3times"><span class="id" type="definition">doit3times</span></a> <a class="idref" href="Basics.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab97"></a><h2 class="section">Partial Application</h2>

<div class="paragraph"> </div>

 In fact, the multiple-argument functions we have already
    seen are also examples of passing functions as data.  To see why,
    recall that the type of <span class="inlinecode"><span class="id" type="var">plus</span></span>, for instance, is <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span>
    <span class="inlinecode"><span class="id" type="var">nat</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="definition">plus</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> is actually a <i>binary</i> operator on types; that is,
    Coq primitively supports only one-argument functions.  Moreover,
    this operator is <i>right-associative</i>, so the type of <span class="inlinecode"><span class="id" type="var">plus</span></span> is
    really a shorthand for <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode">(<span class="id" type="var">nat</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">nat</span>)</span> &mdash; i.e., it can be
    read as saying that "<span class="inlinecode"><span class="id" type="var">plus</span></span> is a one-argument function that takes
    a <span class="inlinecode"><span class="id" type="var">nat</span></span> and returns a one-argument function that takes another
    <span class="inlinecode"><span class="id" type="var">nat</span></span> and returns a <span class="inlinecode"><span class="id" type="var">nat</span></span>."  In the examples above, we have always
    applied <span class="inlinecode"><span class="id" type="var">plus</span></span> to both of its arguments at once, but if we like we
    can supply just the first.  This is called <i>partial
    application</i>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="plus3"><span class="id" type="definition">plus3</span></a> := <span class="id" type="definition">plus</span> 3.<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Poly.html#plus3"><span class="id" type="definition">plus3</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="test_plus3"><span class="id" type="definition">test_plus3</span></a> :    <a class="idref" href="Poly.html#plus3"><span class="id" type="definition">plus3</span></a> 4 = 7.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="test_plus3'"><span class="id" type="definition">test_plus3'</span></a> :   <a class="idref" href="Poly.html#doit3times"><span class="id" type="definition">doit3times</span></a> <a class="idref" href="Poly.html#plus3"><span class="id" type="definition">plus3</span></a> 0 = 9.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="test_plus3''"><span class="id" type="definition">test_plus3''</span></a> :  <a class="idref" href="Poly.html#doit3times"><span class="id" type="definition">doit3times</span></a> (<span class="id" type="definition">plus</span> 3) 0 = 9.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab98"></a><h2 class="section">Digression: Currying</h2>

<div class="paragraph"> </div>

<a name="lab99"></a><h4 class="section">Exercise: 2 stars, optional (currying)</h4>
 In Coq, a function <span class="inlinecode"><span class="id" type="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">C</span></span> really has the type <span class="inlinecode"><span class="id" type="var">A</span></span>
    <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode">(<span class="id" type="var">B</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">C</span>)</span>.  That is, if you give <span class="inlinecode"><span class="id" type="var">f</span></span> a value of type <span class="inlinecode"><span class="id" type="var">A</span></span>, it
    will give you function <span class="inlinecode"><span class="id" type="var">f'</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">B</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">C</span></span>.  If you then give <span class="inlinecode"><span class="id" type="var">f'</span></span> a
    value of type <span class="inlinecode"><span class="id" type="var">B</span></span>, it will return a value of type <span class="inlinecode"><span class="id" type="var">C</span></span>.  This
    allows for partial application, as in <span class="inlinecode"><span class="id" type="var">plus3</span></span>.  Processing a list
    of arguments with functions that return functions is called
    <i>currying</i>, in honor of the logician Haskell Curry.

<div class="paragraph"> </div>

    Conversely, we can reinterpret the type <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">B</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">C</span></span> as <span class="inlinecode">(<span class="id" type="var">A</span></span> <span class="inlinecode">*</span>
    <span class="inlinecode"><span class="id" type="var">B</span>)</span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">C</span></span>.  This is called <i>uncurrying</i>.  With an uncurried binary
    function, both arguments must be given at once as a pair; there is
    no partial application. 
<div class="paragraph"> </div>

 We can define currying as follows: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="prod_curry"><span class="id" type="definition">prod_curry</span></a> {<span class="id" type="var">X</span> <span class="id" type="var">Y</span> <span class="id" type="var">Z</span> : <span class="id" type="keyword">Type</span>}<br/>
&nbsp;&nbsp;(<span class="id" type="var">f</span> : <span class="id" type="var">X</span> * <span class="id" type="var">Y</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Z</span>) (<span class="id" type="var">x</span> : <span class="id" type="var">X</span>) (<span class="id" type="var">y</span> : <span class="id" type="var">Y</span>) : <span class="id" type="var">Z</span> := <span class="id" type="var">f</span> (<span class="id" type="var">x</span>, <span class="id" type="var">y</span>).<br/>

<br/>
</div>

<div class="doc">
As an exercise, define its inverse, <span class="inlinecode"><span class="id" type="var">prod_uncurry</span></span>.  Then prove
    the theorems below to show that the two are inverses. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="prod_uncurry"><span class="id" type="definition">prod_uncurry</span></a> {<span class="id" type="var">X</span> <span class="id" type="var">Y</span> <span class="id" type="var">Z</span> : <span class="id" type="keyword">Type</span>}<br/>
&nbsp;&nbsp;(<span class="id" type="var">f</span> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Y</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Z</span>) (<span class="id" type="var">p</span> : <span class="id" type="var">X</span> * <span class="id" type="var">Y</span>) : <span class="id" type="var">Z</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
</div>

<div class="doc">
(Thought exercise: before running these commands, can you
    calculate the types of <span class="inlinecode"><span class="id" type="var">prod_curry</span></span> and <span class="inlinecode"><span class="id" type="var">prod_uncurry</span></span>?) 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> @<a class="idref" href="Poly.html#prod_curry"><span class="id" type="definition">prod_curry</span></a>.<br/>
<span class="id" type="keyword">Check</span> @<a class="idref" href="Poly.html#prod_uncurry"><span class="id" type="definition">prod_uncurry</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="uncurry_curry"><span class="id" type="lemma">uncurry_curry</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">X</span> <span class="id" type="var">Y</span> <span class="id" type="var">Z</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">f</span> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Y</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Z</span>) <span class="id" type="var">x</span> <span class="id" type="var">y</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#prod_curry"><span class="id" type="definition">prod_curry</span></a> (<a class="idref" href="Poly.html#prod_uncurry"><span class="id" type="definition">prod_uncurry</span></a> <span class="id" type="var">f</span>) <span class="id" type="var">x</span> <span class="id" type="var">y</span> = <span class="id" type="var">f</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="curry_uncurry"><span class="id" type="lemma">curry_uncurry</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">X</span> <span class="id" type="var">Y</span> <span class="id" type="var">Z</span> : <span class="id" type="keyword">Type</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">f</span> : (<span class="id" type="var">X</span> * <span class="id" type="var">Y</span>) <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Z</span>) (<span class="id" type="var">p</span> : <span class="id" type="var">X</span> * <span class="id" type="var">Y</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#prod_uncurry"><span class="id" type="definition">prod_uncurry</span></a> (<a class="idref" href="Poly.html#prod_curry"><span class="id" type="definition">prod_curry</span></a> <span class="id" type="var">f</span>) <span class="id" type="var">p</span> = <span class="id" type="var">f</span> <span class="id" type="var">p</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab100"></a><h2 class="section">Filter</h2>

<div class="paragraph"> </div>

 Here is a useful higher-order function, which takes a list
    of <span class="inlinecode"><span class="id" type="var">X</span></span>s and a <i>predicate</i> on <span class="inlinecode"><span class="id" type="var">X</span></span> (a function from <span class="inlinecode"><span class="id" type="var">X</span></span> to <span class="inlinecode"><span class="id" type="var">bool</span></span>)
    and "filters" the list, returning a new list containing just those
    elements for which the predicate returns <span class="inlinecode"><span class="id" type="var">true</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="filter"><span class="id" type="definition">filter</span></a> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} (<span class="id" type="var">test</span>: <span class="id" type="var">X</span><span style="font-family: arial;">&rarr;</span><a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a>) (<span class="id" type="var">l</span>:<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: (<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| []     =&gt; []<br/>
&nbsp;&nbsp;| <span class="id" type="var">h</span> :: <span class="id" type="var">t</span> =&gt; <span class="id" type="keyword">if</span> <span class="id" type="var">test</span> <span class="id" type="var">h</span> <span class="id" type="keyword">then</span> <span class="id" type="var">h</span> :: (<a class="idref" href="Poly.html#filter"><span class="id" type="definition">filter</span></a> <span class="id" type="var">test</span> <span class="id" type="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span>       <a class="idref" href="Poly.html#filter"><span class="id" type="definition">filter</span></a> <span class="id" type="var">test</span> <span class="id" type="var">t</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
For example, if we apply <span class="inlinecode"><span class="id" type="var">filter</span></span> to the predicate <span class="inlinecode"><span class="id" type="var">evenb</span></span>
    and a list of numbers <span class="inlinecode"><span class="id" type="var">l</span></span>, it returns a list containing just the
    even members of <span class="inlinecode"><span class="id" type="var">l</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="test_filter1"><span class="id" type="definition">test_filter1</span></a>: <a class="idref" href="Poly.html#filter"><span class="id" type="definition">filter</span></a> <a class="idref" href="Basics.html#evenb"><span class="id" type="definition">evenb</span></a> [1,2,3,4] = [2,4].<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="length_is_1"><span class="id" type="definition">length_is_1</span></a> {<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> (<a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> <span class="id" type="var">l</span>) 1.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="test_filter2"><span class="id" type="definition">test_filter2</span></a>: <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Poly.html#filter"><span class="id" type="definition">filter</span></a> <a class="idref" href="Poly.html#length_is_1"><span class="id" type="definition">length_is_1</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ [1, 2], [3], [4], [5,6,7], [], [8] ]<br/>
&nbsp;&nbsp;= [ [3], [4], [8] ].<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We can use <span class="inlinecode"><span class="id" type="var">filter</span></span> to give a concise version of the
    <span class="inlinecode"><span class="id" type="var">countoddmembers</span></span> function from <span class="inlinecode"><span class="id" type="var">Lists.v</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="countoddmembers'"><span class="id" type="definition">countoddmembers'</span></a> (<span class="id" type="var">l</span>:<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="inductive">nat</span>) : <span class="id" type="inductive">nat</span> := <br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> (<a class="idref" href="Poly.html#filter"><span class="id" type="definition">filter</span></a> <a class="idref" href="Basics.html#oddb"><span class="id" type="definition">oddb</span></a> <span class="id" type="var">l</span>).<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="test_countoddmembers'1"><span class="id" type="definition">test_countoddmembers'1</span></a>:   <a class="idref" href="Poly.html#countoddmembers'"><span class="id" type="definition">countoddmembers'</span></a> [1,0,3,1,4,5] = 4.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="test_countoddmembers'2"><span class="id" type="definition">test_countoddmembers'2</span></a>:   <a class="idref" href="Poly.html#countoddmembers'"><span class="id" type="definition">countoddmembers'</span></a> [0,2,4] = 0.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="test_countoddmembers'3"><span class="id" type="definition">test_countoddmembers'3</span></a>:   <a class="idref" href="Poly.html#countoddmembers'"><span class="id" type="definition">countoddmembers'</span></a> <a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a> = 0.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab101"></a><h2 class="section">Anonymous Functions</h2>

<div class="paragraph"> </div>

 It is a little annoying to be forced to define the function
    <span class="inlinecode"><span class="id" type="var">length_is_1</span></span> and give it a name just to be able to pass it as an
    argument to <span class="inlinecode"><span class="id" type="var">filter</span></span>, since we will probably never use it again.
    This is not an isolated example.  When using higher-order
    functions, we often want to pass as arguments "one-off" functions
    that we will never use again; having to give each of these
    functions a name would be tedious.

<div class="paragraph"> </div>

    Fortunately, there is a better way. It is also possible to
    construct a function "on the fly" without declaring it at the top
    level or giving it a name; this is analogous to the notation we've
    been using for writing down constant lists, natural numbers, and
    so on. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="test_anon_fun'"><span class="id" type="definition">test_anon_fun'</span></a>: <br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#doit3times"><span class="id" type="definition">doit3times</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">n</span> =&gt; <span class="id" type="var">n</span> * <span class="id" type="var">n</span>) 2 = 256.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Here is the motivating example from before, rewritten to use
    an anonymous function. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="test_filter2'"><span class="id" type="definition">test_filter2'</span></a>: <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Poly.html#filter"><span class="id" type="definition">filter</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">l</span> =&gt; <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> (<a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> <span class="id" type="var">l</span>) 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ [1, 2], [3], [4], [5,6,7], [], [8] ]<br/>
&nbsp;&nbsp;= [ [3], [4], [8] ].<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab102"></a><h4 class="section">Exercise: 2 stars, optional (filter_even_gt7)</h4>

<div class="paragraph"> </div>

 Use <span class="inlinecode"><span class="id" type="var">filter</span></span> to write a Coq function <span class="inlinecode"><span class="id" type="var">filter_even_gt7</span></span> which takes
    a list of natural numbers as input and keeps only those numbers
    which are even and greater than 7. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="filter_even_gt7"><span class="id" type="definition">filter_even_gt7</span></a> (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="inductive">nat</span>) : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="inductive">nat</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="test_filter_even_gt7_1"><span class="id" type="definition">test_filter_even_gt7_1</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#filter_even_gt7"><span class="id" type="definition">filter_even_gt7</span></a> [1,2,6,9,10,3,12,8] = [10,12,8].<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="test_filter_even_gt7_2"><span class="id" type="definition">test_filter_even_gt7_2</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#filter_even_gt7"><span class="id" type="definition">filter_even_gt7</span></a> [5,2,6,19,129] = [].<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab103"></a><h4 class="section">Exercise: 3 stars, optional (partition)</h4>
 Use <span class="inlinecode"><span class="id" type="var">filter</span></span> to write a Coq function <span class="inlinecode"><span class="id" type="var">partition</span></span>: 

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">partition</span>&nbsp;:&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">X</span>&nbsp;:&nbsp;<span class="id" type="keyword">Type</span>,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">X</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">bool</span>)&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">X</span>&nbsp;*&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">X</span>
<div class="paragraph"> </div>

</div>
   Given a set <span class="inlinecode"><span class="id" type="var">X</span></span>, a test function of type <span class="inlinecode"><span class="id" type="var">X</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">bool</span></span> and a <span class="inlinecode"><span class="id" type="var">list</span></span>
   <span class="inlinecode"><span class="id" type="var">X</span></span>, <span class="inlinecode"><span class="id" type="var">partition</span></span> should return a pair of lists.  The first member of
   the pair is the sublist of the original list containing the
   elements that satisfy the test, and the second is the sublist
   containing those that fail the test.  The order of elements in the
   two sublists should be the same as their order in the original
   list.

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="partition"><span class="id" type="definition">partition</span></a> {<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">test</span> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a>) (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span> * <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span> :=<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="test_partition1"><span class="id" type="definition">test_partition1</span></a>: <a class="idref" href="Poly.html#partition"><span class="id" type="definition">partition</span></a> <a class="idref" href="Basics.html#oddb"><span class="id" type="definition">oddb</span></a> [1,2,3,4,5] = ([1,3,5], [2,4]).<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <a name="test_partition2"><span class="id" type="definition">test_partition2</span></a>: <a class="idref" href="Poly.html#partition"><span class="id" type="definition">partition</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> =&gt; <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>) [5,9,0] = ([], [5,9,0]).<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab104"></a><h2 class="section">Map</h2>

<div class="paragraph"> </div>

 Another handy higher-order function is called <span class="inlinecode"><span class="id" type="var">map</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="map"><span class="id" type="definition">map</span></a> {<span class="id" type="var">X</span> <span class="id" type="var">Y</span>:<span class="id" type="keyword">Type</span>} (<span class="id" type="var">f</span>:<span class="id" type="var">X</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">Y</span>) (<span class="id" type="var">l</span>:<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: (<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">Y</span>) := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| []     =&gt; []<br/>
&nbsp;&nbsp;| <span class="id" type="var">h</span> :: <span class="id" type="var">t</span> =&gt; (<span class="id" type="var">f</span> <span class="id" type="var">h</span>) :: (<a class="idref" href="Poly.html#map"><span class="id" type="definition">map</span></a> <span class="id" type="var">f</span> <span class="id" type="var">t</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
It takes a function <span class="inlinecode"><span class="id" type="var">f</span></span> and a list <span class="inlinecode"></span> <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[<span class="id" type="var">n1</span>,</span> <span class="inlinecode"><span class="id" type="var">n2</span>,</span> <span class="inlinecode"><span class="id" type="var">n3</span>,</span> <span class="inlinecode">...]</span> <span class="inlinecode"></span>
    and returns the list <span class="inlinecode"></span> <span class="inlinecode">[<span class="id" type="var">f</span></span> <span class="inlinecode"><span class="id" type="var">n1</span>,</span> <span class="inlinecode"><span class="id" type="var">f</span></span> <span class="inlinecode"><span class="id" type="var">n2</span>,</span> <span class="inlinecode"><span class="id" type="var">f</span></span> <span class="inlinecode"><span class="id" type="var">n3</span>,...]</span> <span class="inlinecode"></span>, where <span class="inlinecode"><span class="id" type="var">f</span></span> has
    been applied to each element of <span class="inlinecode"><span class="id" type="var">l</span></span> in turn.  For example: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="test_map1"><span class="id" type="definition">test_map1</span></a>: <a class="idref" href="Poly.html#map"><span class="id" type="definition">map</span></a> (<span class="id" type="definition">plus</span> 3) [2,0,2] = [5,3,5].<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The element types of the input and output lists need not be
    the same (<span class="inlinecode"><span class="id" type="var">map</span></span> takes <i>two</i> type arguments, <span class="inlinecode"><span class="id" type="var">X</span></span> and <span class="inlinecode"><span class="id" type="var">Y</span></span>).  This
    version of <span class="inlinecode"><span class="id" type="var">map</span></span> can thus be applied to a list of numbers and a
    function from numbers to booleans to yield a list of booleans: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="test_map2"><span class="id" type="definition">test_map2</span></a>: <a class="idref" href="Poly.html#map"><span class="id" type="definition">map</span></a> <a class="idref" href="Basics.html#oddb"><span class="id" type="definition">oddb</span></a> [2,1,2,5] = [<a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>,<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>,<a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>,<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>].<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
It can even be applied to a list of numbers and
    a function from numbers to <i>lists</i> of booleans to
    yield a list of lists of booleans: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="test_map3"><span class="id" type="definition">test_map3</span></a>: <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Poly.html#map"><span class="id" type="definition">map</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">n</span> =&gt; [<a class="idref" href="Basics.html#evenb"><span class="id" type="definition">evenb</span></a> <span class="id" type="var">n</span>,<a class="idref" href="Basics.html#oddb"><span class="id" type="definition">oddb</span></a> <span class="id" type="var">n</span>]) [2,1,2,5] <br/>
&nbsp;&nbsp;= [[<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>,<a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>],[<a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>,<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>],[<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>,<a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>],[<a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>,<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>]].<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab105"></a><h4 class="section">Exercise: 3 stars, optional (map_rev)</h4>
 Show that <span class="inlinecode"><span class="id" type="var">map</span></span> and <span class="inlinecode"><span class="id" type="var">rev</span></span> commute.  You may need to define an
    auxiliary lemma. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="map_rev"><span class="id" type="lemma">map_rev</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">X</span> <span class="id" type="var">Y</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">f</span> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Y</span>) (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#map"><span class="id" type="definition">map</span></a> <span class="id" type="var">f</span> (<a class="idref" href="Poly.html#rev"><span class="id" type="definition">rev</span></a> <span class="id" type="var">l</span>) = <a class="idref" href="Poly.html#rev"><span class="id" type="definition">rev</span></a> (<a class="idref" href="Poly.html#map"><span class="id" type="definition">map</span></a> <span class="id" type="var">f</span> <span class="id" type="var">l</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab106"></a><h4 class="section">Exercise: 2 stars, recommended (flat_map)</h4>
 The function <span class="inlinecode"><span class="id" type="var">map</span></span> maps a <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> to a <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">Y</span></span> using a function
    of type <span class="inlinecode"><span class="id" type="var">X</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">Y</span></span>.  We can define a similar function, <span class="inlinecode"><span class="id" type="var">flat_map</span></span>,
    which maps a <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> to a <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">Y</span></span> using a function <span class="inlinecode"><span class="id" type="var">f</span></span> of type
    <span class="inlinecode"><span class="id" type="var">X</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">Y</span></span>.  Your definition should work by 'flattening' the
    results of <span class="inlinecode"><span class="id" type="var">f</span></span>, like so:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">flat_map</span>&nbsp;(<span class="id" type="keyword">fun</span>&nbsp;<span class="id" type="var">n</span>&nbsp;=&gt;&nbsp;[<span class="id" type="var">n</span>,<span class="id" type="var">n</span>+1,<span class="id" type="var">n</span>+2])&nbsp;[1,5,10]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;[1,&nbsp;2,&nbsp;3,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;10,&nbsp;11,&nbsp;12].
<div class="paragraph"> </div>

</div>

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="flat_map"><span class="id" type="definition">flat_map</span></a> {<span class="id" type="var">X</span> <span class="id" type="var">Y</span>:<span class="id" type="keyword">Type</span>} (<span class="id" type="var">f</span>:<span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">Y</span>) (<span class="id" type="var">l</span>:<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: (<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">Y</span>) := <br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="test_flat_map1"><span class="id" type="definition">test_flat_map1</span></a>: <br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#flat_map"><span class="id" type="definition">flat_map</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">n</span> =&gt; [<span class="id" type="var">n</span>,<span class="id" type="var">n</span>,<span class="id" type="var">n</span>]) [1,5,4]<br/>
&nbsp;&nbsp;= [1, 1, 1, 5, 5, 5, 4, 4, 4].<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Lists are not the only inductive type that we can write a
    <span class="inlinecode"><span class="id" type="var">map</span></span> function for.  Here is the definition of <span class="inlinecode"><span class="id" type="var">map</span></span> for the
    <span class="inlinecode"><span class="id" type="var">option</span></span> type: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="option_map"><span class="id" type="definition">option_map</span></a> {<span class="id" type="var">X</span> <span class="id" type="var">Y</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">f</span> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Y</span>) (<span class="id" type="var">xo</span> : <a class="idref" href="Poly.html#option"><span class="id" type="inductive">option</span></a> <span class="id" type="var">X</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="Poly.html#option"><span class="id" type="inductive">option</span></a> <span class="id" type="var">Y</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">xo</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Poly.html#None"><span class="id" type="constructor">None</span></a> =&gt; <a class="idref" href="Poly.html#None"><span class="id" type="constructor">None</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Poly.html#Some"><span class="id" type="constructor">Some</span></a> <span class="id" type="var">x</span> =&gt; <a class="idref" href="Poly.html#Some"><span class="id" type="constructor">Some</span></a> (<span class="id" type="var">f</span> <span class="id" type="var">x</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab107"></a><h4 class="section">Exercise: 2 stars, optional (implicit_args)</h4>
 The definitions and uses of <span class="inlinecode"><span class="id" type="var">filter</span></span> and <span class="inlinecode"><span class="id" type="var">map</span></span> use implicit
    arguments in many places.  Replace the curly braces around the
    implicit arguments with parentheses, and then fill in explicit
    type parameters where necessary and use Coq to check that you've
    done so correctly.  This exercise is not to be turned in; it is
    probably easiest to do it on a <i>copy</i> of this file that you can
    throw away afterwards.  <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab108"></a><h2 class="section">Fold</h2>

<div class="paragraph"> </div>

 An even more powerful higher-order function is called <span class="inlinecode"><span class="id" type="var">fold</span></span>.  It
    is the inspiration for the "<span class="inlinecode"><span class="id" type="var">reduce</span></span>" operation that lies at the
    heart of Google's map/reduce distributed programming framework. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="fold"><span class="id" type="definition">fold</span></a> {<span class="id" type="var">X</span> <span class="id" type="var">Y</span>:<span class="id" type="keyword">Type</span>} (<span class="id" type="var">f</span>: <span class="id" type="var">X</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">Y</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">Y</span>) (<span class="id" type="var">l</span>:<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) (<span class="id" type="var">b</span>:<span class="id" type="var">Y</span>) : <span class="id" type="var">Y</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a> =&gt; <span class="id" type="var">b</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">h</span> :: <span class="id" type="var">t</span> =&gt; <span class="id" type="var">f</span> <span class="id" type="var">h</span> (<a class="idref" href="Poly.html#fold"><span class="id" type="definition">fold</span></a> <span class="id" type="var">f</span> <span class="id" type="var">t</span> <span class="id" type="var">b</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Intuitively, the behavior of the <span class="inlinecode"><span class="id" type="var">fold</span></span> operation is to
    insert a given binary operator <span class="inlinecode"><span class="id" type="var">f</span></span> between every pair of elements
    in a given list.  For example, <span class="inlinecode"></span> <span class="inlinecode"><span class="id" type="var">fold</span></span> <span class="inlinecode"><span class="id" type="var">plus</span></span> <span class="inlinecode">[1,2,3,4]</span> <span class="inlinecode"></span> intuitively
    means <span class="inlinecode">1+2+3+4</span>.  To make this precise, we also need a "starting
    element" that serves as the initial second input to <span class="inlinecode"><span class="id" type="var">f</span></span>.  So, for
    example,

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="var">fold</span>&nbsp;<span class="id" type="var">plus</span>&nbsp;[1,2,3,4]&nbsp;0
<div class="paragraph"> </div>

</div>
    yields

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;1&nbsp;+&nbsp;(2&nbsp;+&nbsp;(3&nbsp;+&nbsp;(4&nbsp;+&nbsp;0))).
<div class="paragraph"> </div>

</div>
    Here are some more examples:

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> (<a class="idref" href="Poly.html#fold"><span class="id" type="definition">fold</span></a> <span class="id" type="definition">plus</span>).<br/>
<span class="id" type="keyword">Eval</span> <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> (<a class="idref" href="Poly.html#fold"><span class="id" type="definition">fold</span></a> <span class="id" type="definition">plus</span> [1,2,3,4] 0).<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="fold_example1"><span class="id" type="definition">fold_example1</span></a> : <a class="idref" href="Poly.html#fold"><span class="id" type="definition">fold</span></a> <span class="id" type="definition">mult</span> [1,2,3,4] 1 = 24.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="fold_example2"><span class="id" type="definition">fold_example2</span></a> : <a class="idref" href="Poly.html#fold"><span class="id" type="definition">fold</span></a> <a class="idref" href="Basics.html#andb"><span class="id" type="definition">andb</span></a> [<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>,<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>,<a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>,<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>] <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="fold_example3"><span class="id" type="definition">fold_example3</span></a> : <a class="idref" href="Poly.html#fold"><span class="id" type="definition">fold</span></a> <a class="idref" href="Poly.html#app"><span class="id" type="definition">app</span></a>  [[1],[],[2,3],[4]] [] = [1,2,3,4].<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab109"></a><h4 class="section">Exercise: 1 star, optional (fold_types_different)</h4>
 Observe that the type of <span class="inlinecode"><span class="id" type="var">fold</span></span> is parameterized by <i>two</i> type
    variables, <span class="inlinecode"><span class="id" type="var">X</span></span> and <span class="inlinecode"><span class="id" type="var">Y</span></span>, and the parameter <span class="inlinecode"><span class="id" type="var">f</span></span> is a binary operator
    that takes an <span class="inlinecode"><span class="id" type="var">X</span></span> and a <span class="inlinecode"><span class="id" type="var">Y</span></span> and returns a <span class="inlinecode"><span class="id" type="var">Y</span></span>.  Can you think of a
    situation where it would be useful for <span class="inlinecode"><span class="id" type="var">X</span></span> and <span class="inlinecode"><span class="id" type="var">Y</span></span> to be
    different? 
<div class="paragraph"> </div>

<a name="lab110"></a><h2 class="section">Functions For Constructing Functions</h2>

<div class="paragraph"> </div>

 Most of the higher-order functions we have talked about so
    far take functions as <i>arguments</i>.  Now let's look at some
    examples involving <i>returning</i> functions as the results of other
    functions.

<div class="paragraph"> </div>

    To begin, here is a function that takes a value <span class="inlinecode"><span class="id" type="var">x</span></span> (drawn from
    some type <span class="inlinecode"><span class="id" type="var">X</span></span>) and returns a function from <span class="inlinecode"><span class="id" type="var">nat</span></span> to <span class="inlinecode"><span class="id" type="var">X</span></span> that
    yields <span class="inlinecode"><span class="id" type="var">x</span></span> whenever it is called, ignoring its <span class="inlinecode"><span class="id" type="var">nat</span></span> argument. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="constfun"><span class="id" type="definition">constfun</span></a> {<span class="id" type="var">X</span>: <span class="id" type="keyword">Type</span>} (<span class="id" type="var">x</span>: <span class="id" type="var">X</span>) : <span class="id" type="inductive">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">X</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> (<span class="id" type="var">k</span>:<span class="id" type="inductive">nat</span>) =&gt; <span class="id" type="var">x</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="ftrue"><span class="id" type="definition">ftrue</span></a> := <a class="idref" href="Poly.html#constfun"><span class="id" type="definition">constfun</span></a> <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="constfun_example1"><span class="id" type="definition">constfun_example1</span></a> : <a class="idref" href="Poly.html#ftrue"><span class="id" type="definition">ftrue</span></a> 0 = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="constfun_example2"><span class="id" type="definition">constfun_example2</span></a> : (<a class="idref" href="Poly.html#constfun"><span class="id" type="definition">constfun</span></a> 5) 99 = 5.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Similarly, but a bit more interestingly, here is a function
    that takes a function <span class="inlinecode"><span class="id" type="var">f</span></span> from numbers to some type <span class="inlinecode"><span class="id" type="var">X</span></span>, a number
    <span class="inlinecode"><span class="id" type="var">k</span></span>, and a value <span class="inlinecode"><span class="id" type="var">x</span></span>, and constructs a function that behaves
    exactly like <span class="inlinecode"><span class="id" type="var">f</span></span> except that, when called with the argument <span class="inlinecode"><span class="id" type="var">k</span></span>,
    it returns <span class="inlinecode"><span class="id" type="var">x</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="override"><span class="id" type="definition">override</span></a> {<span class="id" type="var">X</span>: <span class="id" type="keyword">Type</span>} (<span class="id" type="var">f</span>: <span class="id" type="inductive">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">X</span>) (<span class="id" type="var">k</span>:<span class="id" type="inductive">nat</span>) (<span class="id" type="var">x</span>:<span class="id" type="var">X</span>) : <span class="id" type="inductive">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">X</span>:=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> (<span class="id" type="var">k'</span>:<span class="id" type="inductive">nat</span>) =&gt; <span class="id" type="keyword">if</span> <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">k</span> <span class="id" type="var">k'</span> <span class="id" type="keyword">then</span> <span class="id" type="var">x</span> <span class="id" type="keyword">else</span> <span class="id" type="var">f</span> <span class="id" type="var">k'</span>.<br/>

<br/>
</div>

<div class="doc">
For example, we can apply <span class="inlinecode"><span class="id" type="var">override</span></span> twice to obtain a
    function from numbers to booleans that returns <span class="inlinecode"><span class="id" type="var">false</span></span> on <span class="inlinecode">1</span> and
    <span class="inlinecode">3</span> and returns <span class="inlinecode"><span class="id" type="var">true</span></span> on all other arguments. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="fmostlytrue"><span class="id" type="definition">fmostlytrue</span></a> := <a class="idref" href="Poly.html#override"><span class="id" type="definition">override</span></a> (<a class="idref" href="Poly.html#override"><span class="id" type="definition">override</span></a> <a class="idref" href="Poly.html#ftrue"><span class="id" type="definition">ftrue</span></a> 1 <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>) 3 <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="override_example1"><span class="id" type="definition">override_example1</span></a> : <a class="idref" href="Poly.html#fmostlytrue"><span class="id" type="definition">fmostlytrue</span></a> 0 = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="override_example2"><span class="id" type="definition">override_example2</span></a> : <a class="idref" href="Poly.html#fmostlytrue"><span class="id" type="definition">fmostlytrue</span></a> 1 = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="override_example3"><span class="id" type="definition">override_example3</span></a> : <a class="idref" href="Poly.html#fmostlytrue"><span class="id" type="definition">fmostlytrue</span></a> 2 = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="override_example4"><span class="id" type="definition">override_example4</span></a> : <a class="idref" href="Poly.html#fmostlytrue"><span class="id" type="definition">fmostlytrue</span></a> 3 = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab111"></a><h4 class="section">Exercise: 1 star (override_example)</h4>
 Before starting to work on the following proof, make sure you
    understand exactly what the theorem is saying and can paraphrase
    it in your own words.  The proof itself is straightforward. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="override_example"><span class="id" type="lemma">override_example</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">b</span>:<a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a>), <br/>
&nbsp;&nbsp;(<a class="idref" href="Poly.html#override"><span class="id" type="definition">override</span></a> (<a class="idref" href="Poly.html#constfun"><span class="id" type="definition">constfun</span></a> <span class="id" type="var">b</span>) 3 <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>) 2 = <span class="id" type="var">b</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 We'll use function overriding heavily in parts of the rest of the
    course, and we will end up needing to know quite a bit about its
    properties.  To prove these properties, though, we need to know
    about a few more of Coq's tactics; developing these is the main
    topic of the rest of the chapter. 
<div class="paragraph"> </div>

<a name="lab112"></a><h1 class="section">More About Coq</h1>

<div class="paragraph"> </div>

<a name="lab113"></a><h2 class="section">The <span class="inlinecode"><span class="id" type="tactic">unfold</span></span> Tactic</h2>

<div class="paragraph"> </div>

 Sometimes, a proof will get stuck because Coq doesn't
    automatically expand a function call into its definition.  (This
    is a feature, not a bug: if Coq automatically expanded everything
    possible, our proof goals would quickly become enormous &mdash; hard to
    read and slow for Coq to manipulate!) 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="unfold_example_bad"><span class="id" type="lemma">unfold_example_bad</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;3 + <span class="id" type="var">n</span> = <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#plus3"><span class="id" type="definition">plus3</span></a> <span class="id" type="var">n</span> + 1 = <span class="id" type="var">m</span> + 1.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;At&nbsp;this&nbsp;point,&nbsp;we'd&nbsp;like&nbsp;to&nbsp;do&nbsp;<span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span>,&nbsp;since&nbsp;<span class="inlinecode"><span class="id" type="var">plus3</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>&nbsp;is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;definitionally&nbsp;equal&nbsp;to&nbsp;<span class="inlinecode">3</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span></span>.&nbsp;&nbsp;However,&nbsp;Coq&nbsp;doesn't<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;automatically&nbsp;expand&nbsp;<span class="inlinecode"><span class="id" type="var">plus3</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>&nbsp;to&nbsp;its&nbsp;definition.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="tactic">unfold</span></span> tactic can be used to explicitly replace a
    defined name by the right-hand side of its definition.  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="unfold_example"><span class="id" type="lemma">unfold_example</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;3 + <span class="id" type="var">n</span> = <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#plus3"><span class="id" type="definition">plus3</span></a> <span class="id" type="var">n</span> + 1 = <span class="id" type="var">m</span> + 1.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">plus3</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Now we can prove a first property of <span class="inlinecode"><span class="id" type="var">override</span></span>: If we
    override a function at some argument <span class="inlinecode"><span class="id" type="var">k</span></span> and then look up <span class="inlinecode"><span class="id" type="var">k</span></span>, we
    get back the overridden value. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="override_eq"><span class="id" type="lemma">override_eq</span></a> : <span style="font-family: arial;">&forall;</span> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} <span class="id" type="var">x</span> <span class="id" type="var">k</span> (<span class="id" type="var">f</span>:<span class="id" type="inductive">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;(<a class="idref" href="Poly.html#override"><span class="id" type="definition">override</span></a> <span class="id" type="var">f</span> <span class="id" type="var">k</span> <span class="id" type="var">x</span>) <span class="id" type="var">k</span> = <span class="id" type="var">x</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">X</span> <span class="id" type="var">x</span> <span class="id" type="var">k</span> <span class="id" type="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">override</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&larr;</span> <a class="idref" href="Basics.html#beq_nat_refl"><span class="id" type="axiom">beq_nat_refl</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
This proof was straightforward, but note that it requires
    <span class="inlinecode"><span class="id" type="tactic">unfold</span></span> to expand the definition of <span class="inlinecode"><span class="id" type="var">override</span></span>. 
<div class="paragraph"> </div>

<a name="lab114"></a><h4 class="section">Exercise: 2 stars (override_neq)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="override_neq"><span class="id" type="lemma">override_neq</span></a> : <span style="font-family: arial;">&forall;</span> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} <span class="id" type="var">x1</span> <span class="id" type="var">x2</span> <span class="id" type="var">k1</span> <span class="id" type="var">k2</span> (<span class="id" type="var">f</span> : <span class="id" type="inductive">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">f</span> <span class="id" type="var">k1</span> = <span class="id" type="var">x1</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">k2</span> <span class="id" type="var">k1</span> = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;(<a class="idref" href="Poly.html#override"><span class="id" type="definition">override</span></a> <span class="id" type="var">f</span> <span class="id" type="var">k2</span> <span class="id" type="var">x2</span>) <span class="id" type="var">k1</span> = <span class="id" type="var">x1</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 As the inverse of <span class="inlinecode"><span class="id" type="tactic">unfold</span></span>, Coq also provides a tactic
    <span class="inlinecode"><span class="id" type="var">fold</span></span>, which can be used to "unexpand" a definition.  It is used
    much less often. 
<div class="paragraph"> </div>

<a name="lab115"></a><h2 class="section">Inversion</h2>

<div class="paragraph"> </div>

 Recall the definition of natural numbers:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Inductive</span>&nbsp;<span class="id" type="var">nat</span>&nbsp;:&nbsp;<span class="id" type="keyword">Type</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">O</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">S</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">nat</span>.
<div class="paragraph"> </div>

</div>
    It is clear from this definition that every number has one of two
    forms: either it is the constructor <span class="inlinecode"><span class="id" type="var">O</span></span> or it is built by applying
    the constructor <span class="inlinecode"><span class="id" type="var">S</span></span> to another number.  But there is more here than
    meets the eye: implicit in the definition (and in our informal
    understanding of how datatype declarations work in other
    programming languages) are two other facts:

<div class="paragraph"> </div>

<ul class="doclist">
<li> The constructor <span class="inlinecode"><span class="id" type="var">S</span></span> is <i>injective</i>.  That is, the only way we can
      have <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> is if <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>.

<div class="paragraph"> </div>


</li>
<li> The constructors <span class="inlinecode"><span class="id" type="var">O</span></span> and <span class="inlinecode"><span class="id" type="var">S</span></span> are <i>disjoint</i>.  That is, <span class="inlinecode"><span class="id" type="var">O</span></span> is not
      equal to <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> for any <span class="inlinecode"><span class="id" type="var">n</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 Similar principles apply to all inductively defined types: all
    constructors are injective, and the values built from distinct
    constructors are never equal.  For lists, the <span class="inlinecode"><span class="id" type="var">cons</span></span> constructor is
    injective and <span class="inlinecode"><span class="id" type="var">nil</span></span> is different from every non-empty list.  For
    booleans, <span class="inlinecode"><span class="id" type="var">true</span></span> and <span class="inlinecode"><span class="id" type="var">false</span></span> are unequal.  (Since neither <span class="inlinecode"><span class="id" type="var">true</span></span>
    nor <span class="inlinecode"><span class="id" type="var">false</span></span> take any arguments, their injectivity is not an issue.) 
<div class="paragraph"> </div>

 Coq provides a tactic, called <span class="inlinecode"><span class="id" type="tactic">inversion</span></span>, that allows us to
    exploit these principles in making proofs.

<div class="paragraph"> </div>

    The <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> tactic is used like this.  Suppose <span class="inlinecode"><span class="id" type="var">H</span></span> is a
    hypothesis in the context (or a previously proven lemma) of the
    form

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">c</span>&nbsp;<span class="id" type="var">a1</span>&nbsp;<span class="id" type="var">a2</span>&nbsp;... <span class="id" type="var">an</span>&nbsp;=&nbsp;<span class="id" type="var">d</span>&nbsp;<span class="id" type="var">b1</span>&nbsp;<span class="id" type="var">b2</span>&nbsp;... <span class="id" type="var">bm</span>
<div class="paragraph"> </div>

</div>
    for some constructors <span class="inlinecode"><span class="id" type="var">c</span></span> and <span class="inlinecode"><span class="id" type="var">d</span></span> and arguments <span class="inlinecode"><span class="id" type="var">a1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" type="var">an</span></span> and
    <span class="inlinecode"><span class="id" type="var">b1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" type="var">bm</span></span>.

<div class="paragraph"> </div>

    Then <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> instructs Coq to "invert" this equality to
    extract the information it contains about these terms:

<div class="paragraph"> </div>

<ul class="doclist">
<li> If <span class="inlinecode"><span class="id" type="var">c</span></span> and <span class="inlinecode"><span class="id" type="var">d</span></span> are the same constructor, then we know, by the
      injectivity of this constructor, that <span class="inlinecode"><span class="id" type="var">a1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">b1</span></span>, <span class="inlinecode"><span class="id" type="var">a2</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">b2</span></span>,
      etc.; <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> adds these facts to the context, and tries
      to use them to rewrite the goal.

<div class="paragraph"> </div>


</li>
<li> If <span class="inlinecode"><span class="id" type="var">c</span></span> and <span class="inlinecode"><span class="id" type="var">d</span></span> are different constructors, then the hypothesis
      <span class="inlinecode"><span class="id" type="var">H</span></span> is contradictory.  That is, a false assumption has crept
      into the context, and this means that any goal whatsoever is
      provable!  In this case, <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> marks the current goal as
      completed and pops it off the goal stack. 
</li>
</ul>

<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> tactic is probably easier to understand by
    seeing it in action than from general descriptions like the above.
    Below you will find example theorems that demonstrate the use of
    <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> and exercises to test your understanding. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="eq_add_S"><span class="id" type="lemma">eq_add_S</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="constructor">S</span> <span class="id" type="var">n</span> = <span class="id" type="constructor">S</span> <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="silly4"><span class="id" type="lemma">silly4</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">n</span>] = [<span class="id" type="var">m</span>] <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
As a convenience, the <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> tactic can also
    destruct equalities between complex values, binding
    multiple variables as it goes. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="silly5"><span class="id" type="lemma">silly5</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">n</span>,<span class="id" type="var">m</span>] = [<span class="id" type="var">o</span>,<span class="id" type="var">o</span>] <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">n</span>] = [<span class="id" type="var">m</span>].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab116"></a><h4 class="section">Exercise: 1 star (sillyex1)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Example</span> <a name="sillyex1"><span class="id" type="definition">sillyex1</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span> : <span class="id" type="var">X</span>) (<span class="id" type="var">l</span> <span class="id" type="var">j</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">x</span> :: <span class="id" type="var">y</span> :: <span class="id" type="var">l</span> = <span class="id" type="var">z</span> :: <span class="id" type="var">j</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">y</span> :: <span class="id" type="var">l</span> = <span class="id" type="var">x</span> :: <span class="id" type="var">j</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">x</span> = <span class="id" type="var">y</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="silly6"><span class="id" type="lemma">silly6</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">n</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="constructor">S</span> <span class="id" type="var">n</span> = <span class="id" type="constructor">O</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 + 2 = 5.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">contra</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">contra</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="silly7"><span class="id" type="lemma">silly7</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">n</span>] = [<span class="id" type="var">m</span>].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">contra</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">contra</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab117"></a><h4 class="section">Exercise: 1 star (sillyex2)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Example</span> <a name="sillyex2"><span class="id" type="definition">sillyex2</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span> : <span class="id" type="var">X</span>) (<span class="id" type="var">l</span> <span class="id" type="var">j</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">x</span> :: <span class="id" type="var">y</span> :: <span class="id" type="var">l</span> = [] <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">y</span> :: <span class="id" type="var">l</span> = <span class="id" type="var">z</span> :: <span class="id" type="var">j</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">x</span> = <span class="id" type="var">z</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 While the injectivity of constructors allows us to reason
    <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode">(<span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span>),</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>, the reverse direction of
    the implication, provable by standard equational reasoning, is a
    useful fact to record for cases we will see several times. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="eq_remove_S"><span class="id" type="lemma">eq_remove_S</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="constructor">S</span> <span class="id" type="var">n</span> = <span class="id" type="constructor">S</span> <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Here is a more realistic use of inversion to prove a
    property that is useful in many places later on... 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="beq_nat_eq"><span class="id" type="lemma">beq_nat_eq</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> = <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> = <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = 0".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">m</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">m</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">m'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "m = 0". <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "m = S m'". <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">contra</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">contra</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = S n'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">m</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">m</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">m'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "m = 0". <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">contra</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">contra</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "m = S m'". <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Poly.html#eq_remove_S"><span class="id" type="lemma">eq_remove_S</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHn'</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab118"></a><h4 class="section">Exercise: 2 stars (beq_nat_eq_informal)</h4>
 Give an informal proof of <span class="inlinecode"><span class="id" type="var">beq_nat_eq</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab119"></a><h4 class="section">Exercise: 3 stars (beq_nat_eq')</h4>
 We can also prove beq_nat_eq by induction on <span class="inlinecode"><span class="id" type="var">m</span></span>, though we have
    to be a little careful about which order we introduce the
    variables, so that we get a general enough induction hypothesis &mdash;
    this is done for you below.  Finish the following proof.  To get
    maximum benefit from the exercise, try first to do it without
    looking back at the one above. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="beq_nat_eq'"><span class="id" type="lemma">beq_nat_eq'</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">m</span> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> = <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">m</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">m</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">m'</span>].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Here's another illustration of <span class="inlinecode"><span class="id" type="tactic">inversion</span></span>.  This is a slightly
    roundabout way of stating a fact that we have already proved
    above.  The extra equalities force us to do a little more
    equational reasoning and exercise some of the tactics we've seen
    recently. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="length_snoc'"><span class="id" type="lemma">length_snoc'</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">v</span> : <span class="id" type="var">X</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) (<span class="id" type="var">n</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> <span class="id" type="var">l</span> = <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> (<a class="idref" href="Poly.html#snoc"><span class="id" type="definition">snoc</span></a> <span class="id" type="var">l</span> <span class="id" type="var">v</span>) = <span class="id" type="constructor">S</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">X</span> <span class="id" type="var">v</span> <span class="id" type="var">l</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">v'</span> <span class="id" type="var">l'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "l = []". <span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&larr;</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "l = v' :: l'". <span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "n = 0". <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "n = S n'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Poly.html#eq_remove_S"><span class="id" type="lemma">eq_remove_S</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHl'</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab120"></a><h3 class="section">Practice Session</h3>

<div class="paragraph"> </div>

<a name="lab121"></a><h4 class="section">Exercise: 2 stars, optional (practice)</h4>
 Some nontrivial but not-too-complicated proofs to work together in
    class, and some for you to work as exercises.  Some of the
    exercises may involve applying lemmas from earlier lectures or
    homeworks. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="beq_nat_0_l"><span class="id" type="lemma">beq_nat_0_l</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> = <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> 0 <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> 0 = <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="beq_nat_0_r"><span class="id" type="lemma">beq_nat_0_r</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> = <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> 0 <span style="font-family: arial;">&rarr;</span> 0 = <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="double_injective"><span class="id" type="lemma">double_injective</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basics.html#double"><span class="id" type="definition">double</span></a> <span class="id" type="var">n</span> = <a class="idref" href="Basics.html#double"><span class="id" type="definition">double</span></a> <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = 0". <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">m</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">m</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">m'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "m = 0". <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "m = S m'". <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = S n'". <span class="id" type="tactic">intros</span> <span class="id" type="var">m</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">m</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">m'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "m = 0". <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "m = S m'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Poly.html#eq_remove_S"><span class="id" type="lemma">eq_remove_S</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHn'</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab122"></a><h2 class="section">Using Tactics on Hypotheses</h2>

<div class="paragraph"> </div>

 By default, most tactics work on the goal formula and leave
    the context unchanged.  However, most tactics also have a variant
    that performs a similar operation on a statement in the context.

<div class="paragraph"> </div>

    For example, the tactic <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> performs simplification in
    the hypothesis named <span class="inlinecode"><span class="id" type="var">H</span></span> in the context. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="S_inj"><span class="id" type="lemma">S_inj</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="inductive">nat</span>) (<span class="id" type="var">b</span> : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>) (<span class="id" type="constructor">S</span> <span class="id" type="var">m</span>) = <span class="id" type="var">b</span>  <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">m</span> = <span class="id" type="var">b</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">b</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Similarly, the tactic <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">L</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> matches some
    conditional statement <span class="inlinecode"><span class="id" type="var">L</span></span> (of the form <span class="inlinecode"><span class="id" type="var">L1</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">L2</span></span>, say) against a
    hypothesis <span class="inlinecode"><span class="id" type="var">H</span></span> in the context.  However, unlike ordinary
    <span class="inlinecode"><span class="id" type="tactic">apply</span></span> (which rewrites a goal matching <span class="inlinecode"><span class="id" type="var">L2</span></span> into a subgoal <span class="inlinecode"><span class="id" type="var">L1</span></span>),
    <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">L</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> matches <span class="inlinecode"><span class="id" type="var">H</span></span> against <span class="inlinecode"><span class="id" type="var">L1</span></span> and, if successful,
    replaces it with <span class="inlinecode"><span class="id" type="var">L2</span></span>.

<div class="paragraph"> </div>

    In other words, <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">L</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> gives us a form of "forward
    reasoning" &mdash; from <span class="inlinecode"><span class="id" type="var">L1</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">L2</span></span> and a hypothesis matching <span class="inlinecode"><span class="id" type="var">L1</span></span>, it
    gives us a hypothesis matching <span class="inlinecode"><span class="id" type="var">L2</span></span>.  By contrast, <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">L</span></span> is
    "backward reasoning" &mdash; it says that if we know <span class="inlinecode"><span class="id" type="var">L1</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">L2</span></span> and we
    are trying to prove <span class="inlinecode"><span class="id" type="var">L2</span></span>, it suffices to prove <span class="inlinecode"><span class="id" type="var">L1</span></span>.  

<div class="paragraph"> </div>

    Here is a variant of a proof from above, using forward reasoning
    throughout instead of backward reasoning. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="silly3'"><span class="id" type="lemma">silly3'</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">n</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;(<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> 5 = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> (<span class="id" type="constructor">S</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>)) 7 = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> = <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> 5  <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> = <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> (<span class="id" type="constructor">S</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>)) 7.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">eq</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">symmetry</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">eq</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">symmetry</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Forward reasoning starts from what is <i>given</i> (premises,
    previously proven theorems) and iteratively draws conclusions from
    them until the goal is reached.  Backward reasoning starts from
    the <i>goal</i>, and iteratively reasons about what would imply the
    goal, until premises or previously proven theorems are reached.
    If you've seen informal proofs before (for example, in a math or
    computer science class), they probably used forward reasoning.  In
    general, Coq tends to favor backward reasoning, but in some
    situations the forward style can be easier to use or to think
    about.  
<div class="paragraph"> </div>

<a name="lab123"></a><h4 class="section">Exercise: 3 stars, recommended (plus_n_n_injective)</h4>
 You can practice using the "in" variants in this exercise. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="plus_n_n_injective"><span class="id" type="lemma">plus_n_n_injective</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> + <span class="id" type="var">n</span> = <span class="id" type="var">m</span> + <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Hint:&nbsp;use&nbsp;the&nbsp;plus_n_Sm&nbsp;lemma&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab124"></a><h2 class="section">Using <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> on Compound Expressions</h2>

<div class="paragraph"> </div>

 We have seen many examples where the <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> tactic is
    used to perform case analysis of the value of some variable.  But
    sometimes we need to reason by cases on the result of some
    <i>expression</i>.  We can also do this with <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>.

<div class="paragraph"> </div>

    Here are some examples: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="sillyfun"><span class="id" type="definition">sillyfun</span></a> (<span class="id" type="var">n</span> : <span class="id" type="inductive">nat</span>) : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">if</span> <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> 3 <span class="id" type="keyword">then</span> <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a><br/>
&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="keyword">if</span> <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> 5 <span class="id" type="keyword">then</span> <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a><br/>
&nbsp;&nbsp;<span class="id" type="keyword">else</span> <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="sillyfun_false"><span class="id" type="lemma">sillyfun_false</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">n</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#sillyfun"><span class="id" type="definition">sillyfun</span></a> <span class="id" type="var">n</span> = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">unfold</span> <span class="id" type="var">sillyfun</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> 3).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "beq_nat n 3 = true". <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "beq_nat n 3 = false". <span class="id" type="tactic">destruct</span> (<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> 5).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "beq_nat n 5 = true". <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "beq_nat n 5 = false". <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
After unfolding <span class="inlinecode"><span class="id" type="var">sillyfun</span></span> in the above proof, we find that
    we are stuck on <span class="inlinecode"><span class="id" type="keyword">if</span></span> <span class="inlinecode">(<span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">3)</span> <span class="inlinecode"><span class="id" type="keyword">then</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" type="keyword">else</span></span> <span class="inlinecode">...</span>.  Well,
    either <span class="inlinecode"><span class="id" type="var">n</span></span> is equal to <span class="inlinecode">3</span> or it isn't, so we use <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>
    <span class="inlinecode">(<span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">3)</span> to let us reason about the two cases. 
<div class="paragraph"> </div>

<a name="lab125"></a><h4 class="section">Exercise: 1 star (override_shadow)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="override_shadow"><span class="id" type="lemma">override_shadow</span></a> : <span style="font-family: arial;">&forall;</span> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} <span class="id" type="var">x1</span> <span class="id" type="var">x2</span> <span class="id" type="var">k1</span> <span class="id" type="var">k2</span> (<span class="id" type="var">f</span> : <span class="id" type="inductive">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;(<a class="idref" href="Poly.html#override"><span class="id" type="definition">override</span></a> (<a class="idref" href="Poly.html#override"><span class="id" type="definition">override</span></a> <span class="id" type="var">f</span> <span class="id" type="var">k1</span> <span class="id" type="var">x2</span>) <span class="id" type="var">k1</span> <span class="id" type="var">x1</span>) <span class="id" type="var">k2</span> = (<a class="idref" href="Poly.html#override"><span class="id" type="definition">override</span></a> <span class="id" type="var">f</span> <span class="id" type="var">k1</span> <span class="id" type="var">x1</span>) <span class="id" type="var">k2</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab126"></a><h4 class="section">Exercise: 3 stars, recommended (combine_split)</h4>

</div>
<div class="code code-space">
<span class="comment">(*&nbsp;<br/>
Theorem&nbsp;combine_split&nbsp;:&nbsp;forall&nbsp;X&nbsp;Y&nbsp;(l&nbsp;:&nbsp;list&nbsp;(X&nbsp;*&nbsp;Y))&nbsp;l1&nbsp;l2,<br/>
&nbsp;&nbsp;split&nbsp;l&nbsp;=&nbsp;(l1,&nbsp;l2)&nbsp;-&gt;<br/>
&nbsp;&nbsp;combine&nbsp;l1&nbsp;l2&nbsp;=&nbsp;l.<br/>
Proof.<br/>
&nbsp;&nbsp;intros&nbsp;X&nbsp;Y&nbsp;l.&nbsp;induction&nbsp;l&nbsp;as&nbsp;<span class="inlinecode">|</span> <span class="inlinecode">[<span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">y</span>]</span> <span class="inlinecode"><span class="id" type="var">l'</span></span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span>&nbsp;Admitted.<br/>
*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab127"></a><h4 class="section">Exercise: 3 stars, optional (split_combine)</h4>
 Thought exercise: We have just proven that for all lists of pairs,
    <span class="inlinecode"><span class="id" type="var">combine</span></span> is the inverse of <span class="inlinecode"><span class="id" type="tactic">split</span></span>.  How would you state the
    theorem showing that <span class="inlinecode"><span class="id" type="tactic">split</span></span> is the inverse of <span class="inlinecode"><span class="id" type="var">combine</span></span>?

<div class="paragraph"> </div>

    Hint: what property do you need of <span class="inlinecode"><span class="id" type="var">l1</span></span> and <span class="inlinecode"><span class="id" type="var">l2</span></span> for <span class="inlinecode"><span class="id" type="tactic">split</span></span>
    <span class="inlinecode"><span class="id" type="var">combine</span></span> <span class="inlinecode"><span class="id" type="var">l1</span></span> <span class="inlinecode"><span class="id" type="var">l2</span></span> <span class="inlinecode">=</span> <span class="inlinecode">(<span class="id" type="var">l1</span>,<span class="id" type="var">l2</span>)</span> to be true?

<div class="paragraph"> </div>

    State this theorem in Coq, and prove it. (Be sure to leave your
    induction hypothesis general by not doing <span class="inlinecode"><span class="id" type="tactic">intros</span></span> on more things
    than necessary.) 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab128"></a><h2 class="section">The <span class="inlinecode"><span class="id" type="var">remember</span></span> Tactic</h2>

<div class="paragraph"> </div>

 (Note: the <span class="inlinecode"><span class="id" type="var">remember</span></span> tactic is not strictly needed until a
    bit later, so if necessary this section can be skipped and
    returned to when needed.) 
<div class="paragraph"> </div>

 We have seen how the <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> tactic can be used to
    perform case analysis of the results of arbitrary computations.
    If <span class="inlinecode"><span class="id" type="var">e</span></span> is an expression whose type is some inductively defined
    type <span class="inlinecode"><span class="id" type="var">T</span></span>, then, for each constructor <span class="inlinecode"><span class="id" type="var">c</span></span> of <span class="inlinecode"><span class="id" type="var">T</span></span>, <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">e</span></span>
    generates a subgoal in which all occurrences of <span class="inlinecode"><span class="id" type="var">e</span></span> (in the goal
    and in the context) are replaced by <span class="inlinecode"><span class="id" type="var">c</span></span>.

<div class="paragraph"> </div>

    Sometimes, however, this substitution process loses information
    that we need in order to complete the proof.  For example, suppose
    we define a function <span class="inlinecode"><span class="id" type="var">sillyfun1</span></span> like this: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="sillyfun1"><span class="id" type="definition">sillyfun1</span></a> (<span class="id" type="var">n</span> : <span class="id" type="inductive">nat</span>) : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">if</span> <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> 3 <span class="id" type="keyword">then</span> <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a><br/>
&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="keyword">if</span> <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> 5 <span class="id" type="keyword">then</span> <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a><br/>
&nbsp;&nbsp;<span class="id" type="keyword">else</span> <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>

<br/>
</div>

<div class="doc">
And suppose that we want to convince Coq of the rather
    obvious observation that <span class="inlinecode"><span class="id" type="var">sillyfun1</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> yields <span class="inlinecode"><span class="id" type="var">true</span></span> only when <span class="inlinecode"><span class="id" type="var">n</span></span>
    is odd.  By analogy with the proofs we did with <span class="inlinecode"><span class="id" type="var">sillyfun</span></span> above,
    it is natural to start the proof like this: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="sillyfun1_odd_FAILED"><span class="id" type="lemma">sillyfun1_odd_FAILED</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">n</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Poly.html#sillyfun1"><span class="id" type="definition">sillyfun1</span></a> <span class="id" type="var">n</span> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basics.html#oddb"><span class="id" type="definition">oddb</span></a> <span class="id" type="var">n</span> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">unfold</span> <span class="id" type="var">sillyfun1</span> <span class="id" type="keyword">in</span> <span class="id" type="var">eq</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> 3).<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;stuck...&nbsp;*)</span><br/>
<span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
We get stuck at this point because the context does not
    contain enough information to prove the goal!  The problem is that
    the substitution peformed by <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> is too brutal &mdash; it threw
    away every occurrence of <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">3</span>, but we need to keep at
    least one of these because we need to be able to reason that
    since, in this branch of the case analysis, <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">3</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span>,
    it must be that <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">3</span>, from which it follows that <span class="inlinecode"><span class="id" type="var">n</span></span> is odd.

<div class="paragraph"> </div>

    What we would really like is not to use <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> directly on
    <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">3</span> and substitute away all occurrences of this
    expression, but rather to use <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> on something else that is
    <i>equal</i> to <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">3</span>.  For example, if we had a variable that
    we knew was equal to <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">3</span>, we could <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> this
    variable instead.

<div class="paragraph"> </div>

    The <span class="inlinecode"><span class="id" type="var">remember</span></span> tactic allows us to introduce such a variable. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="sillyfun1_odd"><span class="id" type="lemma">sillyfun1_odd</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">n</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Poly.html#sillyfun1"><span class="id" type="definition">sillyfun1</span></a> <span class="id" type="var">n</span> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basics.html#oddb"><span class="id" type="definition">oddb</span></a> <span class="id" type="var">n</span> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">unfold</span> <span class="id" type="var">sillyfun1</span> <span class="id" type="keyword">in</span> <span class="id" type="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">remember</span> (<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> 3) <span class="id" type="keyword">as</span> <span class="id" type="var">e3</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;At&nbsp;this&nbsp;point,&nbsp;the&nbsp;context&nbsp;has&nbsp;been&nbsp;enriched&nbsp;with&nbsp;a&nbsp;new<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variable&nbsp;<span class="inlinecode"><span class="id" type="var">e3</span></span>&nbsp;and&nbsp;an&nbsp;assumption&nbsp;that&nbsp;<span class="inlinecode"><span class="id" type="var">e3</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Now&nbsp;if&nbsp;we&nbsp;do&nbsp;<span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">e3</span></span>...&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">e3</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;...&nbsp;the&nbsp;variable&nbsp;<span class="inlinecode"><span class="id" type="var">e3</span></span>&nbsp;gets&nbsp;substituted&nbsp;away&nbsp;(it<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disappears&nbsp;completely)&nbsp;and&nbsp;we&nbsp;are&nbsp;left&nbsp;with&nbsp;the&nbsp;same<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state&nbsp;as&nbsp;at&nbsp;the&nbsp;point&nbsp;where&nbsp;we&nbsp;got&nbsp;stuck&nbsp;above,&nbsp;except<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that&nbsp;the&nbsp;context&nbsp;still&nbsp;contains&nbsp;the&nbsp;extra&nbsp;equality<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption&nbsp;--&nbsp;now&nbsp;with&nbsp;<span class="inlinecode"><span class="id" type="var">true</span></span>&nbsp;substituted&nbsp;for&nbsp;<span class="inlinecode"><span class="id" type="var">e3</span></span>&nbsp;--<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which&nbsp;is&nbsp;exactly&nbsp;what&nbsp;we&nbsp;need&nbsp;to&nbsp;make&nbsp;progress.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "e3 = true". <span class="id" type="tactic">apply</span> <a class="idref" href="Poly.html#beq_nat_eq"><span class="id" type="lemma">beq_nat_eq</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">Heqe3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Heqe3</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "e3 = false".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;When&nbsp;we&nbsp;come&nbsp;to&nbsp;the&nbsp;second&nbsp;equality&nbsp;test&nbsp;in&nbsp;the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body&nbsp;of&nbsp;the&nbsp;function&nbsp;we&nbsp;are&nbsp;reasoning&nbsp;about,&nbsp;we&nbsp;can<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;<span class="inlinecode"><span class="id" type="var">remember</span></span>&nbsp;again&nbsp;in&nbsp;the&nbsp;same&nbsp;way,&nbsp;allowing&nbsp;us<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;finish&nbsp;the&nbsp;proof.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">remember</span> (<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> 5) <span class="id" type="keyword">as</span> <span class="id" type="var">e5</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">e5</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "e5 = true".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Poly.html#beq_nat_eq"><span class="id" type="lemma">beq_nat_eq</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">Heqe5</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Heqe5</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "e5 = false". <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab129"></a><h4 class="section">Exercise: 2 stars (override_same)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="override_same"><span class="id" type="lemma">override_same</span></a> : <span style="font-family: arial;">&forall;</span> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} <span class="id" type="var">x1</span> <span class="id" type="var">k1</span> <span class="id" type="var">k2</span> (<span class="id" type="var">f</span> : <span class="id" type="inductive">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">f</span> <span class="id" type="var">k1</span> = <span class="id" type="var">x1</span> <span style="font-family: arial;">&rarr;</span> <br/>
&nbsp;&nbsp;(<a class="idref" href="Poly.html#override"><span class="id" type="definition">override</span></a> <span class="id" type="var">f</span> <span class="id" type="var">k1</span> <span class="id" type="var">x1</span>) <span class="id" type="var">k2</span> = <span class="id" type="var">f</span> <span class="id" type="var">k2</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab130"></a><h4 class="section">Exercise: 3 stars, optional (filter_exercise)</h4>
 This one is a bit challenging.  Be sure your initial <span class="inlinecode"><span class="id" type="tactic">intros</span></span> go
    only up through the parameter on which you want to do
    induction! 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="filter_exercise"><span class="id" type="lemma">filter_exercise</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">test</span> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">x</span> : <span class="id" type="var">X</span>) (<span class="id" type="var">l</span> <span class="id" type="var">lf</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Poly.html#filter"><span class="id" type="definition">filter</span></a> <span class="id" type="var">test</span> <span class="id" type="var">l</span> = <span class="id" type="var">x</span> :: <span class="id" type="var">lf</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">test</span> <span class="id" type="var">x</span> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab131"></a><h2 class="section">The <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode">...</span> Tactic</h2>

<div class="paragraph"> </div>

 The following silly example uses two rewrites in a row to
    get from <span class="inlinecode">[<span class="id" type="var">a</span>,<span class="id" type="var">b</span>]</span> to <span class="inlinecode">[<span class="id" type="var">e</span>,<span class="id" type="var">f</span>]</span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="trans_eq_example"><span class="id" type="definition">trans_eq_example</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">d</span> <span class="id" type="var">e</span> <span class="id" type="var">f</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">a</span>,<span class="id" type="var">b</span>] = [<span class="id" type="var">c</span>,<span class="id" type="var">d</span>] <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">c</span>,<span class="id" type="var">d</span>] = [<span class="id" type="var">e</span>,<span class="id" type="var">f</span>] <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">a</span>,<span class="id" type="var">b</span>] = [<span class="id" type="var">e</span>,<span class="id" type="var">f</span>].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">d</span> <span class="id" type="var">e</span> <span class="id" type="var">f</span> <span class="id" type="var">eq1</span> <span class="id" type="var">eq2</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">eq1</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">eq2</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Since this is a common pattern, we might
    abstract it out as a lemma recording once and for all
    the fact that equality is transitive. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="trans_eq"><span class="id" type="lemma">trans_eq</span></a> : <span style="font-family: arial;">&forall;</span> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} (<span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> : <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">m</span> = <span class="id" type="var">o</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> = <span class="id" type="var">o</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">X</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> <span class="id" type="var">eq1</span> <span class="id" type="var">eq2</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">eq1</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">eq2</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Now, we should be able to use <span class="inlinecode"><span class="id" type="var">trans_eq</span></span> to
    prove the above example.  However, to do this we need
    a slight refinement of the <span class="inlinecode"><span class="id" type="tactic">apply</span></span> tactic. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="trans_eq_example'"><span class="id" type="definition">trans_eq_example'</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">d</span> <span class="id" type="var">e</span> <span class="id" type="var">f</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">a</span>,<span class="id" type="var">b</span>] = [<span class="id" type="var">c</span>,<span class="id" type="var">d</span>] <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">c</span>,<span class="id" type="var">d</span>] = [<span class="id" type="var">e</span>,<span class="id" type="var">f</span>] <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">a</span>,<span class="id" type="var">b</span>] = [<span class="id" type="var">e</span>,<span class="id" type="var">f</span>].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">d</span> <span class="id" type="var">e</span> <span class="id" type="var">f</span> <span class="id" type="var">eq1</span> <span class="id" type="var">eq2</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;If&nbsp;we&nbsp;simply&nbsp;tell&nbsp;Coq&nbsp;<span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">trans_eq</span></span>&nbsp;at&nbsp;this&nbsp;point,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it&nbsp;can&nbsp;tell&nbsp;(by&nbsp;matching&nbsp;the&nbsp;goal&nbsp;against&nbsp;the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conclusion&nbsp;of&nbsp;the&nbsp;lemma)&nbsp;that&nbsp;it&nbsp;should&nbsp;instantiate&nbsp;<span class="inlinecode"><span class="id" type="var">X</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;<span class="inlinecode">[<span class="id" type="var">nat</span>]</span>,&nbsp;<span class="inlinecode"><span class="id" type="var">n</span></span>&nbsp;with&nbsp;<span class="inlinecode">[<span class="id" type="var">a</span>,<span class="id" type="var">b</span>]</span>,&nbsp;and&nbsp;<span class="inlinecode"><span class="id" type="var">o</span></span>&nbsp;with&nbsp;<span class="inlinecode">[<span class="id" type="var">e</span>,<span class="id" type="var">f</span>]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;However,&nbsp;the&nbsp;matching&nbsp;process&nbsp;doesn't&nbsp;determine&nbsp;an<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instantiation&nbsp;for&nbsp;<span class="inlinecode"><span class="id" type="var">m</span></span>:&nbsp;we&nbsp;have&nbsp;to&nbsp;supply&nbsp;one&nbsp;explicitly<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by&nbsp;adding&nbsp;<span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode">(<span class="id" type="var">m</span>:=[<span class="id" type="var">c</span>,<span class="id" type="var">d</span>])</span>&nbsp;to&nbsp;the&nbsp;invocation&nbsp;of<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="tactic">apply</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Poly.html#trans_eq"><span class="id" type="lemma">trans_eq</span></a> <span class="id" type="keyword">with</span> (<span class="id" type="var">m</span>:=[<span class="id" type="var">c</span>,<span class="id" type="var">d</span>]). <span class="id" type="tactic">apply</span> <span class="id" type="var">eq1</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">eq2</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
 Actually, we usually don't have to include the name <span class="inlinecode"><span class="id" type="var">m</span></span>
    in the <span class="inlinecode"><span class="id" type="keyword">with</span></span> clause; Coq is often smart enough to
    figure out which instantiation we're giving. We could
    instead write: apply trans_eq with <span class="inlinecode"><span class="id" type="var">c</span>,<span class="id" type="var">d</span></span>. 
<div class="paragraph"> </div>

<a name="lab132"></a><h4 class="section">Exercise: 3 stars, recommended (apply_exercises)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Example</span> <a name="trans_eq_exercise"><span class="id" type="definition">trans_eq_exercise</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> <span class="id" type="var">p</span> : <span class="id" type="inductive">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">m</span> = (<a class="idref" href="Basics.html#minustwo"><span class="id" type="definition">minustwo</span></a> <span class="id" type="var">o</span>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">n</span> + <span class="id" type="var">p</span>) = <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">n</span> + <span class="id" type="var">p</span>) = (<a class="idref" href="Basics.html#minustwo"><span class="id" type="definition">minustwo</span></a> <span class="id" type="var">o</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="beq_nat_trans"><span class="id" type="lemma">beq_nat_trans</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> = <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> = <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">m</span> <span class="id" type="var">p</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> = <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">p</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="override_permute"><span class="id" type="lemma">override_permute</span></a> : <span style="font-family: arial;">&forall;</span> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} <span class="id" type="var">x1</span> <span class="id" type="var">x2</span> <span class="id" type="var">k1</span> <span class="id" type="var">k2</span> <span class="id" type="var">k3</span> (<span class="id" type="var">f</span> : <span class="id" type="inductive">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a> = <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">k2</span> <span class="id" type="var">k1</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;(<a class="idref" href="Poly.html#override"><span class="id" type="definition">override</span></a> (<a class="idref" href="Poly.html#override"><span class="id" type="definition">override</span></a> <span class="id" type="var">f</span> <span class="id" type="var">k2</span> <span class="id" type="var">x2</span>) <span class="id" type="var">k1</span> <span class="id" type="var">x1</span>) <span class="id" type="var">k3</span> = (<a class="idref" href="Poly.html#override"><span class="id" type="definition">override</span></a> (<a class="idref" href="Poly.html#override"><span class="id" type="definition">override</span></a> <span class="id" type="var">f</span> <span class="id" type="var">k1</span> <span class="id" type="var">x1</span>) <span class="id" type="var">k2</span> <span class="id" type="var">x2</span>) <span class="id" type="var">k3</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab133"></a><h1 class="section">Review</h1>

<div class="paragraph"> </div>

 We've now seen a bunch of Coq's fundamental tactics &mdash; enough to
    do pretty much everything we'll want for a while.  We'll introduce
    one or two more as we go along through the next few lectures, and
    later in the course we'll introduce some more powerful
    <i>automation</i> tactics that make Coq do more of the low-level work
    in many cases.  But basically we've got what we need to get work
    done.

<div class="paragraph"> </div>

    Here are the ones we've seen:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="tactic">intros</span></span>: 
        move hypotheses/variables from goal to context 

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>:
        finish the proof (when the goal looks like <span class="inlinecode"><span class="id" type="var">e</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">e</span></span>)

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">apply</span></span>:
        prove goal using a hypothesis, lemma, or constructor

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">apply</span>...</span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span>: 
        apply a hypothesis, lemma, or constructor to a hypothesis in
        the context (forward reasoning)

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">apply</span>...</span> <span class="inlinecode"><span class="id" type="keyword">with</span>...</span>:
        explicitly specify values for variables that cannot be
        determined by pattern matching

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">simpl</span></span>:
        simplify computations in the goal 

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span>:
        ... or a hypothesis 

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>:
        use an equality hypothesis (or lemma) to rewrite the goal 

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span>:
        ... or a hypothesis 

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">unfold</span></span>:
        replace a defined constant by its right-hand side in the goal 

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">unfold</span>...</span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span>:
        ... or a hypothesis  

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">destruct</span>...</span> <span class="inlinecode"><span class="id" type="keyword">as</span>...</span>:
        case analysis on values of inductively defined types 

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">induction</span>...</span> <span class="inlinecode"><span class="id" type="keyword">as</span>...</span>:
        induction on values of inductively defined types 

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">inversion</span></span>:
        reason by injectivity and distinctness of constructors

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="var">remember</span></span> <span class="inlinecode">(<span class="id" type="var">e</span>)</span> <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>:
        give a name (<span class="inlinecode"><span class="id" type="var">x</span></span>) to an expression (<span class="inlinecode"><span class="id" type="var">e</span></span>) so that we can
        destruct <span class="inlinecode"><span class="id" type="var">x</span></span> without "losing" <span class="inlinecode"><span class="id" type="var">e</span></span>

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">assert</span></span> <span class="inlinecode">(<span class="id" type="var">e</span>)</span> <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span>:
        introduce a "local lemma" <span class="inlinecode"><span class="id" type="var">e</span></span> and call it <span class="inlinecode"><span class="id" type="var">H</span></span> 

</li>
</ul>

<div class="paragraph"> </div>

<a name="lab134"></a><h1 class="section">Additional Exercises</h1>

<div class="paragraph"> </div>

<a name="lab135"></a><h4 class="section">Exercise: 2 stars, optional (fold_length)</h4>
 Many common functions on lists can be implemented in terms of
   <span class="inlinecode"><span class="id" type="var">fold</span></span>.  For example, here is an alternate definition of <span class="inlinecode"><span class="id" type="var">length</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="fold_length"><span class="id" type="definition">fold_length</span></a> {<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) : <span class="id" type="inductive">nat</span> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#fold"><span class="id" type="definition">fold</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> <span class="id" type="var">n</span> =&gt; <span class="id" type="constructor">S</span> <span class="id" type="var">n</span>) <span class="id" type="var">l</span> 0.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="test_fold_length1"><span class="id" type="definition">test_fold_length1</span></a> : <a class="idref" href="Poly.html#fold_length"><span class="id" type="definition">fold_length</span></a> [4,7,0] = 3.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Prove the correctness of <span class="inlinecode"><span class="id" type="var">fold_length</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="fold_length_correct"><span class="id" type="lemma">fold_length_correct</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">X</span> (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#fold_length"><span class="id" type="definition">fold_length</span></a> <span class="id" type="var">l</span> = <a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> <span class="id" type="var">l</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab136"></a><h4 class="section">Exercise: 3 stars, recommended (fold_map)</h4>
 We can also define <span class="inlinecode"><span class="id" type="var">map</span></span> in terms of <span class="inlinecode"><span class="id" type="var">fold</span></span>.  Finish <span class="inlinecode"><span class="id" type="var">fold_map</span></span>
    below. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="fold_map"><span class="id" type="definition">fold_map</span></a> {<span class="id" type="var">X</span> <span class="id" type="var">Y</span>:<span class="id" type="keyword">Type</span>} (<span class="id" type="var">f</span> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Y</span>) (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">Y</span> :=<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
</div>

<div class="doc">
Write down a theorem in Coq stating that <span class="inlinecode"><span class="id" type="var">fold_map</span></span> is correct,
    and prove it. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Module</span> <a name="MumbleBaz"><span class="id" type="module">MumbleBaz</span></a>.<br/>
</div>

<div class="doc">
<a name="lab137"></a><h4 class="section">Exercise: 2 stars, optional (mumble_grumble)</h4>
 Consider the following two inductively defined types. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="MumbleBaz.mumble"><span class="id" type="inductive">mumble</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="MumbleBaz.a"><span class="id" type="constructor">a</span></a> : <a class="idref" href="Poly.html#mumble"><span class="id" type="inductive">mumble</span></a><br/>
&nbsp;&nbsp;| <a name="MumbleBaz.b"><span class="id" type="constructor">b</span></a> : <a class="idref" href="Poly.html#mumble"><span class="id" type="inductive">mumble</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Poly.html#mumble"><span class="id" type="inductive">mumble</span></a><br/>
&nbsp;&nbsp;| <a name="MumbleBaz.c"><span class="id" type="constructor">c</span></a> : <a class="idref" href="Poly.html#mumble"><span class="id" type="inductive">mumble</span></a>.<br/>
<span class="id" type="keyword">Inductive</span> <a name="MumbleBaz.grumble"><span class="id" type="inductive">grumble</span></a> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="MumbleBaz.d"><span class="id" type="constructor">d</span></a> : <a class="idref" href="Poly.html#MumbleBaz.mumble"><span class="id" type="inductive">mumble</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Poly.html#grumble"><span class="id" type="inductive">grumble</span></a> <span class="id" type="var">X</span><br/>
&nbsp;&nbsp;| <a name="MumbleBaz.e"><span class="id" type="constructor">e</span></a> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Poly.html#grumble"><span class="id" type="inductive">grumble</span></a> <span class="id" type="var">X</span>.<br/>

<br/>
</div>

<div class="doc">
Which of the following are well-typed elements of <span class="inlinecode"><span class="id" type="var">grumble</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> for
    some type <span class="inlinecode"><span class="id" type="var">X</span></span>?

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">d</span></span> <span class="inlinecode">(<span class="id" type="var">b</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">5)</span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">d</span></span> <span class="inlinecode"><span class="id" type="var">mumble</span></span> <span class="inlinecode">(<span class="id" type="var">b</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">5)</span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">d</span></span> <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">(<span class="id" type="var">b</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">5)</span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">e</span></span> <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode"><span class="id" type="var">true</span></span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">e</span></span> <span class="inlinecode"><span class="id" type="var">mumble</span></span> <span class="inlinecode">(<span class="id" type="var">b</span></span> <span class="inlinecode"><span class="id" type="var">c</span></span> <span class="inlinecode">0)</span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">e</span></span> <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">(<span class="id" type="var">b</span></span> <span class="inlinecode"><span class="id" type="var">c</span></span> <span class="inlinecode">0)</span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">c</span></span> 

</li>
</ul>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab138"></a><h4 class="section">Exercise: 2 stars, optional (baz_num_elts)</h4>
 Consider the following inductive definition: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="MumbleBaz.baz"><span class="id" type="inductive">baz</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;| <a name="MumbleBaz.x"><span class="id" type="constructor">x</span></a> : <a class="idref" href="Poly.html#baz"><span class="id" type="inductive">baz</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Poly.html#baz"><span class="id" type="inductive">baz</span></a><br/>
&nbsp;&nbsp;&nbsp;| <a name="MumbleBaz.y"><span class="id" type="constructor">y</span></a> : <a class="idref" href="Poly.html#baz"><span class="id" type="inductive">baz</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Poly.html#baz"><span class="id" type="inductive">baz</span></a>.<br/>

<br/>
</div>

<div class="doc">
How <i>many</i> elements does the type <span class="inlinecode"><span class="id" type="var">baz</span></span> have? 
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Poly.html#"><span class="id" type="module">MumbleBaz</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab139"></a><h4 class="section">Exercise: 4 stars, recommended (forall_exists_challenge)</h4>
 Challenge problem: Define two recursive <span class="inlinecode"><span class="id" type="var">Fixpoints</span></span>,
    <span class="inlinecode"><span class="id" type="var">forallb</span></span> and <span class="inlinecode"><span class="id" type="var">existsb</span></span>.  The first checks whether every
    element in a list satisfies a given predicate:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">forallb</span>&nbsp;<span class="id" type="var">oddb</span>&nbsp;[1,3,5,7,9]&nbsp;=&nbsp;<span class="id" type="var">true</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">forallb</span>&nbsp;<span class="id" type="var">negb</span>&nbsp;[<span class="id" type="var">false</span>,<span class="id" type="var">false</span>]&nbsp;=&nbsp;<span class="id" type="var">true</span><br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">forallb</span>&nbsp;<span class="id" type="var">evenb</span>&nbsp;[0,2,4,5]&nbsp;=&nbsp;<span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">forallb</span>&nbsp;(<span class="id" type="var">beq_nat</span>&nbsp;5)&nbsp;[]&nbsp;=&nbsp;<span class="id" type="var">true</span>
<div class="paragraph"> </div>

</div>
    The function <span class="inlinecode"><span class="id" type="var">existsb</span></span> checks whether there exists an element in
    the list that satisfies a given predicate:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">existsb</span>&nbsp;(<span class="id" type="var">beq_nat</span>&nbsp;5)&nbsp;[0,2,3,6]&nbsp;=&nbsp;<span class="id" type="var">false</span><br/>
&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">existsb</span>&nbsp;(<span class="id" type="var">andb</span>&nbsp;<span class="id" type="var">true</span>)&nbsp;[<span class="id" type="var">true</span>,<span class="id" type="var">true</span>,<span class="id" type="var">false</span>]&nbsp;=&nbsp;<span class="id" type="var">true</span><br/>
&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">existsb</span>&nbsp;<span class="id" type="var">oddb</span>&nbsp;[1,0,0,0,0,3]&nbsp;=&nbsp;<span class="id" type="var">true</span><br/>
&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">existsb</span>&nbsp;<span class="id" type="var">evenb</span>&nbsp;[]&nbsp;=&nbsp;<span class="id" type="var">false</span>
<div class="paragraph"> </div>

</div>
    Next, create a <i>nonrecursive</i> <span class="inlinecode"><span class="id" type="keyword">Definition</span></span>, <span class="inlinecode"><span class="id" type="var">existsb'</span></span>, using
    <span class="inlinecode"><span class="id" type="var">forallb</span></span> and <span class="inlinecode"><span class="id" type="var">negb</span></span>.

<div class="paragraph"> </div>

    Prove that <span class="inlinecode"><span class="id" type="var">existsb'</span></span> and <span class="inlinecode"><span class="id" type="var">existsb</span></span> have the same behavior.

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab140"></a><h4 class="section">Exercise: 2 stars, optional (index_informal)</h4>
 Recall the definition of the <span class="inlinecode"><span class="id" type="var">index</span></span> function:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Fixpoint</span>&nbsp;<span class="id" type="var">index</span>&nbsp;{<span class="id" type="var">X</span>&nbsp;:&nbsp;<span class="id" type="keyword">Type</span>}&nbsp;(<span class="id" type="var">n</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>)&nbsp;(<span class="id" type="var">l</span>&nbsp;:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">X</span>)&nbsp;:&nbsp;<span class="id" type="var">option</span>&nbsp;<span class="id" type="var">X</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span>&nbsp;<span class="id" type="var">l</span>&nbsp;<span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;[]&nbsp;=&gt;&nbsp;<span class="id" type="var">None</span>&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">a</span>&nbsp;::&nbsp;<span class="id" type="var">l'</span>&nbsp;=&gt;&nbsp;<span class="id" type="keyword">if</span>&nbsp;<span class="id" type="var">beq_nat</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">O</span>&nbsp;<span class="id" type="keyword">then</span>&nbsp;<span class="id" type="var">Some</span>&nbsp;<span class="id" type="var">a</span>&nbsp;<span class="id" type="keyword">else</span>&nbsp;<span class="id" type="var">index</span>&nbsp;(<span class="id" type="var">pred</span>&nbsp;<span class="id" type="var">n</span>)&nbsp;<span class="id" type="var">l'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.
<div class="paragraph"> </div>

</div>
   Write an informal proof of the following theorem:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">length</span>&nbsp;<span class="id" type="var">l</span>&nbsp;=&nbsp;<span class="id" type="var">n</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;@<span class="id" type="var">index</span>&nbsp;<span class="id" type="var">X</span>&nbsp;(<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">n</span>)&nbsp;<span class="id" type="var">l</span>&nbsp;=&nbsp;<span class="id" type="var">None</span>.
<div class="paragraph"> </div>

</div>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
 <font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://www.lix.polytechnique.fr/coq/">coqdoc</a>
</div>

</div>

</body>
</html>