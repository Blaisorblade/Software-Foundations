<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Prop: Propositions and Evidence</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Prop<span class="subtitle">Propositions and Evidence</span></h1>

<div class="code code-tight">
</div>

<div class="doc">

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;$Date:&nbsp;2011-06-27&nbsp;09:22:51&nbsp;-0400&nbsp;(Mon,&nbsp;27&nbsp;Jun&nbsp;2011)&nbsp;$&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
"<i>Algorithms are the computational content of proofs</i>." (Robert
    Harper) 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="Poly.html#"><span class="id" type="library">Poly</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab146"></a><h1 class="section">Programming with Propositions</h1>

<div class="paragraph"> </div>

 <i>Note to readers</i>: Some of the concepts in this chapter may
    seem quite abstract on a first encounter.  We've included a <i>lot</i>
    of exercises, most of which should be quite approachable even if
    you're still working on understanding the details of the text.
    Try to work as many of them as you can, especially the one-starred
    exercises. 
<div class="paragraph"> </div>

 So far, the only statements we have been able to state and
    prove have been in the form of <i>equalities</i>.  However, the
    language of mathematical statements and proofs is much richer than
    this!  In this chapter we will take a much closer and more
    fundamental look at the sorts of mathematical statements
    (<i>propositions</i>) we can make in Coq, and how we go about proving
    them by providing logical <i>evidence</i>. 
<div class="paragraph"> </div>

 A <i>proposition</i> is a statement expressing a factual claim,
    like "two plus two equals four."  In Coq, propositions are written
    as expressions of type <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>.  Although we haven't mentioned it
    explicitly, we have already seen numerous examples. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> (2 + 2 = 4).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;2&nbsp;+&nbsp;2&nbsp;=&nbsp;4&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Check</span> (<a class="idref" href="Basics.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> 3 2 = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;ble_nat&nbsp;3&nbsp;2&nbsp;=&nbsp;false&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Both provable and unprovable claims are perfectly good
    propositions.  Simply <i>being</i> a proposition is one thing; being
    <i>provable</i> is something else! 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> (2 + 2 = 5).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;2&nbsp;+&nbsp;2&nbsp;=&nbsp;5&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Both <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">4</span> and <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">5</span> are legal expressions
    of type <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>. 
<div class="paragraph"> </div>

 We've seen one way that propositions can be used in Coq: in
    <span class="inlinecode"><span class="id" type="keyword">Theorem</span></span> (and <span class="inlinecode"><span class="id" type="keyword">Lemma</span></span> and <span class="inlinecode"><span class="id" type="keyword">Example</span></span>) declarations. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="plus_2_2_is_4"><span class="id" type="lemma">plus_2_2_is_4</span></a> : <br/>
&nbsp;&nbsp;2 + 2 = 4.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
But they can be used in many other ways.  For example, we
    can give a name to a proposition using a <span class="inlinecode"><span class="id" type="keyword">Definition</span></span>, just as we
    have given names to expressions of other sorts (numbers,
    functions, types, type functions, ...). 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="plus_fact"><span class="id" type="definition">plus_fact</span></a> : <span class="id" type="keyword">Prop</span>  :=  2 + 2 = 4.<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Prop.html#plus_fact"><span class="id" type="definition">plus_fact</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;plus_fact&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Now we can use this name in any situation where a proposition is
    expected &mdash; for example, as the claim in a <span class="inlinecode"><span class="id" type="keyword">Theorem</span></span>
    declaration. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="plus_fact_is_true"><span class="id" type="lemma">plus_fact_is_true</span></a> : <br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#plus_fact"><span class="id" type="definition">plus_fact</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
So far, all the propositions we have seen are equality
    propositions.  We can also form new propositions out of old
    ones.  For example, given propositions <span class="inlinecode"><span class="id" type="var">P</span></span> and <span class="inlinecode"><span class="id" type="var">Q</span></span>, we can form
    the proposition "<span class="inlinecode"><span class="id" type="var">P</span></span> implies <span class="inlinecode"><span class="id" type="var">Q</span></span>." 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="strange_prop1"><span class="id" type="definition">strange_prop1</span></a> : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;(2 + 2 = 5) <span style="font-family: arial;">&rarr;</span> (99 + 26 = 42).<br/>

<br/>
</div>

<div class="doc">
Also, given a proposition <span class="inlinecode"><span class="id" type="var">P</span></span> with a free variable <span class="inlinecode"><span class="id" type="var">n</span></span>, we can
    form the proposition <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">n</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="strange_prop2"><span class="id" type="definition">strange_prop2</span></a> :=<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>, (<a class="idref" href="Basics.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> <span class="id" type="var">n</span> 17 = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>) <span style="font-family: arial;">&rarr;</span> (<a class="idref" href="Basics.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> <span class="id" type="var">n</span> 99 = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>).<br/>

<br/>
</div>

<div class="doc">
Finally, we can define <i>parameterized propositions</i>.  For
    example, what does it mean to claim that "a number n is even"?  We
    have written a function that tests evenness, so one possible
    definition of what it means to be even is "<span class="inlinecode"><span class="id" type="var">n</span></span> is even iff <span class="inlinecode"><span class="id" type="var">evenb</span></span>
    <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span>." 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="even"><span class="id" type="definition">even</span></a> (<span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>) : <span class="id" type="keyword">Prop</span> := <br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#evenb"><span class="id" type="definition">evenb</span></a> <span class="id" type="var">n</span> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>

<br/>
</div>

<div class="doc">
This defines <span class="inlinecode"><span class="id" type="var">even</span></span> as a <i>function</i> that, when applied to a number
    <span class="inlinecode"><span class="id" type="var">n</span></span>, <i>yields a proposition</i> asserting that <span class="inlinecode"><span class="id" type="var">n</span></span> is even.  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Prop.html#even"><span class="id" type="definition">even</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;even&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop&nbsp;*)</span><br/>
<span class="id" type="keyword">Check</span> (<a class="idref" href="Prop.html#even"><span class="id" type="definition">even</span></a> 4).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;even&nbsp;4&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>
<span class="id" type="keyword">Check</span> (<a class="idref" href="Prop.html#even"><span class="id" type="definition">even</span></a> 3).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;even&nbsp;3&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
The type of <span class="inlinecode"><span class="id" type="var">even</span></span>, <span class="inlinecode"><span class="id" type="var">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="keyword">Prop</span></span>, can be pronounced in three
    ways: (1) "<span class="inlinecode"><span class="id" type="var">even</span></span> is a <i>function</i> from numbers to
    propositions," (2) "<span class="inlinecode"><span class="id" type="var">even</span></span> is a <i>family</i> of propositions, indexed
    by a number <span class="inlinecode"><span class="id" type="var">n</span></span>," or (3) "<span class="inlinecode"><span class="id" type="var">even</span></span> is a <i>property</i> of numbers."  
<div class="paragraph"> </div>

 Propositions &mdash; including parameterized propositions &mdash; are
    first-class citizens in Coq.  We can use them in other
    definitions: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="even_n__even_SSn"><span class="id" type="definition">even_n__even_SSn</span></a> (<span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>) : <span class="id" type="keyword">Prop</span> := <br/>
&nbsp;&nbsp;(<a class="idref" href="Prop.html#even"><span class="id" type="definition">even</span></a> <span class="id" type="var">n</span>) <span style="font-family: arial;">&rarr;</span> (<a class="idref" href="Prop.html#even"><span class="id" type="definition">even</span></a> (<span class="id" type="constructor">S</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>))).<br/>

<br/>
</div>

<div class="doc">
We can define them to take multiple arguments... 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="between"><span class="id" type="definition">between</span></a> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span>: <span class="id" type="inductive">nat</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#andb"><span class="id" type="definition">andb</span></a> (<a class="idref" href="Basics.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">o</span>) (<a class="idref" href="Basics.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> <span class="id" type="var">o</span> <span class="id" type="var">m</span>) = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>

<br/>
</div>

<div class="doc">
... and then partially apply them: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="teen"><span class="id" type="definition">teen</span></a> : <span class="id" type="inductive">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="keyword">Prop</span> := <a class="idref" href="Prop.html#between"><span class="id" type="definition">between</span></a> 13 19.<br/>

<br/>
</div>

<div class="doc">
We can even pass propositions &mdash; including parameterized
    propositions &mdash; as arguments to functions: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="true_for_zero"><span class="id" type="definition">true_for_zero</span></a> (<span class="id" type="var">P</span>:<span class="id" type="inductive">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="keyword">Prop</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> 0.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="true_for_n__true_for_Sn"><span class="id" type="definition">true_for_n__true_for_Sn</span></a> (<span class="id" type="var">P</span>:<span class="id" type="inductive">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="keyword">Prop</span>) (<span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>).<br/>

<br/>
</div>

<div class="doc">
(Names of the form <span class="inlinecode"><span class="id" type="var">x__y</span></span>, with two underscores in a row, can be
    read "<span class="inlinecode"><span class="id" type="var">x</span></span> implies <span class="inlinecode"><span class="id" type="var">y</span></span>.") 
<div class="paragraph"> </div>

 Here are two more examples of passing parameterized
    propositions as arguments to a function.  The first makes the
    claim that a whenever a proposition <span class="inlinecode"><span class="id" type="var">P</span></span> is true for some natural
    number <span class="inlinecode"><span class="id" type="var">n'</span></span>, it is also true by the successor of <span class="inlinecode"><span class="id" type="var">n'</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="preserved_by_S"><span class="id" type="definition">preserved_by_S</span></a> (<span class="id" type="var">P</span>:<span class="id" type="inductive">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="keyword">Prop</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span> <span class="id" type="var">n'</span>, <span class="id" type="var">P</span> <span class="id" type="var">n'</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n'</span>).<br/>

<br/>
</div>

<div class="doc">
And this one simply claims that a proposition is true for
    all natural numbers: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="true_for_all_numbers"><span class="id" type="definition">true_for_all_numbers</span></a> (<span class="id" type="var">P</span>:<span class="id" type="inductive">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="keyword">Prop</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>, <span class="id" type="var">P</span> <span class="id" type="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
We can put these pieces together to manually restate the
    principle of induction for natural numbers.  Given a parameterized
    proposition <span class="inlinecode"><span class="id" type="var">P</span></span>, if <span class="inlinecode"><span class="id" type="var">P</span></span> is true for <span class="inlinecode">0</span>, and <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span> is true
    whenever <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> is, then <span class="inlinecode"><span class="id" type="var">P</span></span> is true for all natural numbers. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="our_nat_induction"><span class="id" type="definition">our_nat_induction</span></a> (<span class="id" type="var">P</span>:<span class="id" type="inductive">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="keyword">Prop</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Prop.html#true_for_zero"><span class="id" type="definition">true_for_zero</span></a> <span class="id" type="var">P</span>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Prop.html#preserved_by_S"><span class="id" type="definition">preserved_by_S</span></a> <span class="id" type="var">P</span>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Prop.html#true_for_all_numbers"><span class="id" type="definition">true_for_all_numbers</span></a> <span class="id" type="var">P</span>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab147"></a><h1 class="section">Evidence</h1>

<div class="paragraph"> </div>

 We've seen that well-formed expressions of type <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> can
    embody both provable and unprovable propositions.  Naturally,
    we're particularly interested in the provable ones.  When <span class="inlinecode"><span class="id" type="var">P</span></span> is a
    proposition and <span class="inlinecode"><span class="id" type="var">e</span></span> is a proof of <span class="inlinecode"><span class="id" type="var">P</span></span> &mdash; i.e., <span class="inlinecode"><span class="id" type="var">e</span></span> is evidence
    that <span class="inlinecode"><span class="id" type="var">P</span></span> is true &mdash; we'll write "<span class="inlinecode"><span class="id" type="var">e</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span></span>."  This overloading of
    the "has type" or "inhabits" notation is not accidental: we'll see
    that there is a fundamental and fruitful analogy between data
    values inhabiting types and evidence "inhabiting" propositions. 
<div class="paragraph"> </div>

 The next question is "what are proofs?" &mdash; i.e., what sorts of
    things would we be willing to accept as evidence that particular
    propositions are true? 
<div class="paragraph"> </div>

<a name="lab148"></a><h2 class="section">Inductively Defined Propositions</h2>

<div class="paragraph"> </div>

 The answer, of course, depends on the form of the
    proposition &mdash; evidence for implication propositions (<span class="inlinecode"><span class="id" type="var">P</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">Q</span></span>) is
    different from evidence for conjunctions (<span class="inlinecode"><span class="id" type="var">P</span><span style="font-family: arial;">&and;</span><span class="id" type="var">Q</span></span>), etc.  In this
    chapter and the next, we'll address a number of specific cases.

<div class="paragraph"> </div>

    To begin with, consider <i>atomic</i> propositions &mdash; ones that aren't
    built into the logic we're using, but are rather introduced to
    model useful concepts in a particular domain.  For example, having
    defined a type <span class="inlinecode"><span class="id" type="var">day</span></span> as we did in Basics.v, we might have some
    concept in our minds about certain days, say the fact that
    <span class="inlinecode"><span class="id" type="var">saturday</span></span> and <span class="inlinecode"><span class="id" type="var">sunday</span></span> are "good" ones.  If we want to use Coq to
    state and prove theorems involving good days, we need to begin by
    telling it what we mean by "good" &mdash; that is, we need to specify
    what counts as as evidence that some day <span class="inlinecode"><span class="id" type="var">d</span></span> is good (namely, that
    <span class="inlinecode"><span class="id" type="var">d</span></span> is either <span class="inlinecode"><span class="id" type="var">saturday</span></span> or <span class="inlinecode"><span class="id" type="var">sunday</span></span>.  The following declaration
    achieves this: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="good_day"><span class="id" type="inductive">good_day</span></a> : <a class="idref" href="Basics.html#day"><span class="id" type="inductive">day</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="gd_sat"><span class="id" type="constructor">gd_sat</span></a> : <a class="idref" href="Prop.html#good_day"><span class="id" type="inductive">good_day</span></a> <a class="idref" href="Basics.html#saturday"><span class="id" type="constructor">saturday</span></a><br/>
&nbsp;&nbsp;| <a name="gd_sun"><span class="id" type="constructor">gd_sun</span></a> : <a class="idref" href="Prop.html#good_day"><span class="id" type="inductive">good_day</span></a> <a class="idref" href="Basics.html#sunday"><span class="id" type="constructor">sunday</span></a>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> keyword means exactly the same thing whether
    we are using it to define sets of data values (in the <span class="inlinecode"><span class="id" type="keyword">Type</span></span>
    world) or sets of evidence (in the <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> world).  Consider the
    parts of the definition above:

<div class="paragraph"> </div>

<ul class="doclist">
<li> The first line declares that <span class="inlinecode"><span class="id" type="var">good_day</span></span> is a proposition indexed
      by a day.

<div class="paragraph"> </div>


</li>
<li> The second line declares that the constructor <span class="inlinecode"><span class="id" type="var">gd_sat</span></span> can be
      taken as evidence for the assertion <span class="inlinecode"><span class="id" type="var">good_day</span></span> <span class="inlinecode"><span class="id" type="var">saturday</span></span>.

<div class="paragraph"> </div>


</li>
<li> The third line declares that the constructor <span class="inlinecode"><span class="id" type="var">gd_sun</span></span> can be
      taken as evidence for the assertion <span class="inlinecode"><span class="id" type="var">good_day</span></span> <span class="inlinecode"><span class="id" type="var">sunday</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 That is, we're <i>defining</i> what we mean by days being good by
    saying "Saturday is good, sunday is good, and that's all."  Then
    someone can <i>prove</i> that Sunday is good simply by observing that
    we said it was when we defined what <span class="inlinecode"><span class="id" type="var">good_day</span></span> meant. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="gds"><span class="id" type="lemma">gds</span></a> : <a class="idref" href="Prop.html#good_day"><span class="id" type="inductive">good_day</span></a> <a class="idref" href="Basics.html#sunday"><span class="id" type="constructor">sunday</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#gd_sun"><span class="id" type="constructor">gd_sun</span></a>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The constructor <span class="inlinecode"><span class="id" type="var">gd_sun</span></span> is "primitive evidence" &mdash; an <i>axiom</i> &mdash;
    justifying the claim that Sunday is good. 
<div class="paragraph"> </div>

 Similarly, we can define a proposition <span class="inlinecode"><span class="id" type="var">day_before</span></span>
    parameterized by <i>two</i> days, together with axioms stating that
    Monday comes before Tuesday, Tuesday before Wednesday, and so
    on. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="day_before"><span class="id" type="inductive">day_before</span></a> : <a class="idref" href="Basics.html#day"><span class="id" type="inductive">day</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Basics.html#day"><span class="id" type="inductive">day</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> := <br/>
&nbsp;&nbsp;| <a name="db_tue"><span class="id" type="constructor">db_tue</span></a> : <a class="idref" href="Prop.html#day_before"><span class="id" type="inductive">day_before</span></a> <a class="idref" href="Basics.html#tuesday"><span class="id" type="constructor">tuesday</span></a> <a class="idref" href="Basics.html#monday"><span class="id" type="constructor">monday</span></a><br/>
&nbsp;&nbsp;| <a name="db_wed"><span class="id" type="constructor">db_wed</span></a> : <a class="idref" href="Prop.html#day_before"><span class="id" type="inductive">day_before</span></a> <a class="idref" href="Basics.html#wednesday"><span class="id" type="constructor">wednesday</span></a> <a class="idref" href="Basics.html#tuesday"><span class="id" type="constructor">tuesday</span></a><br/>
&nbsp;&nbsp;| <a name="db_thu"><span class="id" type="constructor">db_thu</span></a> : <a class="idref" href="Prop.html#day_before"><span class="id" type="inductive">day_before</span></a> <a class="idref" href="Basics.html#thursday"><span class="id" type="constructor">thursday</span></a> <a class="idref" href="Basics.html#wednesday"><span class="id" type="constructor">wednesday</span></a><br/>
&nbsp;&nbsp;| <a name="db_fri"><span class="id" type="constructor">db_fri</span></a> : <a class="idref" href="Prop.html#day_before"><span class="id" type="inductive">day_before</span></a> <a class="idref" href="Basics.html#friday"><span class="id" type="constructor">friday</span></a> <a class="idref" href="Basics.html#thursday"><span class="id" type="constructor">thursday</span></a><br/>
&nbsp;&nbsp;| <a name="db_sat"><span class="id" type="constructor">db_sat</span></a> : <a class="idref" href="Prop.html#day_before"><span class="id" type="inductive">day_before</span></a> <a class="idref" href="Basics.html#saturday"><span class="id" type="constructor">saturday</span></a> <a class="idref" href="Basics.html#friday"><span class="id" type="constructor">friday</span></a><br/>
&nbsp;&nbsp;| <a name="db_sun"><span class="id" type="constructor">db_sun</span></a> : <a class="idref" href="Prop.html#day_before"><span class="id" type="inductive">day_before</span></a> <a class="idref" href="Basics.html#sunday"><span class="id" type="constructor">sunday</span></a> <a class="idref" href="Basics.html#saturday"><span class="id" type="constructor">saturday</span></a><br/>
&nbsp;&nbsp;| <a name="db_mon"><span class="id" type="constructor">db_mon</span></a> : <a class="idref" href="Prop.html#day_before"><span class="id" type="inductive">day_before</span></a> <a class="idref" href="Basics.html#monday"><span class="id" type="constructor">monday</span></a> <a class="idref" href="Basics.html#sunday"><span class="id" type="constructor">sunday</span></a>.<br/>

<br/>
</div>

<div class="doc">
The axioms that we introduce along with an inductively
    defined proposition can also involve universal quantifiers.  For
    example, it is well known that <i>every</i> day is a fine day for
    singing a song: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="fine_day_for_singing"><span class="id" type="inductive">fine_day_for_singing</span></a> : <a class="idref" href="Basics.html#day"><span class="id" type="inductive">day</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> := <br/>
&nbsp;&nbsp;| <a name="fdfs_any"><span class="id" type="constructor">fdfs_any</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">d</span>:<a class="idref" href="Basics.html#day"><span class="id" type="inductive">day</span></a>, <a class="idref" href="Prop.html#fine_day_for_singing"><span class="id" type="inductive">fine_day_for_singing</span></a> <span class="id" type="var">d</span>.<br/>

<br/>
</div>

<div class="doc">
The line above declares that, if <span class="inlinecode"><span class="id" type="var">d</span></span> is a day, then <span class="inlinecode"><span class="id" type="var">fdfs_any</span></span> <span class="inlinecode"><span class="id" type="var">d</span></span>
    can be taken as evidence for <span class="inlinecode"><span class="id" type="var">fine_day_for_singing</span></span> <span class="inlinecode"><span class="id" type="var">d</span></span>.  That is,
    we can construct evidence that <span class="inlinecode"><span class="id" type="var">d</span></span> is a <span class="inlinecode"><span class="id" type="var">fine_day_for_singing</span></span>
    by applying the constructor <span class="inlinecode"><span class="id" type="var">fdfs_any</span></span> to <span class="inlinecode"><span class="id" type="var">d</span></span>.

<div class="paragraph"> </div>

    In particular, Wednesday is a fine day for singing. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="fdfs_wed"><span class="id" type="lemma">fdfs_wed</span></a> : <a class="idref" href="Prop.html#fine_day_for_singing"><span class="id" type="inductive">fine_day_for_singing</span></a> <a class="idref" href="Basics.html#wednesday"><span class="id" type="constructor">wednesday</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#fdfs_any"><span class="id" type="constructor">fdfs_any</span></a>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
As always, the first line here can be read "I'm about to
    show you some evidence for the proposition <span class="inlinecode"><span class="id" type="var">fine_day_for_singing</span></span>
    <span class="inlinecode"><span class="id" type="var">wednesday</span></span>, and I want to introduce the name <span class="inlinecode"><span class="id" type="var">fdfs_wed</span></span> to refer
    to that evidence later on."  The second line then instructs Coq
    how to assemble the evidence. 
<div class="paragraph"> </div>

<a name="lab149"></a><h2 class="section">Proof Objects</h2>

<div class="paragraph"> </div>

 There's another &mdash; more primitive &mdash; way to accomplish the
    same thing: we can use a <span class="inlinecode"><span class="id" type="keyword">Definition</span></span> whose left-hand side is the
    name we're introducing and whose right-hand side is the evidence
    <i>itself</i>, rather than a script for how to build it.  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="fdfs_wed'"><span class="id" type="definition">fdfs_wed'</span></a> : <a class="idref" href="Prop.html#fine_day_for_singing"><span class="id" type="inductive">fine_day_for_singing</span></a> <a class="idref" href="Basics.html#wednesday"><span class="id" type="constructor">wednesday</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#fdfs_any"><span class="id" type="constructor">fdfs_any</span></a> <a class="idref" href="Basics.html#wednesday"><span class="id" type="constructor">wednesday</span></a>.<br/>

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Prop.html#fdfs_wed"><span class="id" type="lemma">fdfs_wed</span></a>.<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Prop.html#fdfs_wed'"><span class="id" type="definition">fdfs_wed'</span></a>.<br/>

<br/>
</div>

<div class="doc">
The expression <span class="inlinecode"><span class="id" type="var">fdfs_any</span></span> <span class="inlinecode"><span class="id" type="var">wednesday</span></span> can be thought of as
    instantiating the parameterized axiom <span class="inlinecode"><span class="id" type="var">fdfs_any</span></span> with the specific
    argument <span class="inlinecode"><span class="id" type="var">wednesday</span></span>.  Alternatively, we can think of <span class="inlinecode"><span class="id" type="var">fdfs_any</span></span>
    as a primitive "evidence constructor" that, when applied to a
    particular day, stands as evidence that that day is a fine day for
    singing; its type, <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">d</span>:<span class="id" type="var">day</span>,</span> <span class="inlinecode"><span class="id" type="var">fine_day_for_singing</span></span> <span class="inlinecode"><span class="id" type="var">d</span></span>,
    expresses this functionality, in the same way that the polymorphic
    type <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">X</span>,</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> in the previous chapter expressed the fact
    that the constructor <span class="inlinecode"><span class="id" type="var">nil</span></span> can be thought of as a function from
    types to empty lists with elements of that type. 
<div class="paragraph"> </div>

 Let's take a slightly more interesting example.  Let's say
    that a day of the week is "ok" if either (1) it is a good day or
    else (2) it falls the day before an ok day. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="ok_day"><span class="id" type="inductive">ok_day</span></a> : <a class="idref" href="Basics.html#day"><span class="id" type="inductive">day</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> := <br/>
&nbsp;&nbsp;| <a name="okd_gd"><span class="id" type="constructor">okd_gd</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">d</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Prop.html#good_day"><span class="id" type="inductive">good_day</span></a> <span class="id" type="var">d</span> <span style="font-family: arial;">&rarr;</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Prop.html#ok_day"><span class="id" type="inductive">ok_day</span></a> <span class="id" type="var">d</span> <br/>
&nbsp;&nbsp;| <a name="okd_before"><span class="id" type="constructor">okd_before</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">d1</span> <span class="id" type="var">d2</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Prop.html#ok_day"><span class="id" type="inductive">ok_day</span></a> <span class="id" type="var">d2</span> <span style="font-family: arial;">&rarr;</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Prop.html#day_before"><span class="id" type="inductive">day_before</span></a> <span class="id" type="var">d2</span> <span class="id" type="var">d1</span> <span style="font-family: arial;">&rarr;</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Prop.html#ok_day"><span class="id" type="inductive">ok_day</span></a> <span class="id" type="var">d1</span>.<br/>

<br/>
</div>

<div class="doc">
The first constructor can be read "One way to show that <span class="inlinecode"><span class="id" type="var">d</span></span>
    is an ok day is to present evidence that <span class="inlinecode"><span class="id" type="var">d</span></span> is good."  The second
    can be read, "Another way to show that a day <span class="inlinecode"><span class="id" type="var">d1</span></span> is ok is to
    present evidence that it is the day before some other day <span class="inlinecode"><span class="id" type="var">d2</span></span>
    together with evidence that <span class="inlinecode"><span class="id" type="var">d2</span></span> is ok." 
<div class="paragraph"> </div>

 Now suppose that we want to prove that <span class="inlinecode"><span class="id" type="var">wednesday</span></span> is ok.
    There are two ways to do it.  First, we have the primitive way,
    where we simply write down an expression that has the right
    type &mdash; a big nested application of constructors: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="okdw"><span class="id" type="definition">okdw</span></a> : <a class="idref" href="Prop.html#ok_day"><span class="id" type="inductive">ok_day</span></a> <a class="idref" href="Basics.html#wednesday"><span class="id" type="constructor">wednesday</span></a> := <br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#okd_before"><span class="id" type="constructor">okd_before</span></a> <a class="idref" href="Basics.html#wednesday"><span class="id" type="constructor">wednesday</span></a> <a class="idref" href="Basics.html#thursday"><span class="id" type="constructor">thursday</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Prop.html#okd_before"><span class="id" type="constructor">okd_before</span></a> <a class="idref" href="Basics.html#thursday"><span class="id" type="constructor">thursday</span></a> <a class="idref" href="Basics.html#friday"><span class="id" type="constructor">friday</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Prop.html#okd_before"><span class="id" type="constructor">okd_before</span></a> <a class="idref" href="Basics.html#friday"><span class="id" type="constructor">friday</span></a> <a class="idref" href="Basics.html#saturday"><span class="id" type="constructor">saturday</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Prop.html#okd_gd"><span class="id" type="constructor">okd_gd</span></a> <a class="idref" href="Basics.html#saturday"><span class="id" type="constructor">saturday</span></a> <a class="idref" href="Prop.html#gd_sat"><span class="id" type="constructor">gd_sat</span></a>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Prop.html#db_sat"><span class="id" type="constructor">db_sat</span></a>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Prop.html#db_fri"><span class="id" type="constructor">db_fri</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Prop.html#db_thu"><span class="id" type="constructor">db_thu</span></a>.<br/>

<br/>
</div>

<div class="doc">
Second, we have the machine-assisted way, where we go into <span class="inlinecode"><span class="id" type="keyword">Proof</span></span>
    mode and Coq guides us through a series of goals and subgoals
    until it is finally satisfied: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="okdw'"><span class="id" type="lemma">okdw'</span></a> : <a class="idref" href="Prop.html#ok_day"><span class="id" type="inductive">ok_day</span></a> <a class="idref" href="Basics.html#wednesday"><span class="id" type="constructor">wednesday</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;wednesday&nbsp;is&nbsp;OK&nbsp;because&nbsp;it's&nbsp;the&nbsp;day&nbsp;before&nbsp;an&nbsp;OK&nbsp;day&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#okd_before"><span class="id" type="constructor">okd_before</span></a> <span class="id" type="keyword">with</span> (<span class="id" type="var">d2</span>:=<a class="idref" href="Basics.html#thursday"><span class="id" type="constructor">thursday</span></a>).<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;"subgoal:&nbsp;show&nbsp;that&nbsp;thursday&nbsp;is&nbsp;ok".&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;thursday&nbsp;is&nbsp;OK&nbsp;because&nbsp;it's&nbsp;the&nbsp;day&nbsp;before&nbsp;an&nbsp;OK&nbsp;day&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#okd_before"><span class="id" type="constructor">okd_before</span></a> <span class="id" type="keyword">with</span> (<span class="id" type="var">d2</span>:=<a class="idref" href="Basics.html#friday"><span class="id" type="constructor">friday</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;"subgoal:&nbsp;show&nbsp;that&nbsp;friday&nbsp;is&nbsp;ok".&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;friday&nbsp;is&nbsp;OK&nbsp;because&nbsp;it's&nbsp;the&nbsp;day&nbsp;before&nbsp;an&nbsp;OK&nbsp;day&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#okd_before"><span class="id" type="constructor">okd_before</span></a> <span class="id" type="keyword">with</span> (<span class="id" type="var">d2</span>:=<a class="idref" href="Basics.html#saturday"><span class="id" type="constructor">saturday</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;"subgoal:&nbsp;show&nbsp;that&nbsp;saturday&nbsp;is&nbsp;ok".&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;saturday&nbsp;is&nbsp;OK&nbsp;because&nbsp;it's&nbsp;good!&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#okd_gd"><span class="id" type="constructor">okd_gd</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#gd_sat"><span class="id" type="constructor">gd_sat</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;"subgoal:&nbsp;show&nbsp;that&nbsp;the&nbsp;day&nbsp;before&nbsp;saturday&nbsp;is&nbsp;friday".&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#db_sat"><span class="id" type="constructor">db_sat</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;"subgoal:&nbsp;show&nbsp;that&nbsp;the&nbsp;day&nbsp;before&nbsp;friday&nbsp;is&nbsp;thursday".&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#db_fri"><span class="id" type="constructor">db_fri</span></a>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;"subgoal:&nbsp;show&nbsp;that&nbsp;the&nbsp;day&nbsp;before&nbsp;thursday&nbsp;is&nbsp;wednesday".&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#db_thu"><span class="id" type="constructor">db_thu</span></a>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Fundamentally, though, these two ways of making proofs are the
    same, in the sense that what Coq is actually doing when it's
    following the commands in a <span class="inlinecode"><span class="id" type="keyword">Proof</span></span> script is <i>literally</i>
    attempting to construct an expression with the desired type. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">okdw'</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;okdw'&nbsp;=&nbsp;okd_before&nbsp;wednesday&nbsp;thursday<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(okd_before&nbsp;thursday&nbsp;friday<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(okd_before&nbsp;friday&nbsp;saturday&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(okd_gd&nbsp;saturday&nbsp;gd_sat)&nbsp;db_sat)&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db_fri)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db_thu<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;ok_day&nbsp;wednesday&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
These expressions are often called <i>proof objects</i>. 
<div class="paragraph"> </div>

 Proof objects are the bedrock of Coq.  Tactic proofs are
    essentially <i>programs</i> that instruct Coq how to construct proof
    objects for us instead of our writing them out explicitly.  Here,
    of course, the proof object is actually shorter than the tactic
    proof.  But the proof objects for more interesting proofs can
    become quite large and complex &mdash; building them by hand would be
    painful.  Moreover, we'll see later on in the course that Coq has
    a number of automation tactics that can construct quite complex
    proof objects without our needing to specify every step. 
<div class="paragraph"> </div>

<a name="lab150"></a><h2 class="section">The Curry-Howard Correspondence</h2>

<div class="paragraph"> </div>

 The analogy 
<pre>
                 propositions  ~  sets / types
                 proofs        ~  data values 
</pre>
    is called the <i>Curry-Howard correspondence</i> (or <i>Curry-Howard
    isomorphism</i>).  Many wonderful things follow from it. 
<div class="paragraph"> </div>

 Just as a set can be empty, a singleton, finite, or infinite &mdash; it
    can have zero, one, or many inhabitants &mdash; a proposition may be
    inhabited by zero, one, many, or infinitely many proofs.  Each
    inhabitant of a proposition <span class="inlinecode"><span class="id" type="var">P</span></span> is a different way of giving
    evidence for <span class="inlinecode"><span class="id" type="var">P</span></span>.  If there are none, then <span class="inlinecode"><span class="id" type="var">P</span></span> is not provable.
    If there are many, then <span class="inlinecode"><span class="id" type="var">P</span></span> has many different proofs. 
<div class="paragraph"> </div>

<a name="lab151"></a><h2 class="section">Implication</h2>

<div class="paragraph"> </div>

 We've seen that the <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> operator (implication) builds bigger
    propositions from smaller ones.  What constitutes evidence for
    propositions built in this way?  Consider this statement: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="okd_before2"><span class="id" type="definition">okd_before2</span></a> := <span style="font-family: arial;">&forall;</span> <span class="id" type="var">d1</span> <span class="id" type="var">d2</span> <span class="id" type="var">d3</span>, <br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#ok_day"><span class="id" type="inductive">ok_day</span></a> <span class="id" type="var">d3</span> <span style="font-family: arial;">&rarr;</span> <br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#day_before"><span class="id" type="inductive">day_before</span></a> <span class="id" type="var">d2</span> <span class="id" type="var">d1</span> <span style="font-family: arial;">&rarr;</span> <br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#day_before"><span class="id" type="inductive">day_before</span></a> <span class="id" type="var">d3</span> <span class="id" type="var">d2</span> <span style="font-family: arial;">&rarr;</span> <br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#ok_day"><span class="id" type="inductive">ok_day</span></a> <span class="id" type="var">d1</span>.<br/>

<br/>
</div>

<div class="doc">
In English: if we have three days, <span class="inlinecode"><span class="id" type="var">d1</span></span> which is before <span class="inlinecode"><span class="id" type="var">d2</span></span>
    which is before <span class="inlinecode"><span class="id" type="var">d3</span></span>, and if we know <span class="inlinecode"><span class="id" type="var">d3</span></span> is ok, then so is
    <span class="inlinecode"><span class="id" type="var">d1</span></span>. 

<div class="paragraph"> </div>

    It should be easy to see how we'd construct a tactic proof of
    <span class="inlinecode"><span class="id" type="var">okd_before2</span></span>... 
<div class="paragraph"> </div>

<a name="lab152"></a><h4 class="section">Exercise: 1 star, optional (okd_before2_valid)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="okd_before2_valid"><span class="id" type="lemma">okd_before2_valid</span></a> : <a class="idref" href="Prop.html#okd_before2"><span class="id" type="definition">okd_before2</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 But what should the corresponding proof object look like? 

<div class="paragraph"> </div>

    Answer: We've made a notational pun between <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> as implication
    and <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> as the type of functions.  If we take this pun seriously,
    then what we're looking for is an expression with <i>type</i> <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span>
    <span class="inlinecode"><span class="id" type="var">d1</span></span> <span class="inlinecode"><span class="id" type="var">d2</span></span> <span class="inlinecode"><span class="id" type="var">d3</span>,</span> <span class="inlinecode"><span class="id" type="var">ok_day</span></span> <span class="inlinecode"><span class="id" type="var">d3</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">day_before</span></span> <span class="inlinecode"><span class="id" type="var">d2</span></span> <span class="inlinecode"><span class="id" type="var">d1</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">day_before</span></span> <span class="inlinecode"><span class="id" type="var">d3</span></span> <span class="inlinecode"><span class="id" type="var">d2</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span>
    <span class="inlinecode"><span class="id" type="var">ok_day</span></span> <span class="inlinecode"><span class="id" type="var">d1</span></span>, and so what we want is a <i>function</i> that takes six
    arguments (three days and three pieces of evidence) and returns a
    piece of evidence!  Here it is: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="okd_before2_valid'"><span class="id" type="definition">okd_before2_valid'</span></a> : <a class="idref" href="Prop.html#okd_before2"><span class="id" type="definition">okd_before2</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> (<span class="id" type="var">d1</span> <span class="id" type="var">d2</span> <span class="id" type="var">d3</span> : <a class="idref" href="Basics.html#day"><span class="id" type="inductive">day</span></a>) =&gt; <br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> (<span class="id" type="var">H</span> : <a class="idref" href="Prop.html#ok_day"><span class="id" type="inductive">ok_day</span></a> <span class="id" type="var">d3</span>) =&gt; <br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> (<span class="id" type="var">H0</span> : <a class="idref" href="Prop.html#day_before"><span class="id" type="inductive">day_before</span></a> <span class="id" type="var">d2</span> <span class="id" type="var">d1</span>) =&gt;<br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> (<span class="id" type="var">H1</span> : <a class="idref" href="Prop.html#day_before"><span class="id" type="inductive">day_before</span></a> <span class="id" type="var">d3</span> <span class="id" type="var">d2</span>) =&gt;<br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#okd_before"><span class="id" type="constructor">okd_before</span></a> <span class="id" type="var">d1</span> <span class="id" type="var">d2</span> (<a class="idref" href="Prop.html#okd_before"><span class="id" type="constructor">okd_before</span></a> <span class="id" type="var">d2</span> <span class="id" type="var">d3</span> <span class="id" type="var">H</span> <span class="id" type="var">H1</span>) <span class="id" type="var">H0</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab153"></a><h4 class="section">Exercise: 1 star, optional (okd_before2_valid_defn)</h4>
 Predict what Coq will print in response to this: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">okd_before2_valid</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab154"></a><h2 class="section">Induction Principles for Inductively Defined Types</h2>

<div class="paragraph"> </div>

 Every time we declare a new <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> datatype, Coq
    automatically generates an axiom that embodies an <i>induction
    principle</i> for this type.

<div class="paragraph"> </div>

    The induction principle for a type <span class="inlinecode"><span class="id" type="var">t</span></span> is called <span class="inlinecode"><span class="id" type="var">t_ind</span></span>.  Here is
    the one for natural numbers: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="definition">nat_ind</span>.<br/>
<span class="comment">(*&nbsp;&nbsp;===&gt;&nbsp;nat_ind&nbsp;:&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;0&nbsp;&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;n))&nbsp;&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Note that this is exactly the <span class="inlinecode"><span class="id" type="var">our_nat_induction</span></span> property from
    above. 
<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" type="tactic">induction</span></span> tactic is a straightforward wrapper that, at
    its core, simply performs <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">t_ind</span></span>.  To see this more
    clearly, let's experiment a little with using <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">nat_ind</span></span>
    directly, instead of the <span class="inlinecode"><span class="id" type="tactic">induction</span></span> tactic, to carry out some
    proofs.  Here, for example, is an alternate proof of a theorem
    that we saw in the <span class="inlinecode"><span class="id" type="var">Basics</span></span> chapter. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="mult_0_r'"><span class="id" type="lemma">mult_0_r'</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> * 0 = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="definition">nat_ind</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "O". <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "S". <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">IHn</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">IHn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
This proof is basically the same as the earlier one, but a
    few minor differences are worth noting.  First, in the induction
    step of the proof (the <span class="inlinecode">"<span class="id" type="var">S</span>"</span> case), we have to do a little
    bookkeeping manually (the <span class="inlinecode"><span class="id" type="tactic">intros</span></span>) that <span class="inlinecode"><span class="id" type="tactic">induction</span></span> does
    automatically.

<div class="paragraph"> </div>

    Second, we do not introduce <span class="inlinecode"><span class="id" type="var">n</span></span> into the context before applying
    <span class="inlinecode"><span class="id" type="var">nat_ind</span></span> &mdash; the conclusion of <span class="inlinecode"><span class="id" type="var">nat_ind</span></span> is a quantified formula,
    and <span class="inlinecode"><span class="id" type="tactic">apply</span></span> needs this conclusion to exactly match the shape of
    the goal state, including the quantifier.  The <span class="inlinecode"><span class="id" type="tactic">induction</span></span> tactic
    works either with a variable in the context or a quantified
    variable in the goal.

<div class="paragraph"> </div>

    Third, the <span class="inlinecode"><span class="id" type="tactic">apply</span></span> tactic automatically chooses variable names for
    us (in the second subgoal, here), whereas <span class="inlinecode"><span class="id" type="tactic">induction</span></span> lets us
    specify (with the <span class="inlinecode"><span class="id" type="keyword">as</span>...</span>  clause) what names should be used.  The
    automatic choice is actually a little unfortunate, since it
    re-uses the name <span class="inlinecode"><span class="id" type="var">n</span></span> for a variable that is different from the <span class="inlinecode"><span class="id" type="var">n</span></span>
    in the original theorem.  This is why the <span class="inlinecode"><span class="id" type="var">Case</span></span> annotation is
    just <span class="inlinecode"><span class="id" type="var">S</span></span> &mdash; if we tried to write it out in the more explicit form
    that we've been using for most proofs, we'd have to write <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span>
    <span class="inlinecode"><span class="id" type="var">n</span></span>, which doesn't make a lot of sense!  All of these conveniences
    make <span class="inlinecode"><span class="id" type="tactic">induction</span></span> nicer to use in practice than applying induction
    principles like <span class="inlinecode"><span class="id" type="var">nat_ind</span></span> directly.  But it is important to
    realize that, modulo this little bit of bookkeeping, applying
    <span class="inlinecode"><span class="id" type="var">nat_ind</span></span> is what we are really doing. 
<div class="paragraph"> </div>

<a name="lab155"></a><h4 class="section">Exercise: 2 stars (plus_one_r')</h4>
 Complete this proof without using the <span class="inlinecode"><span class="id" type="tactic">induction</span></span> tactic. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="plus_one_r'"><span class="id" type="lemma">plus_one_r'</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> + 1 = <span class="id" type="constructor">S</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 The induction principles that Coq generates for other
    datatypes defined with <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> follow a similar pattern. If we
    define a type <span class="inlinecode"><span class="id" type="var">t</span></span> with constructors <span class="inlinecode"><span class="id" type="var">c1</span></span> ... <span class="inlinecode"><span class="id" type="var">cn</span></span>, Coq generates a
    theorem with this shape:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">t_ind</span>&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">P</span>&nbsp;:&nbsp;<span class="id" type="var">t</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... <span class="id" type="tactic">case</span>&nbsp;<span class="id" type="keyword">for</span>&nbsp;<span class="id" type="var">c1</span>&nbsp;... <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... <span class="id" type="tactic">case</span>&nbsp;<span class="id" type="keyword">for</span>&nbsp;<span class="id" type="var">c2</span>&nbsp;... <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... <span class="id" type="tactic">case</span>&nbsp;<span class="id" type="keyword">for</span>&nbsp;<span class="id" type="var">cn</span>&nbsp;... <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">n</span>&nbsp;:&nbsp;<span class="id" type="var">t</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">n</span>
<div class="paragraph"> </div>

</div>
    The specific shape of each case depends on the arguments to the
    corresponding constructor.  Before trying to write down a general
    rule, let's look at some more examples. First, an example where
    the constructors take no arguments: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="yesno"><span class="id" type="inductive">yesno</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="yes"><span class="id" type="constructor">yes</span></a> : <a class="idref" href="Prop.html#yesno"><span class="id" type="inductive">yesno</span></a><br/>
&nbsp;&nbsp;| <a name="no"><span class="id" type="constructor">no</span></a> : <a class="idref" href="Prop.html#yesno"><span class="id" type="inductive">yesno</span></a>.<br/>

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Prop.html#yesno_ind"><span class="id" type="definition">yesno_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;yesno_ind&nbsp;:&nbsp;forall&nbsp;P&nbsp;:&nbsp;yesno&nbsp;-&gt;&nbsp;Prop,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;yes&nbsp;&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;no&nbsp;&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;y&nbsp;:&nbsp;yesno,&nbsp;P&nbsp;y&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<a name="lab156"></a><h4 class="section">Exercise: 1 star (rgb)</h4>
 Write out the induction principle that Coq will generate for
    the following datatype.  Write down your answer on paper, and
    then compare it with what Coq prints. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="rgb"><span class="id" type="inductive">rgb</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="red"><span class="id" type="constructor">red</span></a> : <a class="idref" href="Prop.html#rgb"><span class="id" type="inductive">rgb</span></a><br/>
&nbsp;&nbsp;| <a name="green"><span class="id" type="constructor">green</span></a> : <a class="idref" href="Prop.html#rgb"><span class="id" type="inductive">rgb</span></a><br/>
&nbsp;&nbsp;| <a name="blue"><span class="id" type="constructor">blue</span></a> : <a class="idref" href="Prop.html#rgb"><span class="id" type="inductive">rgb</span></a>.<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Prop.html#rgb_ind"><span class="id" type="definition">rgb_ind</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Here's another example, this time with one of the constructors
    taking some arguments. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="natlist"><span class="id" type="inductive">natlist</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="nnil"><span class="id" type="constructor">nnil</span></a> : <a class="idref" href="Prop.html#natlist"><span class="id" type="inductive">natlist</span></a><br/>
&nbsp;&nbsp;| <a name="ncons"><span class="id" type="constructor">ncons</span></a> : <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#natlist"><span class="id" type="inductive">natlist</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#natlist"><span class="id" type="inductive">natlist</span></a>.<br/>

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Prop.html#natlist_ind"><span class="id" type="definition">natlist_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;(modulo&nbsp;a&nbsp;little&nbsp;tidying)<br/>
&nbsp;&nbsp;&nbsp;natlist_ind&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;natlist&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;nnil&nbsp;&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;(l&nbsp;:&nbsp;natlist),&nbsp;P&nbsp;l&nbsp;-&gt;&nbsp;P&nbsp;(ncons&nbsp;n&nbsp;l))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;natlist,&nbsp;P&nbsp;n&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<a name="lab157"></a><h4 class="section">Exercise: 1 star (natlist1)</h4>
 Suppose we had written the above definition a little
   differently: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="natlist1"><span class="id" type="inductive">natlist1</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="nnil1"><span class="id" type="constructor">nnil1</span></a> : <a class="idref" href="Prop.html#natlist1"><span class="id" type="inductive">natlist1</span></a><br/>
&nbsp;&nbsp;| <a name="nsnoc1"><span class="id" type="constructor">nsnoc1</span></a> : <a class="idref" href="Prop.html#natlist1"><span class="id" type="inductive">natlist1</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#natlist1"><span class="id" type="inductive">natlist1</span></a>.<br/>

<br/>
</div>

<div class="doc">
Now what will the induction principle look like?  <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 From these examples, we can extract this general rule:

<div class="paragraph"> </div>

<ul class="doclist">
<li> The type declaration gives several constructors; each
      corresponds to one clause of the induction principle.

</li>
<li> Each constructor <span class="inlinecode"><span class="id" type="var">c</span></span> takes argument types <span class="inlinecode"><span class="id" type="var">a1</span></span>...<span class="inlinecode"><span class="id" type="var">an</span></span>.

</li>
<li> Each <span class="inlinecode"><span class="id" type="var">ai</span></span> can be either <span class="inlinecode"><span class="id" type="var">t</span></span> (the datatype we are defining) or
      some other type <span class="inlinecode"><span class="id" type="var">s</span></span>.

</li>
<li> The corresponding case of the induction principle
      says (in English):
<ul class="doclist">
<li> "for all values <span class="inlinecode"><span class="id" type="var">x1</span></span>...<span class="inlinecode"><span class="id" type="var">xn</span></span> of types <span class="inlinecode"><span class="id" type="var">a1</span></span>...<span class="inlinecode"><span class="id" type="var">an</span></span>, if
           <span class="inlinecode"><span class="id" type="var">P</span></span> holds for each of the <span class="inlinecode"><span class="id" type="var">x</span></span>s of type <span class="inlinecode"><span class="id" type="var">t</span></span>, then <span class="inlinecode"><span class="id" type="var">P</span></span>
           holds for <span class="inlinecode"><span class="id" type="var">c</span></span> <span class="inlinecode"><span class="id" type="var">x1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" type="var">xn</span></span>". 
</li>
</ul>

</li>
</ul>

<div class="paragraph"> </div>

<a name="lab158"></a><h4 class="section">Exercise: 1 star (ExSet)</h4>
 Here is an induction principle for an inductively defined
    set.

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ExSet_ind</span>&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">P</span>&nbsp;:&nbsp;<span class="id" type="var">ExSet</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">b</span>&nbsp;:&nbsp;<span class="id" type="var">bool</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;(<span class="id" type="var">con1</span>&nbsp;<span class="id" type="var">b</span>))&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;(<span class="id" type="var">n</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>)&nbsp;(<span class="id" type="var">e</span>&nbsp;:&nbsp;<span class="id" type="var">ExSet</span>),&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">e</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">P</span>&nbsp;(<span class="id" type="var">con2</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">e</span>))&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">e</span>&nbsp;:&nbsp;<span class="id" type="var">ExSet</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">e</span>
<div class="paragraph"> </div>

</div>
    Give an <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> definition of <span class="inlinecode"><span class="id" type="var">ExSet</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="ExSet"><span class="id" type="inductive">ExSet</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 What about polymorphic datatypes?

<div class="paragraph"> </div>

    The inductive definition of polymorphic lists

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Inductive</span>&nbsp;<span class="id" type="var">list</span>&nbsp;(<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>)&nbsp;:&nbsp;<span class="id" type="keyword">Type</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">nil</span>&nbsp;:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">X</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">cons</span>&nbsp;:&nbsp;<span class="id" type="var">X</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">X</span>.
<div class="paragraph"> </div>

</div>
    is very similar to that of <span class="inlinecode"><span class="id" type="var">natlist</span></span>.  The main difference is
    that, here, the whole definition is <i>parameterized</i> on a set <span class="inlinecode"><span class="id" type="var">X</span></span>:
    that is, we are defining a <i>family</i> of inductive types <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span>,
    one for each <span class="inlinecode"><span class="id" type="var">X</span></span>.  (Note that, wherever <span class="inlinecode"><span class="id" type="var">list</span></span> appears in the body
    of the declaration, it is always applied to the parameter <span class="inlinecode"><span class="id" type="var">X</span></span>.)
    The induction principle is likewise parameterized on <span class="inlinecode"><span class="id" type="var">X</span></span>:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">list_ind</span>&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;(<span class="id" type="var">X</span>&nbsp;:&nbsp;<span class="id" type="keyword">Type</span>)&nbsp;(<span class="id" type="var">P</span>&nbsp;:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">P</span>&nbsp;[]&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;(<span class="id" type="var">x</span>&nbsp;:&nbsp;<span class="id" type="var">X</span>)&nbsp;(<span class="id" type="var">l</span>&nbsp;:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">X</span>),&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">l</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">P</span>&nbsp;(<span class="id" type="var">x</span>&nbsp;::&nbsp;<span class="id" type="var">l</span>))&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">l</span>&nbsp;:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">X</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">l</span>
<div class="paragraph"> </div>

</div>
   Note the wording here (and, accordingly, the form of <span class="inlinecode"><span class="id" type="var">list_ind</span></span>):
   The <i>whole</i> induction principle is parameterized on <span class="inlinecode"><span class="id" type="var">X</span></span>.  That is,
   <span class="inlinecode"><span class="id" type="var">list_ind</span></span> can be thought of as a polymorphic function that, when
   applied to a type <span class="inlinecode"><span class="id" type="var">X</span></span>, gives us back an induction principle
   specialized to the type <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span>. 
<div class="paragraph"> </div>

<a name="lab159"></a><h4 class="section">Exercise: 1 star (tree)</h4>
 Write out the induction principle that Coq will generate for
   the following datatype.  Compare your answer with what Coq
   prints. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="tree"><span class="id" type="inductive">tree</span></a> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="leaf"><span class="id" type="constructor">leaf</span></a> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#tree"><span class="id" type="inductive">tree</span></a> <span class="id" type="var">X</span><br/>
&nbsp;&nbsp;| <a name="node"><span class="id" type="constructor">node</span></a> : <a class="idref" href="Prop.html#tree"><span class="id" type="inductive">tree</span></a> <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#tree"><span class="id" type="inductive">tree</span></a> <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#tree"><span class="id" type="inductive">tree</span></a> <span class="id" type="var">X</span>.<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Prop.html#tree_ind"><span class="id" type="definition">tree_ind</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab160"></a><h4 class="section">Exercise: 1 star (mytype)</h4>
 Find an inductive definition that gives rise to the
    following induction principle:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">mytype_ind</span>&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;(<span class="id" type="var">X</span>&nbsp;:&nbsp;<span class="id" type="keyword">Type</span>)&nbsp;(<span class="id" type="var">P</span>&nbsp;:&nbsp;<span class="id" type="var">mytype</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">x</span>&nbsp;:&nbsp;<span class="id" type="var">X</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;(<span class="id" type="var">constr1</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">x</span>))&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">n</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;(<span class="id" type="var">constr2</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">n</span>))&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">m</span>&nbsp;:&nbsp;<span class="id" type="var">mytype</span>&nbsp;<span class="id" type="var">X</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">m</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">n</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;(<span class="id" type="var">constr3</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">m</span>&nbsp;<span class="id" type="var">n</span>))&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">m</span>&nbsp;:&nbsp;<span class="id" type="var">mytype</span>&nbsp;<span class="id" type="var">X</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">m</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<div class="paragraph"> </div>

</div>
 <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab161"></a><h4 class="section">Exercise: 1 star, optional (foo)</h4>
 Find an inductive definition that gives rise to the
    following induction principle:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">foo_ind</span>&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;(<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">Y</span>&nbsp;:&nbsp;<span class="id" type="keyword">Type</span>)&nbsp;(<span class="id" type="var">P</span>&nbsp;:&nbsp;<span class="id" type="var">foo</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">Y</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">x</span>&nbsp;:&nbsp;<span class="id" type="var">X</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;(<span class="id" type="var">bar</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">Y</span>&nbsp;<span class="id" type="var">x</span>))&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">y</span>&nbsp;:&nbsp;<span class="id" type="var">Y</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;(<span class="id" type="var">baz</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">Y</span>&nbsp;<span class="id" type="var">y</span>))&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">f1</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">foo</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">Y</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">n</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;(<span class="id" type="var">f1</span>&nbsp;<span class="id" type="var">n</span>))&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">P</span>&nbsp;(<span class="id" type="var">quux</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">Y</span>&nbsp;<span class="id" type="var">f1</span>))&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">f2</span>&nbsp;:&nbsp;<span class="id" type="var">foo</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">Y</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">f2</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<div class="paragraph"> </div>

</div>
 <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab162"></a><h4 class="section">Exercise: 1 star, optional (foo')</h4>
 Consider the following inductive definition: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="foo'"><span class="id" type="inductive">foo'</span></a> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="C1"><span class="id" type="constructor">C1</span></a> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#foo'"><span class="id" type="inductive">foo'</span></a> <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#foo'"><span class="id" type="inductive">foo'</span></a> <span class="id" type="var">X</span><br/>
&nbsp;&nbsp;| <a name="C2"><span class="id" type="constructor">C2</span></a> : <a class="idref" href="Prop.html#foo'"><span class="id" type="inductive">foo'</span></a> <span class="id" type="var">X</span>.<br/>

<br/>
</div>

<div class="doc">
What induction principle will Coq generate for <span class="inlinecode"><span class="id" type="var">foo'</span></span>?  Fill
   in the blanks, then check your answer with Coq.)

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">foo'_ind</span>&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;(<span class="id" type="var">X</span>&nbsp;:&nbsp;<span class="id" type="keyword">Type</span>)&nbsp;(<span class="id" type="var">P</span>&nbsp;:&nbsp;<span class="id" type="var">foo'</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;(<span class="id" type="var">l</span>&nbsp;:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">X</span>)&nbsp;(<span class="id" type="var">f</span>&nbsp;:&nbsp;<span class="id" type="var">foo'</span>&nbsp;<span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">_______________________</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">_______________________</span>&nbsp;&nbsp;&nbsp;)&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">___________________________________________</span>&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">f</span>&nbsp;:&nbsp;<span class="id" type="var">foo'</span>&nbsp;<span class="id" type="var">X</span>,&nbsp;<span class="id" type="var">________________________</span>
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab163"></a><h2 class="section">Induction Hypotheses</h2>

<div class="paragraph"> </div>

 Where does the phrase "induction hypothesis" fit into this
    picture?  

<div class="paragraph"> </div>

    The induction principle for numbers

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">P</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">P</span>&nbsp;0&nbsp;&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">n</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">P</span>&nbsp;(<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">n</span>))&nbsp;&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">n</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">n</span>
<div class="paragraph"> </div>

</div>
   is a generic statement that holds for all propositions
   <span class="inlinecode"><span class="id" type="var">P</span></span> (strictly speaking, for all families of propositions <span class="inlinecode"><span class="id" type="var">P</span></span>
   indexed by a number <span class="inlinecode"><span class="id" type="var">n</span></span>).  Each time we use this principle, we
   are choosing <span class="inlinecode"><span class="id" type="var">P</span></span> to be a particular expression of type
   <span class="inlinecode"><span class="id" type="var">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="keyword">Prop</span></span>.

<div class="paragraph"> </div>

   We can make the proof more explicit by giving this expression a
   name.  For example, instead of stating the theorem <span class="inlinecode"><span class="id" type="var">mult_0_r</span></span> as
   "<span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">n</span>,</span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">*</span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>," we can write it as "<span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">n</span>,</span> <span class="inlinecode"><span class="id" type="var">P_m0r</span></span>
   <span class="inlinecode"><span class="id" type="var">n</span></span>", where <span class="inlinecode"><span class="id" type="var">P_m0r</span></span> is defined as... 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="P_m0r"><span class="id" type="definition">P_m0r</span></a> (<span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>) : <span class="id" type="keyword">Prop</span> := <br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> * 0 = 0.<br/>

<br/>
</div>

<div class="doc">
... or equivalently... 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="P_m0r'"><span class="id" type="definition">P_m0r'</span></a> : <span class="id" type="inductive">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="keyword">Prop</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> <span class="id" type="var">n</span> =&gt; <span class="id" type="var">n</span> * 0 = 0.<br/>

<br/>
</div>

<div class="doc">
Now when we do the proof it is easier to see where <span class="inlinecode"><span class="id" type="var">P_m0r</span></span>
    appears. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="mult_0_r''"><span class="id" type="lemma">mult_0_r''</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>, <br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#P_m0r"><span class="id" type="definition">P_m0r</span></a> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="definition">nat_ind</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = O". <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = S n'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Note&nbsp;the&nbsp;proof&nbsp;state&nbsp;at&nbsp;this&nbsp;point!&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">P_m0r</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">n'</span> <span class="id" type="var">IHn'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHn'</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
This extra naming step isn't something that we'll do in
    normal proofs, but it is useful to do it explicitly for an example
    or two, because it allows us to see exactly what the induction
    hypothesis is.  If we prove <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">n</span>,</span> <span class="inlinecode"><span class="id" type="var">P_m0r</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> by induction on
    <span class="inlinecode"><span class="id" type="var">n</span></span> (using either <span class="inlinecode"><span class="id" type="tactic">induction</span></span> or <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">nat_ind</span></span>), we see that the
    first subgoal requires us to prove <span class="inlinecode"><span class="id" type="var">P_m0r</span></span> <span class="inlinecode">0</span> ("<span class="inlinecode"><span class="id" type="var">P</span></span> holds for
    zero"), while the second subgoal requires us to prove <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>,</span>
    <span class="inlinecode"><span class="id" type="var">P_m0r</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">P_m0r</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span> (that is "<span class="inlinecode"><span class="id" type="var">P</span></span> holds of <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> if it
    holds of <span class="inlinecode"><span class="id" type="var">n'</span></span>" or, more elegantly, "<span class="inlinecode"><span class="id" type="var">P</span></span> is preserved by <span class="inlinecode"><span class="id" type="var">S</span></span>").
    The <i>induction hypothesis</i> is the premise of this latter
    implication &mdash; the assumption that <span class="inlinecode"><span class="id" type="var">P</span></span> holds of <span class="inlinecode"><span class="id" type="var">n'</span></span>, which we are
    allowed to use in proving that <span class="inlinecode"><span class="id" type="var">P</span></span> holds for <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span>. 
<div class="paragraph"> </div>

<a name="lab164"></a><h2 class="section">Evenness Again</h2>

<div class="paragraph"> </div>

 Some of the examples in the opening discussion of
    propositions involved the concept of <i>evenness</i>.  We began with a
    computation <span class="inlinecode"><span class="id" type="var">evenb</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> that <i>checks</i> evenness, yielding a boolean.
    From this, we built a proposition <span class="inlinecode"><span class="id" type="var">even</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> (defined in terms of
    <span class="inlinecode"><span class="id" type="var">evenb</span></span>) that <i>asserts</i> that <span class="inlinecode"><span class="id" type="var">n</span></span> is even.  That is, we defined
    "<span class="inlinecode"><span class="id" type="var">n</span></span> is even" to mean "<span class="inlinecode"><span class="id" type="var">evenb</span></span> returns <span class="inlinecode"><span class="id" type="var">true</span></span> when applied to
    <span class="inlinecode"><span class="id" type="var">n</span></span>."

<div class="paragraph"> </div>

    Another alternative is to define the concept of evenness directly.
    Instead of going indirectly via the <span class="inlinecode"><span class="id" type="var">evenb</span></span> function ("a number is
    even if a certain computation yields <span class="inlinecode"><span class="id" type="var">true</span></span>"), we can say directly
    what the concept of evenness means in terms of evidence. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="ev"><span class="id" type="inductive">ev</span></a> : <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="ev_0"><span class="id" type="constructor">ev_0</span></a> : <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="constructor">O</span><br/>
&nbsp;&nbsp;| <a name="ev_SS"><span class="id" type="constructor">ev_SS</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>, <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<span class="id" type="constructor">S</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>)).<br/>

<br/>
</div>

<div class="doc">
This definition says that there are two ways to give
    evidence that a number <span class="inlinecode"><span class="id" type="var">m</span></span> is even.  First, <span class="inlinecode">0</span> is even, and
    <span class="inlinecode"><span class="id" type="var">ev_0</span></span> is evidence for this.  Second, if <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> for some
    <span class="inlinecode"><span class="id" type="var">n</span></span> and we can give evidence <span class="inlinecode"><span class="id" type="var">e</span></span> that <span class="inlinecode"><span class="id" type="var">n</span></span> is even, then <span class="inlinecode"><span class="id" type="var">m</span></span> is
    also even, and <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">e</span></span> is the evidence. 
<div class="paragraph"> </div>

<a name="lab165"></a><h4 class="section">Exercise: 1 star, optional (four_ev)</h4>
 Give a tactic proof and a proof object showing that four is even. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="four_ev'"><span class="id" type="lemma">four_ev'</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> 4.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Definition</span> <a name="four_ev"><span class="id" type="definition">four_ev</span></a> : <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> 4 :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab166"></a><h4 class="section">Exercise: 2 stars (ev_plus4)</h4>
 Give a tactic proof and a proof object showing that, if <span class="inlinecode"><span class="id" type="var">n</span></span> is
    even, then so is <span class="inlinecode">4+<span class="id" type="var">n</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="ev_plus4"><span class="id" type="definition">ev_plus4</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (4 + <span class="id" type="var">n</span>) :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>
<span class="id" type="keyword">Theorem</span> <a name="ev_plus4'"><span class="id" type="lemma">ev_plus4'</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (4 + <span class="id" type="var">n</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab167"></a><h4 class="section">Exercise: 2 stars (double_even)</h4>
 Construct a tactic proof of the following proposition. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="double_even"><span class="id" type="lemma">double_even</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="Basics.html#double"><span class="id" type="definition">double</span></a> <span class="id" type="var">n</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab168"></a><h4 class="section">Exercise: 4 stars, optional (double_even_pfobj)</h4>
 Try to predict what proof object is constructed by the above
    tactic proof.  (Before checking your answer, you'll want to
    strip out any uses of <span class="inlinecode"><span class="id" type="var">Case</span></span>, as these will make the proof
    object look a bit cluttered.)  <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab169"></a><h2 class="section">Reasoning by Induction Over Evidence</h2>

<div class="paragraph"> </div>

 The highly "orthogonal" organization of Coq's design might
    suggest that, since we use the keyword <span class="inlinecode"><span class="id" type="keyword">Induction</span></span> to define
    primitive propositions together with their evidence, there must be
    some sort of induction principles associated with these
    definitions.  Indeed there are, and in this section we'll take a
    look at how they can be used.  To get warmed up, let's look at how
    the simpler <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> tactic works with inductively defined
    evidence. 
<div class="paragraph"> </div>

 Besides <i>constructing</i> evidence of evenness, we can also <i>reason
    about</i> evidence of evenness.  The fact that we introduced <span class="inlinecode"><span class="id" type="var">ev</span></span>
    with an <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> declaration tells us not only that the
    constructors <span class="inlinecode"><span class="id" type="var">ev_0</span></span> and <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> are ways to build evidence of
    evenness, but also that these two constructors are the <i>only</i> ways
    that evidence of evenness can be built.

<div class="paragraph"> </div>

    In other words, if someone gives us evidence <span class="inlinecode"><span class="id" type="var">E</span></span> justifying the
    assertion <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>, then we know that <span class="inlinecode"><span class="id" type="var">E</span></span> can only have one of two
    forms: either <span class="inlinecode"><span class="id" type="var">E</span></span> is <span class="inlinecode"><span class="id" type="var">ev_0</span></span> (and <span class="inlinecode"><span class="id" type="var">n</span></span> is <span class="inlinecode"><span class="id" type="var">O</span></span>), or <span class="inlinecode"><span class="id" type="var">E</span></span> is <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span>
    <span class="inlinecode"><span class="id" type="var">E'</span></span> (and <span class="inlinecode"><span class="id" type="var">n</span></span> is <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span>) and <span class="inlinecode"><span class="id" type="var">E'</span></span> is evidence that <span class="inlinecode"><span class="id" type="var">n'</span></span> is
    even.

<div class="paragraph"> </div>

    Thus, it makes sense to use the tactics that we have already seen
    for inductively defined <i>data</i> to reason instead about inductively
    defined <i>evidence</i>.

<div class="paragraph"> </div>

    For example, here we use a <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> on evidence that <span class="inlinecode"><span class="id" type="var">n</span></span> is even
    in order to show that <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> implies <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">(<span class="id" type="var">n</span>-2)</span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="ev_minus2"><span class="id" type="lemma">ev_minus2</span></a>: <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<span class="id" type="definition">pred</span> (<span class="id" type="definition">pred</span> <span class="id" type="var">n</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">E'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "E = ev_0". <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#ev_0"><span class="id" type="constructor">ev_0</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "E = ev_SS n' E'". <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">E'</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab170"></a><h4 class="section">Exercise: 1 star (ev_minus2_n)</h4>
 What happens if we try to <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> on <span class="inlinecode"><span class="id" type="var">n</span></span> instead of <span class="inlinecode"><span class="id" type="var">E</span></span>?  <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 We can also perform <i>induction</i> on evidence that <span class="inlinecode"><span class="id" type="var">n</span></span> is
    even. Here we use it to show that the old <span class="inlinecode"><span class="id" type="var">evenb</span></span> function
    returns <span class="inlinecode"><span class="id" type="var">true</span></span> on <span class="inlinecode"><span class="id" type="var">n</span></span> when <span class="inlinecode"><span class="id" type="var">n</span></span> is even according to <span class="inlinecode"><span class="id" type="var">ev</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="ev_even"><span class="id" type="lemma">ev_even</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#even"><span class="id" type="definition">even</span></a> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">E'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "E = ev_0".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">even</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "E = ev_SS n' E'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">even</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHE'</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
(Of course, we'd expect that <span class="inlinecode"><span class="id" type="var">even</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> also holds.  We'll
    see how to prove it in the next chapter.) 
<div class="paragraph"> </div>

<a name="lab171"></a><h4 class="section">Exercise: 1 star (ev_even_n)</h4>
 Could this proof be carried out by induction on <span class="inlinecode"><span class="id" type="var">n</span></span> instead
    of <span class="inlinecode"><span class="id" type="var">E</span></span>?  <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 The induction principle for inductively defined propositions does
    not follow quite the same form as that of inductively defined
    sets.  For now, you can take the intuitive view that induction on
    evidence <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> is similar to induction on <span class="inlinecode"><span class="id" type="var">n</span></span>, but restricts our
    attention to only those numbers for which evidence <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> could be
    generated.  We'll look at the induction principle of <span class="inlinecode"><span class="id" type="var">ev</span></span> in more
    depth below, to explain what's really going on. 
<div class="paragraph"> </div>

<a name="lab172"></a><h4 class="section">Exercise: 1 star (l_fails)</h4>
 The following proof attempt will not succeed.

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span>&nbsp;<span class="id" type="var">l</span>&nbsp;:&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ev</span>&nbsp;<span class="id" type="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span>&nbsp;<span class="id" type="var">n</span>. <span class="id" type="tactic">induction</span>&nbsp;<span class="id" type="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span>&nbsp;"O". <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span>&nbsp;<span class="id" type="var">ev_0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span>&nbsp;"S".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
<div class="paragraph"> </div>

</div>
   Briefly explain why.

<div class="paragraph"> </div>

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
 <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab173"></a><h4 class="section">Exercise: 2 stars (ev_sum)</h4>
 Here's another exercise requiring induction. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="ev_sum"><span class="id" type="lemma">ev_sum</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<span class="id" type="var">n</span>+<span class="id" type="var">m</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Here's another situation where we want to analyze evidence for
    evenness: proving that if <span class="inlinecode"><span class="id" type="var">n</span>+2</span> is even, then <span class="inlinecode"><span class="id" type="var">n</span></span> is.  Our first
    idea might be to use <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> for this kind of case analysis: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="SSev_ev_firsttry"><span class="id" type="lemma">SSev_ev_firsttry</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<span class="id" type="constructor">S</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>)) <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">E'</span>].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Stuck:&nbsp;<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>&nbsp;gives&nbsp;us&nbsp;un-provable&nbsp;subgoals!&nbsp;*)</span><br/>
<span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
But this doesn't work.  For example, in the first sub-goal, we've
    lost the information that <span class="inlinecode"><span class="id" type="var">n</span></span> is <span class="inlinecode">0</span>.  The right thing to use
    here, it turns out, is <span class="inlinecode"><span class="id" type="tactic">inversion</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="SSev_even"><span class="id" type="lemma">SSev_even</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<span class="id" type="constructor">S</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>)) <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">E'</span>]. <span class="id" type="tactic">apply</span> <span class="id" type="var">E'</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="comment">(*&nbsp;Print&nbsp;SSev_even.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
This use of <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> may seem a bit mysterious at first.
    Until now, we've only used <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> on equality
    propositions, to utilize injectivity of constructors or to
    discriminate between different constructors.  But we see here
    that <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> can also be applied to analyzing evidence
    for inductively defined propositions.

<div class="paragraph"> </div>

    Here's how <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> works in general.  Suppose the name
    <span class="inlinecode"><span class="id" type="var">I</span></span> refers to an assumption <span class="inlinecode"><span class="id" type="var">P</span></span> in the current context, where
    <span class="inlinecode"><span class="id" type="var">P</span></span> has been defined by an <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> declaration.  Then,
    for each of the constructors of <span class="inlinecode"><span class="id" type="var">P</span></span>, <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> <span class="inlinecode"><span class="id" type="var">I</span></span> generates
    a subgoal in which <span class="inlinecode"><span class="id" type="var">I</span></span> has been replaced by the exact,
    specific conditions under which this constructor could have
    been used to prove <span class="inlinecode"><span class="id" type="var">P</span></span>.  Some of these subgoals will be
    self-contradictory; <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> throws these away.  The ones
    that are left represent the cases that must be proved to
    establish the original goal.

<div class="paragraph"> </div>

    In this particular case, the <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> analyzed the construction
    <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>))</span>, determined that this could only have been
    constructed using <span class="inlinecode"><span class="id" type="var">ev_SS</span></span>, and generated a new subgoal with the
    arguments of that constructor as new hypotheses.  (It also
    produced an auxiliary equality, which happens to be useless here.)
    We'll begin exploring this more general behavior of inversion in
    what follows. 
<div class="paragraph"> </div>

<a name="lab174"></a><h4 class="section">Exercise: 1 star (inversion_practice)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="SSSSev_even"><span class="id" type="lemma">SSSSev_even</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<span class="id" type="constructor">S</span> (<span class="id" type="constructor">S</span> (<span class="id" type="constructor">S</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>)))) <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> tactic can also be used to derive goals by showing
    the absurdity of a hypothesis. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="even5_nonsense"><span class="id" type="lemma">even5_nonsense</span></a> : <br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> 5 <span style="font-family: arial;">&rarr;</span> 2 + 2 = 9.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 We can generally use <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> instead of <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> on
    inductive propositions.  This illustrates that in general, we
    get one case for each possible constructor.  Again, we also
    get some auxiliary equalities that are rewritten in the goal
    but not in the other hypotheses. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="ev_minus2'"><span class="id" type="lemma">ev_minus2'</span></a>: <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<span class="id" type="definition">pred</span> (<span class="id" type="definition">pred</span> <span class="id" type="var">n</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">E'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "E = ev_0". <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#ev_0"><span class="id" type="constructor">ev_0</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "E = ev_SS n' E'". <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">E'</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab175"></a><h4 class="section">Exercise: 3 stars (ev_ev_even)</h4>
 Finding the appropriate thing to do induction on is a
    bit tricky here: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="ev_ev_even"><span class="id" type="lemma">ev_ev_even</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<span class="id" type="var">n</span>+<span class="id" type="var">m</span>) <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab176"></a><h4 class="section">Exercise: 3 stars, optional (ev_plus_plus)</h4>
 Here's an exercise that just requires applying existing lemmas.  No
    induction or even case analysis is needed, but some of the rewriting
    may be tedious.  You'll want the <span class="inlinecode"><span class="id" type="tactic">replace</span></span> tactic used for <span class="inlinecode"><span class="id" type="var">plus_swap'</span></span>
    in Basics.v 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="ev_plus_plus"><span class="id" type="lemma">ev_plus_plus</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<span class="id" type="var">n</span>+<span class="id" type="var">m</span>) <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<span class="id" type="var">n</span>+<span class="id" type="var">p</span>) <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<span class="id" type="var">m</span>+<span class="id" type="var">p</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab177"></a><h2 class="section">Why Define Propositions Inductively?</h2>

<div class="paragraph"> </div>

 We have seen that the proposition "some number is even" can
    be phrased in two different ways &mdash; indirectly, via a testing
    function <span class="inlinecode"><span class="id" type="var">evenb</span></span>, or directly, by inductively describing what
    constitutes evidence for evenness.  These two ways of
    defining evenness are about equally easy to state and work
    with.  Which we choose is basically a question of taste.

<div class="paragraph"> </div>

    However, for many other properties of interest, the direct
    inductive definition is preferable, since writing a testing
    function may be awkward or even impossible.  For example, consider
    the property <span class="inlinecode"><span class="id" type="var">MyProp</span></span> defined as follows:

<div class="paragraph"> </div>

<ul class="doclist">
<li> the number <span class="inlinecode">4</span> has property <span class="inlinecode"><span class="id" type="var">MyProp</span></span>

</li>
<li> if <span class="inlinecode"><span class="id" type="var">n</span></span> has property <span class="inlinecode"><span class="id" type="var">MyProp</span></span>, then so does <span class="inlinecode">4+<span class="id" type="var">n</span></span>

</li>
<li> if <span class="inlinecode">2+<span class="id" type="var">n</span></span> has property <span class="inlinecode"><span class="id" type="var">MyProp</span></span>, then so does <span class="inlinecode"><span class="id" type="var">n</span></span>

</li>
<li> no other numbers have property <span class="inlinecode"><span class="id" type="var">MyProp</span></span>

</li>
</ul>

<div class="paragraph"> </div>

    This is a perfectly sensible definition of a set of numbers, but
    we cannot translate this definition directly as a Coq Fixpoint (or
    translate it directly into a recursive function in any other
    programming language).  We might be able to find a clever way of
    testing this property using a <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span> (indeed, it is not too
    hard to find one in this case), but in general this could require
    arbitrarily much thinking.  In fact, if the property we are
    interested in is uncomputable, then we cannot define it as a
    <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span> no matter how hard we try, because Coq requires that
    all <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>s correspond to terminating computations.

<div class="paragraph"> </div>

    On the other hand, writing an inductive definition of what it
    means to give evidence for the property <span class="inlinecode"><span class="id" type="var">MyProp</span></span> is
    straightforward: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="MyProp"><span class="id" type="inductive">MyProp</span></a> : <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="MyProp1"><span class="id" type="constructor">MyProp1</span></a> : <a class="idref" href="Prop.html#MyProp"><span class="id" type="inductive">MyProp</span></a> 4<br/>
&nbsp;&nbsp;| <a name="MyProp2"><span class="id" type="constructor">MyProp2</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>, <a class="idref" href="Prop.html#MyProp"><span class="id" type="inductive">MyProp</span></a> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#MyProp"><span class="id" type="inductive">MyProp</span></a> (4 + <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;| <a name="MyProp3"><span class="id" type="constructor">MyProp3</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>, <a class="idref" href="Prop.html#MyProp"><span class="id" type="inductive">MyProp</span></a> (2 + <span class="id" type="var">n</span>) <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#MyProp"><span class="id" type="inductive">MyProp</span></a> <span class="id" type="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
The first three clauses in the informal definition of <span class="inlinecode"><span class="id" type="var">MyProp</span></span>
    above are reflected in the first three clauses of the inductive
    definition.  The fourth clause is the precise force of the keyword
    <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span>. 
<div class="paragraph"> </div>

 As we did with evenness, we can now construct evidence that
    certain numbers satisfy <span class="inlinecode"><span class="id" type="var">MyProp</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="MyProp_ten"><span class="id" type="lemma">MyProp_ten</span></a> : <a class="idref" href="Prop.html#MyProp"><span class="id" type="inductive">MyProp</span></a> 10.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#MyProp3"><span class="id" type="constructor">MyProp3</span></a>. <span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (12 = 4 + 8) <span class="id" type="keyword">as</span> <span class="id" type="var">H12</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "Proof of assertion". <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">H12</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#MyProp2"><span class="id" type="constructor">MyProp2</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (8 = 4 + 4) <span class="id" type="keyword">as</span> <span class="id" type="var">H8</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "Proof of assertion". <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">H8</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#MyProp2"><span class="id" type="constructor">MyProp2</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#MyProp1"><span class="id" type="constructor">MyProp1</span></a>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab178"></a><h4 class="section">Exercise: 2 stars (MyProp)</h4>
 Here are two useful facts about MyProp.  The proofs are left
    to you. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="MyProp_0"><span class="id" type="lemma">MyProp_0</span></a> : <a class="idref" href="Prop.html#MyProp"><span class="id" type="inductive">MyProp</span></a> 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="MyProp_plustwo"><span class="id" type="lemma">MyProp_plustwo</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>, <a class="idref" href="Prop.html#MyProp"><span class="id" type="inductive">MyProp</span></a> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#MyProp"><span class="id" type="inductive">MyProp</span></a> (<span class="id" type="constructor">S</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 With these, we can show that <span class="inlinecode"><span class="id" type="var">MyProp</span></span> holds of all even numbers,
    and vice versa. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="MyProp_ev"><span class="id" type="lemma">MyProp_ev</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>, <br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#MyProp"><span class="id" type="inductive">MyProp</span></a> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">E'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "E = ev_0".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#MyProp_0"><span class="id" type="axiom">MyProp_0</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "E = ev_SS n' E'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#MyProp_plustwo"><span class="id" type="axiom">MyProp_plustwo</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHE'</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Here's an informal proof of this theorem:

<div class="paragraph"> </div>

    <i>Theorem</i>: For any nat <span class="inlinecode"><span class="id" type="var">n</span></span>, if <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> then <span class="inlinecode"><span class="id" type="var">MyProp</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>.

<div class="paragraph"> </div>

    <i>Proof</i>: Suppose <span class="inlinecode"><span class="id" type="var">n</span></span> is a <span class="inlinecode"><span class="id" type="var">nat</span></span> and <span class="inlinecode"><span class="id" type="var">E</span></span> is a derivation of <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>.
    We must exhibit a derivation of <span class="inlinecode"><span class="id" type="var">MyProp</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>.  The proof is by
    induction on <span class="inlinecode"><span class="id" type="var">E</span></span>.  There are two cases to consider:

<div class="paragraph"> </div>

<ul class="doclist">
<li> If the last step in <span class="inlinecode"><span class="id" type="var">E</span></span> is a use of <span class="inlinecode"><span class="id" type="var">ev_0</span></span>, then <span class="inlinecode"><span class="id" type="var">n</span></span> is <span class="inlinecode">0</span>.
      Then we must show that <span class="inlinecode"><span class="id" type="var">MyProp</span></span> <span class="inlinecode">0</span> holds; this is true by
      lemma <span class="inlinecode"><span class="id" type="var">MyProp_0</span></span>.

<div class="paragraph"> </div>


</li>
<li> If the last step in <span class="inlinecode"><span class="id" type="var">E</span></span> is a use of <span class="inlinecode"><span class="id" type="var">ev_SS</span></span>, then <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span>
      for some <span class="inlinecode"><span class="id" type="var">n'</span></span>, and there is a derivation of <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span>.  We must
      show <span class="inlinecode"><span class="id" type="var">MyProp</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>))</span>, with the induction hypothesis that
      <span class="inlinecode"><span class="id" type="var">MyProp</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> holds.  But by lemma <span class="inlinecode"><span class="id" type="var">MyProp_plustwo</span></span>, it's enough
      to show <span class="inlinecode"><span class="id" type="var">MyProp</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span>, which is exactly the induction
      hypothesis. <font size=-2>&#9744;</font> 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab179"></a><h4 class="section">Exercise: 3 stars (ev_MyProp)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="ev_MyProp"><span class="id" type="lemma">ev_MyProp</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>, <br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#MyProp"><span class="id" type="inductive">MyProp</span></a> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab180"></a><h4 class="section">Exercise: 3 stars, optional (ev_MyProp_informal)</h4>
 Write an informal proof corresponding to your
    formal proof of <span class="inlinecode"><span class="id" type="var">ev_MyProp</span></span>:

<div class="paragraph"> </div>

    Theorem: For any nat <span class="inlinecode"><span class="id" type="var">n</span></span>, if <span class="inlinecode"><span class="id" type="var">MyProp</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> then <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>.

<div class="paragraph"> </div>

    Proof:
    <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab181"></a><h1 class="section">The Big Picture: Coq's Two Universes</h1>

<div class="paragraph"> </div>

 Now that we've touched on several of Coq's basic structures,
    it may be useful to take a step back and talk a little about how
    it all fits together. 
<div class="paragraph"> </div>

 Expressions in Coq live in two distinct universes:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="keyword">Type</span></span> is the universe of <i>computations</i> and <i>data</i>.  

</li>
<li> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> is the universe of <i>logical assertions</i> and <i>evidence</i>.

</li>
</ul>

<div class="paragraph"> </div>

   The two universes have some deep similarities &mdash; in each, we can
   talk about values, inductive definitions, quantification, etc. &mdash;
   but they play quite different roles in defining and reasoning about
   mathematical structures. 
<div class="paragraph"> </div>

<a name="lab182"></a><h2 class="section">Values</h2>

<div class="paragraph"> </div>

 Both universes start with an infinite set of <i>constructors</i>.
    Constructors have no internal structure: they are just atomic
    symbols.  For example, <span class="inlinecode"><span class="id" type="var">true</span></span>, <span class="inlinecode"><span class="id" type="var">false</span></span>, <span class="inlinecode"><span class="id" type="var">O</span></span>, <span class="inlinecode"><span class="id" type="var">S</span></span>, <span class="inlinecode"><span class="id" type="var">nil</span></span>, <span class="inlinecode"><span class="id" type="var">cons</span></span>,
    <span class="inlinecode"><span class="id" type="var">ev_0</span></span>, <span class="inlinecode"><span class="id" type="var">ev_SS</span></span>, ...

<div class="paragraph"> </div>

    The simplest values are expressions consisting entirely of
    constructor applications.  Examples include:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">true</span></span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">O</span></span> 

</li>
<li> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>))</span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">ev_0</span></span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>))</span> <span class="inlinecode"><span class="id" type="var">ev_0</span></span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>))))</span> <span class="inlinecode">(<span class="id" type="var">ev_SS</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>))</span> <span class="inlinecode"><span class="id" type="var">ev_0</span>)</span>

</li>
</ul>

<div class="paragraph"> </div>

    Such expressions can be thought of as trees. Their leaves are
    nullary constructors (applied to no arguments), and their internal
    nodes are applications of constructors to one or more values.  In
    the universe <span class="inlinecode"><span class="id" type="keyword">Type</span></span>, we think of values as <i>data</i>.  In <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>, we
    think of values as <i>evidence</i>.  Values in <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> are sometimes
    called <i>derivation trees</i>. 

<div class="paragraph"> </div>

    Functions are also values &mdash; for example:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">true</span></span> 

</li>
<li> <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">b</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">negb</span></span> <span class="inlinecode"><span class="id" type="var">b</span></span>

</li>
<li> <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>))</span>

</li>
<li> <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode">(<span class="id" type="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>))</span> <span class="inlinecode"><span class="id" type="var">P</span></span>

</li>
</ul>

<div class="paragraph"> </div>

    Functions that return values in the universe <span class="inlinecode"><span class="id" type="keyword">Type</span></span> represent
    <i>computations</i>: they take some input values and return an output
    value computed from the inputs.  Functions returning values in
    <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> are <i>universally quantified evidence</i>: that is, they use
    their inputs to build evidence for some proposition (whose
    statement may also involve these inputs). 
<div class="paragraph"> </div>

<a name="lab183"></a><h2 class="section">Inductive Definitions</h2>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> declarations give names to subsets of the set of all
    values.  For example, the declaration of the inductive type <span class="inlinecode"><span class="id" type="var">nat</span></span>
    defines a <i>set</i> whose <i>elements</i> are values representing natural
    numbers.  That is, it picks out a subset <span class="inlinecode"><span class="id" type="var">nat</span></span> of the set of all
    values that satisfies the following properties:

<div class="paragraph"> </div>

<ul class="doclist">
<li> the value <span class="inlinecode"><span class="id" type="var">O</span></span> is in this set;

</li>
<li> the set is <i>closed</i> under applications of <span class="inlinecode"><span class="id" type="var">S</span></span> (i.e., if a
        value <span class="inlinecode"><span class="id" type="var">n</span></span> is in the set, then <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> is too);

</li>
<li> it is the smallest set satisfying these conditions (i.e., the
        only values in <span class="inlinecode"><span class="id" type="var">nat</span></span> are the ones that <i>must</i> be, according to
        the previous two conditions; there is no other "junk").

</li>
</ul>

<div class="paragraph"> </div>

    Inductively defined sets can themselves appear as arguments to
    constructors in compound values.  Examples:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">nat</span></span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">nil</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">cons</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode"><span class="id" type="var">O</span></span> <span class="inlinecode">(<span class="id" type="var">cons</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>)</span> <span class="inlinecode">(<span class="id" type="var">nil</span></span> <span class="inlinecode"><span class="id" type="var">nat</span>))</span>

</li>
</ul>

<div class="paragraph"> </div>

    Also, we can write functions that take sets as arguments and
    return sets as results.  For example, <span class="inlinecode"><span class="id" type="var">list</span></span> is a function that
    takes a set <span class="inlinecode"><span class="id" type="var">X</span></span> as argument and returns as result the set <span class="inlinecode"><span class="id" type="var">list</span></span>
    <span class="inlinecode"><span class="id" type="var">X</span></span> (whose members are lists with elements drawn from <span class="inlinecode"><span class="id" type="var">X</span></span>).

<div class="paragraph"> </div>

    Similarly, the declaration of the inductive type <span class="inlinecode"><span class="id" type="var">ev</span></span> defines a
    <i>family of propositions</i> whose <i>elements</i> are values representing
    evidence that numbers are even.  That is, for each <span class="inlinecode"><span class="id" type="var">n</span></span>, the
    definition picks out a subset <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> of the set of all values,
    satisfying the following properties:

<div class="paragraph"> </div>

<ul class="doclist">
<li> the value <span class="inlinecode"><span class="id" type="var">ev_0</span></span> is in the set <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">O</span></span>;

</li>
<li> the sets are <i>closed</i> under well-typed applications of
        <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> &mdash; i.e., if <span class="inlinecode"><span class="id" type="var">e</span></span> is in the set <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>, then
        <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">e</span></span> is in the set <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>))</span>;

</li>
<li> it is the smallest family of sets satisfying these
        conditions (i.e., the only values in any set <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> are the
        ones that <i>must</i> be, according to the previous two conditions;
        there is no other junk). 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab184"></a><h2 class="section">Types and Kinds</h2>

<div class="paragraph"> </div>

 Informally, a <i>type</i> in Coq is an expression that is used to
    classify other expressions.  For example, <span class="inlinecode"><span class="id" type="var">bool</span></span>, <span class="inlinecode"><span class="id" type="var">nat</span></span>, <span class="inlinecode"><span class="id" type="var">list</span></span>
    <span class="inlinecode"><span class="id" type="var">bool</span></span>, <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span>, <span class="inlinecode"><span class="id" type="var">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">nat</span></span>, and so on are all types.  The type
    <span class="inlinecode"><span class="id" type="var">bool</span></span> classifies <span class="inlinecode"><span class="id" type="var">true</span></span> and <span class="inlinecode"><span class="id" type="var">false</span></span>; the type <span class="inlinecode"><span class="id" type="var">nat</span></span> classifies
    <span class="inlinecode"><span class="id" type="var">O</span></span>, <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span></span>, <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>)</span>, etc.; the type <span class="inlinecode"><span class="id" type="var">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">nat</span></span> classifies
    function values (like <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>) that yield a number when
    given a number as input.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" type="keyword">Type</span></span>, <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>, and compound expressions built from them (like
    <span class="inlinecode"><span class="id" type="keyword">Type</span><span style="font-family: arial;">&rarr;</span><span class="id" type="keyword">Type</span></span>) play a similar classifying role "one level up" &mdash;
    that is, they can be thought of as the <i>types of type (and
    proposition) expressions</i>.  Technically, they are called <i>kinds</i>,
    to avoid too many uses of the word "type."  For example, the
    expressions <span class="inlinecode"><span class="id" type="var">nat</span></span>, <span class="inlinecode"><span class="id" type="var">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">nat</span></span> and <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span> all have kind <span class="inlinecode"><span class="id" type="keyword">Type</span></span>,
    while <span class="inlinecode"><span class="id" type="var">list</span></span> itself has kind <span class="inlinecode"><span class="id" type="keyword">Type</span><span style="font-family: arial;">&rarr;</span><span class="id" type="keyword">Type</span></span> and <span class="inlinecode"><span class="id" type="var">ev</span></span> has kind
    <span class="inlinecode"><span class="id" type="var">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="keyword">Prop</span></span>.  
<div class="paragraph"> </div>

<a name="lab185"></a><h2 class="section">Propositions vs. Booleans</h2>

<div class="paragraph"> </div>

 Propositions and booleans are superficially similar, but they are
    really quite different things!

<div class="paragraph"> </div>

<ul class="doclist">
<li> Booleans are <i>values</i> in the <i>computational</i> world.  Every
      expression of type <span class="inlinecode"><span class="id" type="var">bool</span></span> (with no free variables) can be
      simplified to either <span class="inlinecode"><span class="id" type="var">true</span></span> or <span class="inlinecode"><span class="id" type="var">false</span></span>.

<div class="paragraph"> </div>


</li>
<li> Propositions are <i>types</i> in the <i>logical</i> world.  They are
      either <i>provable</i> (i.e., there is some expression that has this
      type) or not (there is no such expression).  It doesn't make
      sense to say that a proposition is "equivalent to <span class="inlinecode"><span class="id" type="var">true</span></span>." 

<div class="paragraph"> </div>

      We sometimes use the words "true" and "false" informally when
      referring to propositions.  Strictly speaking, this is wrong: a
      proposition is either provable or it is not. 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab186"></a><h2 class="section">Functions vs. Quantifiers</h2>

<div class="paragraph"> </div>

 The types <span class="inlinecode"><span class="id" type="var">A</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">B</span></span> and <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">x</span>:<span class="id" type="var">A</span>,</span> <span class="inlinecode"><span class="id" type="var">B</span></span> both describe functions from
    <span class="inlinecode"><span class="id" type="var">A</span></span> to <span class="inlinecode"><span class="id" type="var">B</span></span>.  The only difference is that, in the second case, the
    expression <span class="inlinecode"><span class="id" type="var">B</span></span> &mdash; the type of the result &mdash; can mention the
    argument <span class="inlinecode"><span class="id" type="var">x</span></span> by name.  For example:

<div class="paragraph"> </div>

<ul class="doclist">
<li> The function <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">x</span>:<span class="id" type="var">nat</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">x</span></span> has type <span class="inlinecode"><span class="id" type="var">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">nat</span></span> &mdash;
         that is, it maps each number <span class="inlinecode"><span class="id" type="var">n</span></span> to a number.

<div class="paragraph"> </div>


</li>
<li> The function <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">nil</span></span> <span class="inlinecode">(<span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">X</span>)</span> has type <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span>
         <span class="inlinecode"><span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>,</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode">(<span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">X</span>)</span> &mdash; that is, it maps each set <span class="inlinecode"><span class="id" type="var">X</span></span> to a
         particular list of lists of <span class="inlinecode"><span class="id" type="var">X</span></span>s.  (Of course, <span class="inlinecode"><span class="id" type="var">nil</span></span> is
         usually written as <span class="inlinecode">[]</span> instead of <span class="inlinecode"><span class="id" type="var">nil</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span>.)

</li>
</ul>

<div class="paragraph"> </div>

    In fact, the two ways of writing function types are really the
    same: In Coq, <span class="inlinecode"><span class="id" type="var">A</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">B</span></span> is actually just an abbreviation for <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span>
    <span class="inlinecode"><span class="id" type="var">x</span>:<span class="id" type="var">A</span>,</span> <span class="inlinecode"><span class="id" type="var">B</span></span>, where <span class="inlinecode"><span class="id" type="var">x</span></span> is some variable name not occurring in <span class="inlinecode"><span class="id" type="var">B</span></span>.  For
    example, the type of <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">x</span>:<span class="id" type="var">nat</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">x</span></span> can be written, if we
    like, as <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">x</span>:<span class="id" type="var">nat</span>,</span> <span class="inlinecode"><span class="id" type="var">nat</span></span>. 
<div class="paragraph"> </div>

<a name="lab187"></a><h2 class="section">Functions vs. Implications</h2>

<div class="paragraph"> </div>

 In both <span class="inlinecode"><span class="id" type="keyword">Type</span></span> and <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>, we can write functions that transform
    values into other values.  Also, functions themselves are values;
    this means we can

<div class="paragraph"> </div>

<ul class="doclist">
<li> write higher-order functions that take functions as arguments
        or return functions as results, and

</li>
<li> apply constructors to functions to build complex values
        containing functions.

</li>
</ul>

<div class="paragraph"> </div>

    A function of type <span class="inlinecode"><span class="id" type="var">P</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">Q</span></span> in <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> is something that takes
    evidence for <span class="inlinecode"><span class="id" type="var">P</span></span> as an argument and yields evidence for <span class="inlinecode"><span class="id" type="var">Q</span></span> as its
    result.  Such a function can be regarded as <i>evidence</i> that <span class="inlinecode"><span class="id" type="var">P</span></span>
    implies <span class="inlinecode"><span class="id" type="var">Q</span></span>, since, whenever we have evidence that <span class="inlinecode"><span class="id" type="var">P</span></span> is true, we
    can apply the function and get back evidence that <span class="inlinecode"><span class="id" type="var">Q</span></span> is true:
    evidence for an implication is a function on evidence.  This is why
    we use the same notation for functions and logical implications in
    Coq: they are exactly the same thing! 
<div class="paragraph"> </div>

<a name="lab188"></a><h1 class="section">Informal Proofs</h1>

<div class="paragraph"> </div>

 Q: What is the relation between a formal proof of a proposition
       <span class="inlinecode"><span class="id" type="var">P</span></span> and an informal proof of the same proposition <span class="inlinecode"><span class="id" type="var">P</span></span>?

<div class="paragraph"> </div>

    A: The latter should <i>teach</i> the reader how to produce the
       former.

<div class="paragraph"> </div>

    Q: How much detail is needed?

<div class="paragraph"> </div>

    A: There is no single right answer; rather, there is a range
       of choices.  

<div class="paragraph"> </div>

      At one end of the spectrum, we can essentially give the
      reader the whole formal proof (i.e., the informal proof
      amounts to just transcribing the formal one into words).
      This gives the reader the <i>ability</i> to reproduce the formal
      one for themselves, but it doesn't <i>teach</i> them anything.

<div class="paragraph"> </div>

      At the other end of the spectrum, we can say "The theorem
      is true and you can figure out why for yourself if you
      think about it hard enough."  This is also not a good
      teaching strategy, because usually writing the proof
      requires some deep insights into the thing we're proving,
      and most readers will give up before they rediscover all
      the same insights as we did.

<div class="paragraph"> </div>

      In the middle is the golden mean &mdash; a proof that includes
      all of the essential insights (saving the reader the hard
      part of work that we went through to find the proof in the
      first place) and clear high-level suggestions for the more
      routine parts to save the reader from spending too much
      time reconstructing these parts (e.g., what the IH says and
      what must be shown in each case of an inductive proof), but
      not so much detail that the main ideas are obscured. 

<div class="paragraph"> </div>

   Another key point: if we're talking about a formal proof of a
   proposition P and an informal proof of P, the proposition P doesn't
   change.  That is, formal and informal proofs are <i>talking about the
   same world</i> and they must <i>play by the same rules</i>. 
<div class="paragraph"> </div>

<a name="lab189"></a><h2 class="section">Informal Proofs by Induction</h2>

<div class="paragraph"> </div>

 Since we've spent much of this chapter looking "under the hood" at
    formal proofs by induction, now is a good moment to talk a little
    about <i>informal</i> proofs by induction.

<div class="paragraph"> </div>

    In the real world of mathematical communication, written proofs
    range from extremely longwinded and pedantic to extremely brief
    and telegraphic.  The ideal is somewhere in between, of course,
    but while you are getting used to the style it is better to start
    out at the pedantic end.  Also, during the learning phase, it is
    probably helpful to have a clear standard to compare against.
    With this in mind, we offer two templates below &mdash; one for proofs
    by induction over <i>data</i> (i.e., where the thing we're doing
    induction on lives in <span class="inlinecode"><span class="id" type="keyword">Type</span></span>) and one for proofs by induction over
    <i>evidence</i> (i.e., where the inductively defined thing lives in
    <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>).  In the rest of this course, please follow one of the two
    for <i>all</i> of your inductive proofs. 
<div class="paragraph"> </div>

<a name="lab190"></a><h3 class="section">Induction Over an Inductively Defined Set</h3>

<div class="paragraph"> </div>

 <i>Template</i>: 

<div class="paragraph"> </div>

<ul class="doclist">
<li> <i>Theorem</i>: &lt;Universally quantified proposition of the form
         "For all <span class="inlinecode"><span class="id" type="var">n</span>:<span class="id" type="var">S</span></span>, <span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">n</span>)</span>," where <span class="inlinecode"><span class="id" type="var">S</span></span> is some inductively defined
         set.&gt;

<div class="paragraph"> </div>

         <i>Proof</i>: By induction on <span class="inlinecode"><span class="id" type="var">n</span></span>.

<div class="paragraph"> </div>

           &lt;one case for each constructor <span class="inlinecode"><span class="id" type="var">c</span></span> of <span class="inlinecode"><span class="id" type="var">S</span></span>...&gt;

<div class="paragraph"> </div>

<ul class="doclist">
<li> Suppose <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">c</span></span> <span class="inlinecode"><span class="id" type="var">a1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" type="var">ak</span></span>, where &lt;...and here we state
             the IH for each of the <span class="inlinecode"><span class="id" type="var">a</span></span>'s that has type <span class="inlinecode"><span class="id" type="var">S</span></span>, if any&gt;.
             We must show &lt;...and here we restate <span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">c</span></span> <span class="inlinecode"><span class="id" type="var">a1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" type="var">ak</span>)</span>&gt;.

<div class="paragraph"> </div>

             &lt;go on and prove <span class="inlinecode"><span class="id" type="var">P</span>(<span class="id" type="var">n</span>)</span> to finish the case...&gt;

<div class="paragraph"> </div>


</li>
<li> &lt;other cases similarly...&gt;                        <font size=-2>&#9744;</font>

</li>
</ul>

</li>
</ul>

<div class="paragraph"> </div>

    <i>Example</i>:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <i>Theorem</i>: For all sets <span class="inlinecode"><span class="id" type="var">X</span></span>, lists <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span>, and numbers
        <span class="inlinecode"><span class="id" type="var">n</span></span>, if <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">n</span></span> then <span class="inlinecode"><span class="id" type="var">index</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">None</span></span>.

<div class="paragraph"> </div>

        <i>Proof</i>: By induction on <span class="inlinecode"><span class="id" type="var">l</span></span>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Suppose <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>.  We must show, for all numbers <span class="inlinecode"><span class="id" type="var">n</span></span>,
          that, if length <span class="inlinecode">[]</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">n</span></span>, then <span class="inlinecode"><span class="id" type="var">index</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> <span class="inlinecode">[]</span> <span class="inlinecode">=</span>
          <span class="inlinecode"><span class="id" type="var">None</span></span>.

<div class="paragraph"> </div>

          This follows immediately from the definition of index.

<div class="paragraph"> </div>


</li>
<li> Suppose <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" type="var">l'</span></span> for some <span class="inlinecode"><span class="id" type="var">x</span></span> and <span class="inlinecode"><span class="id" type="var">l'</span></span>, where
          <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode"><span class="id" type="var">l'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">n'</span></span> implies <span class="inlinecode"><span class="id" type="var">index</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span> <span class="inlinecode"><span class="id" type="var">l'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">None</span></span>, for
          any number <span class="inlinecode"><span class="id" type="var">n'</span></span>.  We must show, for all <span class="inlinecode"><span class="id" type="var">n</span></span>, that, if
          <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode">(<span class="id" type="var">x</span>::<span class="id" type="var">l'</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">n</span></span> then <span class="inlinecode"><span class="id" type="var">index</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> <span class="inlinecode">(<span class="id" type="var">x</span>::<span class="id" type="var">l'</span>)</span> <span class="inlinecode">=</span>
          <span class="inlinecode"><span class="id" type="var">None</span></span>.

<div class="paragraph"> </div>

          Let <span class="inlinecode"><span class="id" type="var">n</span></span> be a number with <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">n</span></span>.  Since

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">length</span>&nbsp;<span class="id" type="var">l</span>&nbsp;=&nbsp;<span class="id" type="var">length</span>&nbsp;(<span class="id" type="var">x</span>::<span class="id" type="var">l'</span>)&nbsp;=&nbsp;<span class="id" type="var">S</span>&nbsp;(<span class="id" type="var">length</span>&nbsp;<span class="id" type="var">l'</span>),
<div class="paragraph"> </div>

</div>
          it suffices to show that 

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">index</span>&nbsp;(<span class="id" type="var">S</span>&nbsp;(<span class="id" type="var">length</span>&nbsp;<span class="id" type="var">l'</span>))&nbsp;<span class="id" type="var">l'</span>&nbsp;=&nbsp;<span class="id" type="var">None</span>.
<div class="paragraph"> </div>

</div>
          But this follows directly from the induction hypothesis,
          picking <span class="inlinecode"><span class="id" type="var">n'</span></span> to be length <span class="inlinecode"><span class="id" type="var">l'</span></span>.  <font size=-2>&#9744;</font> 
</li>
</ul>

</li>
</ul>

<div class="paragraph"> </div>

<a name="lab191"></a><h3 class="section">Induction Over an Inductively Defined Proposition</h3>

<div class="paragraph"> </div>

 Since inductively defined proof objects are often called
    "derivation trees," this form of proof is also known as <i>induction
    on derivations</i>. 

<div class="paragraph"> </div>

    <i>Template</i>:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <i>Theorem</i>: &lt;Proposition of the form "<span class="inlinecode"><span class="id" type="var">Q</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span>," where <span class="inlinecode"><span class="id" type="var">Q</span></span> is
         some inductively defined proposition (more generally,
         "For all <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode"><span class="id" type="var">z</span></span>, <span class="inlinecode"><span class="id" type="var">Q</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode"><span class="id" type="var">z</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode"><span class="id" type="var">z</span></span>")&gt;

<div class="paragraph"> </div>

         <i>Proof</i>: By induction on a derivation of <span class="inlinecode"><span class="id" type="var">Q</span></span>.  &lt;Or, more
         generally, "Suppose we are given <span class="inlinecode"><span class="id" type="var">x</span></span>, <span class="inlinecode"><span class="id" type="var">y</span></span>, and <span class="inlinecode"><span class="id" type="var">z</span></span>.  We
         show that <span class="inlinecode"><span class="id" type="var">Q</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode"><span class="id" type="var">z</span></span> implies <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode"><span class="id" type="var">z</span></span>, by induction on a
         derivation of <span class="inlinecode"><span class="id" type="var">Q</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode"><span class="id" type="var">z</span></span>"...&gt;

<div class="paragraph"> </div>

           &lt;one case for each constructor <span class="inlinecode"><span class="id" type="var">c</span></span> of <span class="inlinecode"><span class="id" type="var">Q</span></span>...&gt;

<div class="paragraph"> </div>

<ul class="doclist">
<li> Suppose the final rule used to show <span class="inlinecode"><span class="id" type="var">Q</span></span> is <span class="inlinecode"><span class="id" type="var">c</span></span>.  Then
             &lt;...and here we state the types of all of the <span class="inlinecode"><span class="id" type="var">a</span></span>'s
             together with any equalities that follow from the
             definition of the constructor and the IH for each of
             the <span class="inlinecode"><span class="id" type="var">a</span></span>'s that has type <span class="inlinecode"><span class="id" type="var">Q</span></span>, if there are any&gt;.  We must
             show &lt;...and here we restate <span class="inlinecode"><span class="id" type="var">P</span></span>&gt;.

<div class="paragraph"> </div>

             &lt;go on and prove <span class="inlinecode"><span class="id" type="var">P</span></span> to finish the case...&gt;

<div class="paragraph"> </div>


</li>
<li> &lt;other cases similarly...&gt;                        <font size=-2>&#9744;</font>

</li>
</ul>

</li>
</ul>

<div class="paragraph"> </div>

    <i>Example</i>
 

<div class="paragraph"> </div>

<ul class="doclist">
<li> <i>Theorem</i>: The <span class="inlinecode">&lt;=</span> relation is transitive &mdash; i.e., for all
         numbers <span class="inlinecode"><span class="id" type="var">n</span></span>, <span class="inlinecode"><span class="id" type="var">m</span></span>, and <span class="inlinecode"><span class="id" type="var">o</span></span>, if <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" type="var">m</span></span> and <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" type="var">o</span></span>, then
         <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" type="var">o</span></span>.

<div class="paragraph"> </div>

         <i>Proof</i>: By induction on a derivation of <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" type="var">o</span></span>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Suppose the final rule used to show <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" type="var">o</span></span> is
             <span class="inlinecode"><span class="id" type="var">le_n</span></span>.  Then <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">o</span></span> and the result is immediate.

<div class="paragraph"> </div>


</li>
<li> Suppose the final rule used to show <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" type="var">o</span></span> is
             <span class="inlinecode"><span class="id" type="var">le_S</span></span>.  Then <span class="inlinecode"><span class="id" type="var">o</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">o'</span></span> for some <span class="inlinecode"><span class="id" type="var">o'</span></span> with <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" type="var">o'</span></span>.
             By induction hypothesis, <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" type="var">o'</span></span>.

<div class="paragraph"> </div>

             But then, by <span class="inlinecode"><span class="id" type="var">le_S</span></span>, <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" type="var">o</span></span>.  <font size=-2>&#9744;</font> 
</li>
</ul>

</li>
</ul>

<div class="paragraph"> </div>

<a name="lab192"></a><h1 class="section">Optional Material</h1>

<div class="paragraph"> </div>

 This section offers some additional details on how induction works
    in Coq.  It can safely be skimmed on a first reading.  (We
    recommend skimming rather than skipping over it outright: it
    answers some questions that occur to many Coq users at some point,
    so it is useful to have a rough idea of what's here.) 
<div class="paragraph"> </div>

<a name="lab193"></a><h2 class="section">More on the <span class="inlinecode"><span class="id" type="tactic">induction</span></span> Tactic</h2>

<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" type="tactic">induction</span></span> tactic actually does even more low-level
    bookkeeping for us than we discussed above.

<div class="paragraph"> </div>

    Recall the informal statement of the induction principle for
    natural numbers:

<div class="paragraph"> </div>

<ul class="doclist">
<li> If <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> is some proposition involving a natural number n, and
        we want to show that P holds for <i>all</i> numbers n, we can
        reason like this:
<ul class="doclist">
<li> show that <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">O</span></span> holds

</li>
<li> show that, if <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> holds, then so does <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span>

</li>
<li> conclude that <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> holds for all n.

</li>
</ul>

</li>
</ul>
    So, when we begin a proof with <span class="inlinecode"><span class="id" type="tactic">intros</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> and then <span class="inlinecode"><span class="id" type="tactic">induction</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>,
    we are first telling Coq to consider a <i>particular</i> <span class="inlinecode"><span class="id" type="var">n</span></span> (by
    introducing it into the context) and then telling it to prove
    something about <i>all</i> numbers (by using induction).

<div class="paragraph"> </div>

    What Coq actually does in this situation, internally, is to
    "re-generalize" the variable we perform induction on.  For
    example, in the proof above that <span class="inlinecode"><span class="id" type="var">plus</span></span> is associative...

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="plus_assoc'"><span class="id" type="lemma">plus_assoc'</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> : <span class="id" type="inductive">nat</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> + (<span class="id" type="var">m</span> + <span class="id" type="var">p</span>) = (<span class="id" type="var">n</span> + <span class="id" type="var">m</span>) + <span class="id" type="var">p</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;...we&nbsp;first&nbsp;introduce&nbsp;all&nbsp;3&nbsp;variables&nbsp;into&nbsp;the&nbsp;context,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;which&nbsp;amounts&nbsp;to&nbsp;saying&nbsp;"Consider&nbsp;an&nbsp;arbitrary&nbsp;<span class="inlinecode"><span class="id" type="var">n</span></span>,&nbsp;<span class="inlinecode"><span class="id" type="var">m</span></span>,&nbsp;and<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="var">p</span></span>..."&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;...We&nbsp;now&nbsp;use&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="tactic">induction</span></span>&nbsp;tactic&nbsp;to&nbsp;prove&nbsp;<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>&nbsp;(that<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is,&nbsp;<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">(<span class="id" type="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">p</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode">(<span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">m</span>)</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">p</span></span>)&nbsp;for&nbsp;_all_&nbsp;<span class="inlinecode"><span class="id" type="var">n</span></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;hence&nbsp;also&nbsp;for&nbsp;the&nbsp;particular&nbsp;<span class="inlinecode"><span class="id" type="var">n</span></span>&nbsp;that&nbsp;is&nbsp;in&nbsp;the&nbsp;context<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;the&nbsp;moment.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = O". <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = S n'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;In&nbsp;the&nbsp;second&nbsp;subgoal&nbsp;generated&nbsp;by&nbsp;<span class="inlinecode"><span class="id" type="tactic">induction</span></span>&nbsp;--&nbsp;the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"inductive&nbsp;step"&nbsp;--&nbsp;we&nbsp;must&nbsp;prove&nbsp;that&nbsp;<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span>&nbsp;implies&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span>&nbsp;for&nbsp;all&nbsp;<span class="inlinecode"><span class="id" type="var">n'</span></span>.&nbsp;&nbsp;The&nbsp;<span class="inlinecode"><span class="id" type="tactic">induction</span></span>&nbsp;tactic&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;automatically&nbsp;introduces&nbsp;<span class="inlinecode"><span class="id" type="var">n'</span></span>&nbsp;and&nbsp;<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span>&nbsp;into&nbsp;the&nbsp;context<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;us,&nbsp;leaving&nbsp;just&nbsp;<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span>&nbsp;as&nbsp;the&nbsp;goal.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">IHn'</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
It also works to apply <span class="inlinecode"><span class="id" type="tactic">induction</span></span> to a variable that is
   quantified in the goal. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="plus_comm'"><span class="id" type="lemma">plus_comm'</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="inductive">nat</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> + <span class="id" type="var">m</span> = <span class="id" type="var">m</span> + <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = O". <span class="id" type="tactic">intros</span> <span class="id" type="var">m</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Basics.html#plus_0_r"><span class="id" type="lemma">plus_0_r</span></a>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = S n'". <span class="id" type="tactic">intros</span> <span class="id" type="var">m</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">IHn'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&larr;</span> <a class="idref" href="Basics.html#plus_n_Sm"><span class="id" type="axiom">plus_n_Sm</span></a>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Note that <span class="inlinecode"><span class="id" type="tactic">induction</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> leaves <span class="inlinecode"><span class="id" type="var">m</span></span> still bound in the goal &mdash;
    i.e., what we are proving inductively is a statement beginning
    with <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span>.

<div class="paragraph"> </div>

    If we do <span class="inlinecode"><span class="id" type="tactic">induction</span></span> on a variable that is quantified in the goal
    <i>after</i> some other quantifiers, the <span class="inlinecode"><span class="id" type="tactic">induction</span></span> tactic will
    automatically introduce the variables bound by these quantifiers
    into the context. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="plus_comm''"><span class="id" type="lemma">plus_comm''</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="inductive">nat</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> + <span class="id" type="var">m</span> = <span class="id" type="var">m</span> + <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Let's&nbsp;do&nbsp;induction&nbsp;on&nbsp;<span class="inlinecode"><span class="id" type="var">m</span></span>&nbsp;this&nbsp;time,&nbsp;instead&nbsp;of&nbsp;<span class="inlinecode"><span class="id" type="var">n</span></span>...&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">m</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">m'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "m = O". <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Basics.html#plus_0_r"><span class="id" type="lemma">plus_0_r</span></a>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "m = S m'". <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&larr;</span> <span class="id" type="var">IHm'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&larr;</span> <a class="idref" href="Basics.html#plus_n_Sm"><span class="id" type="axiom">plus_n_Sm</span></a>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab194"></a><h4 class="section">Exercise: 1 star, optional (plus_explicit_prop)</h4>
 Rewrite both <span class="inlinecode"><span class="id" type="var">plus_assoc'</span></span> and <span class="inlinecode"><span class="id" type="var">plus_comm'</span></span> and their proofs in
    the same style as <span class="inlinecode"><span class="id" type="var">mult_0_r''</span></span> above &mdash; that is, for each theorem,
    give an explicit <span class="inlinecode"><span class="id" type="keyword">Definition</span></span> of the proposition being proved by
    induction, and state the theorem and proof in terms of this
    defined proposition.  
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 One more quick digression, for adventurous souls: if we can define 
    parameterized propositions using <span class="inlinecode"><span class="id" type="keyword">Definition</span></span>, then can we also
    define them using <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>?  Of course we can!  However, this
    kind of "recursive parameterization" doesn't correspond to
    anything very familiar from everyday mathematics.  The following
    exercise gives a slightly contrived example. 
<div class="paragraph"> </div>

<a name="lab195"></a><h4 class="section">Exercise: 4 stars, optional (true_upto_n__true_everywhere)</h4>
 Define a recursive function
    <span class="inlinecode"><span class="id" type="var">true_upto_n__true_everywhere</span></span> that makes
    <span class="inlinecode"><span class="id" type="var">true_upto_n_example</span></span> work. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;<br/>
Fixpoint&nbsp;true_upto_n__true_everywhere&nbsp;<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<br/>
Example&nbsp;true_upto_n_example&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(true_upto_n__true_everywhere&nbsp;3&nbsp;(fun&nbsp;n&nbsp;=&gt;&nbsp;even&nbsp;n))<br/>
&nbsp;&nbsp;=&nbsp;(even&nbsp;3&nbsp;-&gt;&nbsp;even&nbsp;2&nbsp;-&gt;&nbsp;even&nbsp;1&nbsp;-&gt;&nbsp;forall&nbsp;m&nbsp;:&nbsp;nat,&nbsp;even&nbsp;m).<br/>
Proof.&nbsp;reflexivity.&nbsp;&nbsp;Qed.<br/>
*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab196"></a><h2 class="section">Induction Principles in <span class="inlinecode"><span class="id" type="keyword">Prop</span></span></h2>

<div class="paragraph"> </div>

 Earlier, we looked in detail at the induction principles that Coq
    generates for inductively defined <i>sets</i>.  The induction principles
    for inductively defined <i>propositions</i> like <span class="inlinecode"><span class="id" type="var">ev</span></span> are a tiny bit
    more complicated.  As with all induction principles, we want to use
    the induction principle on <span class="inlinecode"><span class="id" type="var">ev</span></span> to prove things by inductively
    considering the possible shapes that something in <span class="inlinecode"><span class="id" type="var">ev</span></span> can have &mdash;
    either it is evidence that <span class="inlinecode">0</span> is even, or it is evidence that,
    for some <span class="inlinecode"><span class="id" type="var">n</span></span>, <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> is even, and it includes evidence that <span class="inlinecode"><span class="id" type="var">n</span></span>
    itself is.  Intuitively speaking, however, what we want to prove
    are not statements about <i>evidence</i> but statements about <i>numbers</i>.
    So we want an induction principle that lets us prove properties of
    numbers by induction on evidence.

<div class="paragraph"> </div>

    For example, from what we've said so far, you might expect the
    inductive definition of <span class="inlinecode"><span class="id" type="var">ev</span></span>...

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Inductive</span>&nbsp;<span class="id" type="var">ev</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="keyword">Prop</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">ev_0</span>&nbsp;:&nbsp;<span class="id" type="var">ev</span>&nbsp;<span class="id" type="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">ev_SS</span>&nbsp;:&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>,&nbsp;<span class="id" type="var">ev</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">ev</span>&nbsp;(<span class="id" type="var">S</span>&nbsp;(<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">n</span>)).
<div class="paragraph"> </div>

</div>
    ...to give rise to an induction principle that looks like this...

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ev_ind_max</span>&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">P</span>&nbsp;:&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">n</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>,&nbsp;<span class="id" type="var">ev</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">O</span>&nbsp;<span class="id" type="var">ev_0</span>&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;(<span class="id" type="var">n</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>)&nbsp;(<span class="id" type="var">e</span>&nbsp;:&nbsp;<span class="id" type="var">ev</span>&nbsp;<span class="id" type="var">n</span>),&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">e</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">P</span>&nbsp;(<span class="id" type="var">S</span>&nbsp;(<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">n</span>))&nbsp;(<span class="id" type="var">ev_SS</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">e</span>))&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;(<span class="id" type="var">n</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>)&nbsp;(<span class="id" type="var">e</span>&nbsp;:&nbsp;<span class="id" type="var">ev</span>&nbsp;<span class="id" type="var">n</span>),&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">e</span>
<div class="paragraph"> </div>

</div>
    ... because:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Since <span class="inlinecode"><span class="id" type="var">ev</span></span> is indexed by a number <span class="inlinecode"><span class="id" type="var">n</span></span> (every <span class="inlinecode"><span class="id" type="var">ev</span></span> object
       <span class="inlinecode"><span class="id" type="var">e</span></span> is a piece of evidence that some particular number <span class="inlinecode"><span class="id" type="var">n</span></span>
       is even), the proposition <span class="inlinecode"><span class="id" type="var">P</span></span> is parameterized by both <span class="inlinecode"><span class="id" type="var">n</span></span>
       and <span class="inlinecode"><span class="id" type="var">e</span></span> &mdash; that is, the induction principle can be used to
       prove assertions involving both an even number and the
       evidence that it is even.

<div class="paragraph"> </div>


</li>
<li> Since there are two ways of giving evidence of evenness
       (<span class="inlinecode"><span class="id" type="var">ev</span></span> has two constructors), applying the induction
       principle generates two subgoals:

<div class="paragraph"> </div>

<ul class="doclist">
<li> We must prove that <span class="inlinecode"><span class="id" type="var">P</span></span> holds for <span class="inlinecode"><span class="id" type="var">O</span></span> and <span class="inlinecode"><span class="id" type="var">ev_0</span></span>.

<div class="paragraph"> </div>


</li>
<li> We must prove that, whenever <span class="inlinecode"><span class="id" type="var">n</span></span> is an even number and
           <span class="inlinecode"><span class="id" type="var">e</span></span> is evidence of its evenness, if <span class="inlinecode"><span class="id" type="var">P</span></span> holds of <span class="inlinecode"><span class="id" type="var">n</span></span>
           and <span class="inlinecode"><span class="id" type="var">e</span></span>, then it also holds of <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> and <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>
           <span class="inlinecode"><span class="id" type="var">e</span></span>.

<div class="paragraph"> </div>


</li>
</ul>

</li>
<li> If these subgoals can be proved, then the induction
       principle tells us that <span class="inlinecode"><span class="id" type="var">P</span></span> is true for <i>all</i> even numbers
       <span class="inlinecode"><span class="id" type="var">n</span></span> and evidence <span class="inlinecode"><span class="id" type="var">e</span></span> of their evenness.

</li>
</ul>

<div class="paragraph"> </div>

    But this is a little more flexibility than we actually need or
    want: it is giving us a way to prove logical assertions where the
    assertion involves properties of some piece of <i>evidence</i> of
    evenness, while all we really care about is proving properties of
    <i>numbers</i> that are even &mdash; we are interested in assertions about
    numbers, not about evidence.  It would therefore be more convenient
    to have an induction principle for proving propositions <span class="inlinecode"><span class="id" type="var">P</span></span> that
    are parameterized just by <span class="inlinecode"><span class="id" type="var">n</span></span> and whose conclusion establishes <span class="inlinecode"><span class="id" type="var">P</span></span>
    for all even numbers <span class="inlinecode"><span class="id" type="var">n</span></span>:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">P</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">n</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>,&nbsp;<span class="id" type="var">ev</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">n</span>
<div class="paragraph"> </div>

</div>
    For this reason, Coq actually generates the following simplified
    induction principle for <span class="inlinecode"><span class="id" type="var">ev</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Prop.html#ev_ind"><span class="id" type="definition">ev_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;&nbsp;ev_ind<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;0&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;ev&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;(S&nbsp;n)))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;ev&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
In particular, Coq has dropped the evidence term <span class="inlinecode"><span class="id" type="var">e</span></span> as a parameter
    of the the proposition <span class="inlinecode"><span class="id" type="var">P</span></span>, and consequently has rewritten the
    assumption <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode">(<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>)</span> <span class="inlinecode">(<span class="id" type="var">e</span>:<span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span>),</span> <span class="inlinecode">...</span> to be <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode">(<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>),</span> <span class="inlinecode"><span class="id" type="var">ev</span></span>
    <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode">...</span>; i.e., we no longer require explicit evidence of the
    provability of <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>. 
<div class="paragraph"> </div>

 In English, <span class="inlinecode"><span class="id" type="var">ev_ind</span></span> says:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Suppose, <span class="inlinecode"><span class="id" type="var">P</span></span> is a property of natural numbers (that is, <span class="inlinecode"><span class="id" type="var">P</span></span>
      <span class="inlinecode"><span class="id" type="var">n</span></span> is a <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> for every <span class="inlinecode"><span class="id" type="var">n</span></span>).  To show that <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> holds
      whenever <span class="inlinecode"><span class="id" type="var">n</span></span> is even, it suffices to show:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">P</span></span> holds for <span class="inlinecode">0</span>

<div class="paragraph"> </div>


</li>
<li> for any <span class="inlinecode"><span class="id" type="var">n</span></span>, if <span class="inlinecode"><span class="id" type="var">n</span></span> is even and <span class="inlinecode"><span class="id" type="var">P</span></span> holds for <span class="inlinecode"><span class="id" type="var">n</span></span>,
        then <span class="inlinecode"><span class="id" type="var">P</span></span> holds for <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span>. 
</li>
</ul>

</li>
</ul>

<div class="paragraph"> </div>

 We can apply <span class="inlinecode"><span class="id" type="var">ev_ind</span></span> directly instead of using <span class="inlinecode"><span class="id" type="tactic">induction</span></span>,
    following pretty much the same pattern as above. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="ev_even'"><span class="id" type="lemma">ev_even'</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#even"><span class="id" type="definition">even</span></a> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#ev_ind"><span class="id" type="definition">ev_ind</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "ev_0". <span class="id" type="tactic">unfold</span> <span class="id" type="var">even</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "ev_SS". <span class="id" type="tactic">intros</span> <span class="id" type="var">n'</span> <span class="id" type="var">E'</span> <span class="id" type="var">IHE'</span>. <span class="id" type="tactic">unfold</span> <span class="id" type="var">even</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHE'</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab197"></a><h4 class="section">Exercise: 3 stars, optional (prop_ind)</h4>
 Write out the induction principles that Coq will generate for the
    inductive declarations <span class="inlinecode"><span class="id" type="var">list</span></span> and <span class="inlinecode"><span class="id" type="var">MyProp</span></span>.  Compare your answers
    against the results Coq prints for the following queries. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Poly.html#list_ind"><span class="id" type="definition">list_ind</span></a>.<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Prop.html#MyProp_ind"><span class="id" type="definition">MyProp_ind</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab198"></a><h4 class="section">Exercise: 3 stars, optional (ev_MyProp')</h4>
 Prove <span class="inlinecode"><span class="id" type="var">ev_MyProp</span></span> again, using <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">MyProp_ind</span></span> instead
    of the <span class="inlinecode"><span class="id" type="tactic">induction</span></span> tactic. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="ev_MyProp'"><span class="id" type="lemma">ev_MyProp'</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>, <br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#MyProp"><span class="id" type="inductive">MyProp</span></a> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#MyProp_ind"><span class="id" type="definition">MyProp_ind</span></a>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab199"></a><h4 class="section">Exercise: 4 stars, optional (MyProp_pfobj)</h4>
 Prove <span class="inlinecode"><span class="id" type="var">MyProp_ev</span></span> and <span class="inlinecode"><span class="id" type="var">ev_MyProp</span></span> again by constructing
    explicit proof objects by hand (as you did above in
    <span class="inlinecode"><span class="id" type="var">ev_plus4</span></span>, for example). 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Module</span> <a name="P"><span class="id" type="module">P</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab200"></a><h4 class="section">Exercise: 3 stars, optional (p_provability)</h4>
 Consider the following inductively defined proposition: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="P.p"><span class="id" type="inductive">p</span></a> : (<a class="idref" href="Prop.html#P.tree"><span class="id" type="inductive">tree</span></a> <span class="id" type="inductive">nat</span>) <span style="font-family: arial;">&rarr;</span> <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;| <a name="P.c1"><span class="id" type="constructor">c1</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="Prop.html#p"><span class="id" type="inductive">p</span></a> (<a class="idref" href="Prop.html#P.leaf"><span class="id" type="constructor">leaf</span></a> <span class="id" type="var">_</span> <span class="id" type="var">n</span>) 1<br/>
&nbsp;&nbsp;&nbsp;| <a name="P.c2"><span class="id" type="constructor">c2</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">t1</span> <span class="id" type="var">t2</span> <span class="id" type="var">n1</span> <span class="id" type="var">n2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Prop.html#p"><span class="id" type="inductive">p</span></a> <span class="id" type="var">t1</span> <span class="id" type="var">n1</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#p"><span class="id" type="inductive">p</span></a> <span class="id" type="var">t2</span> <span class="id" type="var">n2</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#p"><span class="id" type="inductive">p</span></a> (<a class="idref" href="Prop.html#P.node"><span class="id" type="constructor">node</span></a> <span class="id" type="var">_</span> <span class="id" type="var">t1</span> <span class="id" type="var">t2</span>) (<span class="id" type="var">n1</span> + <span class="id" type="var">n2</span>)<br/>
&nbsp;&nbsp;&nbsp;| <a name="P.c3"><span class="id" type="constructor">c3</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">t</span> <span class="id" type="var">n</span>, <a class="idref" href="Prop.html#p"><span class="id" type="inductive">p</span></a> <span class="id" type="var">t</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#p"><span class="id" type="inductive">p</span></a> <span class="id" type="var">t</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>).<br/>

<br/>
</div>

<div class="doc">
Describe, in English, the conditions under which the
   proposition <span class="inlinecode"><span class="id" type="var">p</span></span> <span class="inlinecode"><span class="id" type="var">t</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> is provable. 

<div class="paragraph"> </div>

   <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
 <font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Prop.html#"><span class="id" type="module">P</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab201"></a><h1 class="section">Additional Exercises</h1>

<div class="paragraph"> </div>

<a name="lab202"></a><h4 class="section">Exercise: 4 stars (palindromes)</h4>
 A palindrome is a sequence that reads the same backwards as
    forwards.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Define an inductive proposition <span class="inlinecode"><span class="id" type="var">pal</span></span> on <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> that
      captures what it means to be a palindrome. (Hint: You'll need
      three cases.  Your definition should be based on the structure
      of the list; just having a single constructor

<div class="paragraph"> </div>

<div class="code code-tight">
<span class="id" type="var">c</span>&nbsp;:&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">l</span>&nbsp;=&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">pal</span>&nbsp;<span class="id" type="var">l</span>
<div class="paragraph"> </div>

</div>
      may seem obvious, but will not work very well.)

<div class="paragraph"> </div>


</li>
<li> Prove that 

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">pal</span>&nbsp;(<span class="id" type="var">l</span>&nbsp;++&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l</span>).
<div class="paragraph"> </div>

</div>

</li>
<li> Prove that 

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">pal</span>&nbsp;<span class="id" type="var">l</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">l</span>&nbsp;=&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l</span>.
<div class="paragraph"> </div>

</div>

</li>
</ul>

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab203"></a><h4 class="section">Exercise: 5 stars, optional (palindrome_converse)</h4>
 Using your definition of <span class="inlinecode"><span class="id" type="var">pal</span></span> from the previous exercise, prove
    that

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">l</span>&nbsp;=&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">pal</span>&nbsp;<span class="id" type="var">l</span>.
<div class="paragraph"> </div>

</div>

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab204"></a><h4 class="section">Exercise: 4 stars (subsequence)</h4>
 A list is a <i>subsequence</i> of another list if all of the elements
    in the first list occur in the same order in the second list,
    possibly with some extra elements in between. For example,

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;[1,2,3]
<div class="paragraph"> </div>

</div>
    is a subsequence of each of the lists

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;[1,2,3]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[1,1,1,2,2,3]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[1,2,7,3]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[5,6,1,9,9,2,7,3,8]
<div class="paragraph"> </div>

</div>
    but it is <i>not</i> a subsequence of any of the lists

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;[1,2]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[1,3]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[5,6,2,1,7,3,8]
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

<ul class="doclist">
<li> Define an inductive proposition <span class="inlinecode"><span class="id" type="var">subseq</span></span> on <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span> that
      captures what it means to be a subsequence. (Hint: You'll need
      three cases.)

<div class="paragraph"> </div>


</li>
<li> Prove that subsequence is reflexive, that is, any list is a
      subsequence of itself.  

<div class="paragraph"> </div>


</li>
<li> Prove that for any lists <span class="inlinecode"><span class="id" type="var">l1</span></span>, <span class="inlinecode"><span class="id" type="var">l2</span></span>, and <span class="inlinecode"><span class="id" type="var">l3</span></span>, if <span class="inlinecode"><span class="id" type="var">l1</span></span> is a
      subsequence of <span class="inlinecode"><span class="id" type="var">l2</span></span>, then <span class="inlinecode"><span class="id" type="var">l1</span></span> is also a subsequence of <span class="inlinecode"><span class="id" type="var">l2</span></span> <span class="inlinecode">++</span>
      <span class="inlinecode"><span class="id" type="var">l3</span></span>.

<div class="paragraph"> </div>


</li>
<li> (Optional, harder) Prove that subsequence is transitive &mdash; that
      is, if <span class="inlinecode"><span class="id" type="var">l1</span></span> is a subsequence of <span class="inlinecode"><span class="id" type="var">l2</span></span> and <span class="inlinecode"><span class="id" type="var">l2</span></span> is a subsequence
      of <span class="inlinecode"><span class="id" type="var">l3</span></span>, then <span class="inlinecode"><span class="id" type="var">l1</span></span> is a subsequence of <span class="inlinecode"><span class="id" type="var">l3</span></span>.  Hint: choose your
      induction carefully!

</li>
</ul>

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab205"></a><h4 class="section">Exercise: 2 stars, optional (foo_ind_principle)</h4>
 Suppose we make the following inductive definition:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Inductive</span>&nbsp;<span class="id" type="var">foo</span>&nbsp;(<span class="id" type="var">X</span>&nbsp;:&nbsp;<span class="id" type="keyword">Set</span>)&nbsp;(<span class="id" type="var">Y</span>&nbsp;:&nbsp;<span class="id" type="keyword">Set</span>)&nbsp;:&nbsp;<span class="id" type="keyword">Set</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">foo1</span>&nbsp;:&nbsp;<span class="id" type="var">X</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">foo</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">Y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">foo2</span>&nbsp;:&nbsp;<span class="id" type="var">Y</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">foo</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">Y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">foo3</span>&nbsp;:&nbsp;<span class="id" type="var">foo</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">Y</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">foo</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">Y</span>.
<div class="paragraph"> </div>

</div>
   Fill in the blanks to complete the induction principle that will be
   generated by Coq. 

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="var">foo_ind</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;(<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">Y</span>&nbsp;:&nbsp;<span class="id" type="keyword">Set</span>)&nbsp;(<span class="id" type="var">P</span>&nbsp;:&nbsp;<span class="id" type="var">foo</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">Y</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="keyword">Prop</span>),&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">x</span>&nbsp;:&nbsp;<span class="id" type="var">X</span>,&nbsp;<span class="id" type="var">__________________________________</span>)&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">y</span>&nbsp;:&nbsp;<span class="id" type="var">Y</span>,&nbsp;<span class="id" type="var">__________________________________</span>)&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">________________________________________________</span>)&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">________________________________________________</span>
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab206"></a><h4 class="section">Exercise: 2 stars, optional (bar_ind_principle)</h4>
 Consider the following induction principle:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="var">bar_ind</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">P</span>&nbsp;:&nbsp;<span class="id" type="var">bar</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">n</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;(<span class="id" type="var">bar1</span>&nbsp;<span class="id" type="var">n</span>))&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">b</span>&nbsp;:&nbsp;<span class="id" type="var">bar</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">b</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">P</span>&nbsp;(<span class="id" type="var">bar2</span>&nbsp;<span class="id" type="var">b</span>))&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;(<span class="id" type="var">b</span>&nbsp;:&nbsp;<span class="id" type="var">bool</span>)&nbsp;(<span class="id" type="var">b0</span>&nbsp;:&nbsp;<span class="id" type="var">bar</span>),&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">b0</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">P</span>&nbsp;(<span class="id" type="var">bar3</span>&nbsp;<span class="id" type="var">b</span>&nbsp;<span class="id" type="var">b0</span>))&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">b</span>&nbsp;:&nbsp;<span class="id" type="var">bar</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">b</span>
<div class="paragraph"> </div>

</div>
   Write out the corresponding inductive set definition.

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Inductive</span>&nbsp;<span class="id" type="var">bar</span>&nbsp;:&nbsp;<span class="id" type="keyword">Set</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">bar1</span>&nbsp;:&nbsp;<span class="id" type="var">________________________________________</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">bar2</span>&nbsp;:&nbsp;<span class="id" type="var">________________________________________</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">bar3</span>&nbsp;:&nbsp;<span class="id" type="var">________________________________________</span>.
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab207"></a><h4 class="section">Exercise: 2 stars, optional (no_longer_than_ind)</h4>
 Given the following inductively defined proposition:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="keyword">Inductive</span>&nbsp;<span class="id" type="var">no_longer_than</span>&nbsp;(<span class="id" type="var">X</span>&nbsp;:&nbsp;<span class="id" type="keyword">Set</span>)&nbsp;:&nbsp;(<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">X</span>)&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">nat</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="keyword">Prop</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">nlt_nil</span>&nbsp;&nbsp;:&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">n</span>,&nbsp;<span class="id" type="var">no_longer_than</span>&nbsp;<span class="id" type="var">X</span>&nbsp;[]&nbsp;<span class="id" type="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">nlt_cons</span>&nbsp;:&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">x</span>&nbsp;<span class="id" type="var">l</span>&nbsp;<span class="id" type="var">n</span>,&nbsp;<span class="id" type="var">no_longer_than</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">l</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">no_longer_than</span>&nbsp;<span class="id" type="var">X</span>&nbsp;(<span class="id" type="var">x</span>::<span class="id" type="var">l</span>)&nbsp;(<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">nlt_succ</span>&nbsp;:&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">l</span>&nbsp;<span class="id" type="var">n</span>,&nbsp;<span class="id" type="var">no_longer_than</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">l</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">no_longer_than</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">l</span>&nbsp;(<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">n</span>).
<div class="paragraph"> </div>

</div>
  write the induction principle generated by Coq.

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">no_longer_than_ind</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;(<span class="id" type="var">X</span>&nbsp;:&nbsp;<span class="id" type="keyword">Set</span>)&nbsp;(<span class="id" type="var">P</span>&nbsp;:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">nat</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">n</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>,&nbsp;<span class="id" type="var">____________________</span>)&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;(<span class="id" type="var">x</span>&nbsp;:&nbsp;<span class="id" type="var">X</span>)&nbsp;(<span class="id" type="var">l</span>&nbsp;:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">X</span>)&nbsp;(<span class="id" type="var">n</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">no_longer_than</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">l</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">____________________</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">_____________________________</span>&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;(<span class="id" type="var">l</span>&nbsp;:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">X</span>)&nbsp;(<span class="id" type="var">n</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">no_longer_than</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">l</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">____________________</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">_____________________________</span>&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;(<span class="id" type="var">l</span>&nbsp;:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">X</span>)&nbsp;(<span class="id" type="var">n</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>),&nbsp;<span class="id" type="var">no_longer_than</span>&nbsp;<span class="id" type="var">X</span>&nbsp;<span class="id" type="var">l</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">____________________</span>
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab208"></a><h4 class="section">Exercise: 2 stars, optional (R_provability)</h4>
 Suppose we give Coq the following definition:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Inductive</span>&nbsp;<span class="id" type="var">R</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">nat</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="keyword">Prop</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">c1</span>&nbsp;:&nbsp;<span class="id" type="var">R</span>&nbsp;0&nbsp;[]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">c2</span>&nbsp;:&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">R</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">l</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">R</span>&nbsp;(<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">n</span>)&nbsp;(<span class="id" type="var">n</span>&nbsp;::&nbsp;<span class="id" type="var">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">c3</span>&nbsp;:&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">R</span>&nbsp;(<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">n</span>)&nbsp;<span class="id" type="var">l</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">R</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">l</span>.
<div class="paragraph"> </div>

</div>
    Which of the following propositions are provable?

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">2</span> <span class="inlinecode">[1,0]</span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">1</span> <span class="inlinecode">[1,2,1,0]</span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">6</span> <span class="inlinecode">[3,2,1,0]</span>

</li>
</ul>

<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://www.lix.polytechnique.fr/coq/">coqdoc</a>
</div>

</div>

</body>
</html>