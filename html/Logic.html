<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Logic: Logic in Coq</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Logic<span class="subtitle">Logic in Coq</span></h1>

<div class="code code-tight">
</div>

<div class="doc">

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;$Date:&nbsp;2011-06-22&nbsp;10:06:32&nbsp;-0400&nbsp;(Wed,&nbsp;22&nbsp;Jun&nbsp;2011)&nbsp;$&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> "Prop".<br/>

<br/>
</div>

<div class="doc">
Coq's built-in logic is extremely small: <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> definitions,
    universal quantification (<span class="inlinecode"><span style="font-family: arial;">&forall;</span></span>), and implication (<span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span>) are
    primitive, but all the other familiar logical connectives &mdash;
    conjunction, disjunction, negation, existential quantification,
    even equality &mdash; can be defined using just these. 
<div class="paragraph"> </div>

<a name="lab209"></a><h1 class="section">Quantification and Implication</h1>

<div class="paragraph"> </div>

 In fact, <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> and <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> are the <i>same</i> primitive!  Coq's <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span>
    notation is actually just a shorthand for <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span>.  The <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span>
    notation is more general, because it allows us to <i>name</i> the
    hypothesis. 
<div class="paragraph"> </div>

 For example, consider this proposition: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="funny_prop1"><span class="id" type="definition">funny_prop1</span></a> := <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>, <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">E</span> : <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span>), <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<span class="id" type="var">n</span>+4).<br/>

<br/>
</div>

<div class="doc">
If we had a proof term inhabiting this proposition, it would be a
    function with two arguments: a number <span class="inlinecode"><span class="id" type="var">n</span></span> and some evidence that
    <span class="inlinecode"><span class="id" type="var">n</span></span> is even.  But the name <span class="inlinecode"><span class="id" type="var">E</span></span> for this evidence is not used in
    the rest of the statement of <span class="inlinecode"><span class="id" type="var">funny_prop1</span></span>, so it's a bit silly to
    bother making up a name.  We could write it like this instead: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="funny_prop1'"><span class="id" type="definition">funny_prop1'</span></a> := <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>, <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">_</span> : <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span>), <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<span class="id" type="var">n</span>+4).<br/>

<br/>
</div>

<div class="doc">
Or we can write it in more familiar notation: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="funny_prop1''"><span class="id" type="definition">funny_prop1''</span></a> := <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<span class="id" type="var">n</span>+4).<br/>

<br/>
</div>

<div class="doc">
This illustrates that "<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>" is just syntactic sugar for
    "<span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode">(<span class="id" type="var">_</span>:<span class="id" type="var">P</span>),</span> <span class="inlinecode"><span class="id" type="var">Q</span></span>". 
<div class="paragraph"> </div>

<a name="lab210"></a><h1 class="section">Conjunction</h1>

<div class="paragraph"> </div>

 The logical conjunction of propositions <span class="inlinecode"><span class="id" type="var">P</span></span> and <span class="inlinecode"><span class="id" type="var">Q</span></span> is
    represented using an <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> definition with one
    constructor. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="and"><span class="id" type="inductive">and</span></a> (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<a name="conj"><span class="id" type="constructor">conj</span></a> : <span class="id" type="var">P</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">&rarr;</span> (<a class="idref" href="Logic.html#and"><span class="id" type="inductive">and</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>).<br/>

<br/>
</div>

<div class="doc">
Note that, like the definition of <span class="inlinecode"><span class="id" type="var">ev</span></span> in the previous
    chapter, this definition is parameterized; however, in this case,
    the parameters are themselves propositions, rather than numbers. 
<div class="paragraph"> </div>

 The intuition behind this definition is simple: to
    construct evidence for <span class="inlinecode"><span class="id" type="var">and</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>, we must provide evidence
    for <span class="inlinecode"><span class="id" type="var">P</span></span> and evidence for <span class="inlinecode"><span class="id" type="var">Q</span></span>.  More precisely:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">conj</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span> <span class="inlinecode"><span class="id" type="var">q</span></span> can be taken as evidence for <span class="inlinecode"><span class="id" type="var">and</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span> if <span class="inlinecode"><span class="id" type="var">p</span></span>
      is evidence for <span class="inlinecode"><span class="id" type="var">P</span></span> and <span class="inlinecode"><span class="id" type="var">q</span></span> is evidence for <span class="inlinecode"><span class="id" type="var">Q</span></span>; and

<div class="paragraph"> </div>


</li>
<li> this is the <i>only</i> way to give evidence for <span class="inlinecode"><span class="id" type="var">and</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span> &mdash;
      that is, if someone gives us evidence for <span class="inlinecode"><span class="id" type="var">and</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>, we
      know it must have the form <span class="inlinecode"><span class="id" type="var">conj</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span> <span class="inlinecode"><span class="id" type="var">q</span></span>, where <span class="inlinecode"><span class="id" type="var">p</span></span> is
      evidence for <span class="inlinecode"><span class="id" type="var">P</span></span> and <span class="inlinecode"><span class="id" type="var">q</span></span> is evidence for <span class="inlinecode"><span class="id" type="var">Q</span></span>. 

</li>
</ul>

<div class="paragraph"> </div>

   Since we'll be using conjunction a lot, let's introduce a more
   familiar-looking infix notation for it. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> "P <span style="font-family: arial;">&and;</span> Q" := (<a class="idref" href="Logic.html#and"><span class="id" type="inductive">and</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) : <span class="id" type="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
(The <span class="inlinecode"><span class="id" type="var">type_scope</span></span> annotation tells Coq that this notation
    will be appearing in propositions, not values.) 
<div class="paragraph"> </div>

 Consider the "type" of the constructor <span class="inlinecode"><span class="id" type="var">conj</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Logic.html#conj"><span class="id" type="constructor">conj</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;&nbsp;forall&nbsp;P&nbsp;Q&nbsp;:&nbsp;Prop,&nbsp;P&nbsp;-&gt;&nbsp;Q&nbsp;-&gt;&nbsp;P&nbsp;/\&nbsp;Q&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Notice that it takes 4 inputs &mdash; namely the propositions <span class="inlinecode"><span class="id" type="var">P</span></span>
    and <span class="inlinecode"><span class="id" type="var">Q</span></span> and evidence for <span class="inlinecode"><span class="id" type="var">P</span></span> and <span class="inlinecode"><span class="id" type="var">Q</span></span> &mdash; and returns as output the
    evidence of <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>. 
<div class="paragraph"> </div>

 Besides the elegance of building everything up from a tiny
    foundation, what's nice about defining conjunction this way is
    that we can prove statements involving conjunction using the
    tactics that we already know.  For example, if the goal statement
    is a conjuction, we can prove it by applying the single
    constructor <span class="inlinecode"><span class="id" type="var">conj</span></span>, which (as can be seen from the type of <span class="inlinecode"><span class="id" type="var">conj</span></span>)
    solves the current goal and leaves the two parts of the
    conjunction as subgoals to be proved separately. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="and_example"><span class="id" type="lemma">and_example</span></a> : <br/>
&nbsp;&nbsp;(<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> 0) <span style="font-family: arial;">&and;</span> (<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> 4).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#conj"><span class="id" type="constructor">conj</span></a>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Case&nbsp;"left".&nbsp;*)</span> <span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#ev_0"><span class="id" type="constructor">ev_0</span></a>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Case&nbsp;"right".&nbsp;*)</span> <span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#ev_0"><span class="id" type="constructor">ev_0</span></a>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Let's take a look at the proof object for the above theorem. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">and_example</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;&nbsp;conj&nbsp;(ev&nbsp;0)&nbsp;(ev&nbsp;4)&nbsp;ev_0&nbsp;(ev_SS&nbsp;2&nbsp;(ev_SS&nbsp;0&nbsp;ev_0))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;ev&nbsp;0&nbsp;/\&nbsp;ev&nbsp;4&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Note that the proof is of the form

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">conj</span>&nbsp;(<span class="id" type="var">ev</span>&nbsp;0)&nbsp;(<span class="id" type="var">ev</span>&nbsp;4)&nbsp;(...<span class="id" type="var">pf</span>&nbsp;<span class="id" type="var">of</span>&nbsp;<span class="id" type="var">ev</span>&nbsp;0...)&nbsp;(...<span class="id" type="var">pf</span>&nbsp;<span class="id" type="var">of</span>&nbsp;<span class="id" type="var">ev</span>&nbsp;4...)
<div class="paragraph"> </div>

</div>
    which is what you'd expect, given the type of <span class="inlinecode"><span class="id" type="var">conj</span></span>. 
<div class="paragraph"> </div>

 Just for convenience, we can use the tactic <span class="inlinecode"><span class="id" type="tactic">split</span></span> as a shorthand for
    <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">conj</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="and_example'"><span class="id" type="lemma">and_example'</span></a> : <br/>
&nbsp;&nbsp;(<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> 0) <span style="font-family: arial;">&and;</span> (<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> 4).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "left". <span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#ev_0"><span class="id" type="constructor">ev_0</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "right". <span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#ev_0"><span class="id" type="constructor">ev_0</span></a>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Conversely, the <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> tactic can be used to take a
    conjunction hypothesis in the context, calculate what evidence
    must have been used to build it, and put this evidence into the
    proof context. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="proj1"><span class="id" type="lemma">proj1</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HQ</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab211"></a><h4 class="section">Exercise: 1 star, optional (proj2)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="proj2"><span class="id" type="lemma">proj2</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Q</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="and_commut"><span class="id" type="lemma">and_commut</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HQ</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Case&nbsp;"left".&nbsp;*)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">HQ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Case&nbsp;"right".*)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Once again, we have commented out the <span class="inlinecode"><span class="id" type="var">Case</span></span> tactics to make the
    proof object for this theorem easy to understand.  Examining it
    shows that all that is really happening is taking apart a record
    containing evidence for <span class="inlinecode"><span class="id" type="var">P</span></span> and <span class="inlinecode"><span class="id" type="var">Q</span></span> and rebuilding it in the
    opposite order: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">and_commut</span>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;&nbsp;and_commut&nbsp;=&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;(P&nbsp;Q&nbsp;:&nbsp;Prop)&nbsp;(H&nbsp;:&nbsp;P&nbsp;/\&nbsp;Q)&nbsp;=&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;H0&nbsp;:=&nbsp;match&nbsp;H&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;conj&nbsp;HP&nbsp;HQ&nbsp;=&gt;&nbsp;conj&nbsp;Q&nbsp;P&nbsp;HQ&nbsp;HP<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end&nbsp;in&nbsp;H0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;P&nbsp;Q&nbsp;:&nbsp;Prop,&nbsp;P&nbsp;/\&nbsp;Q&nbsp;-&gt;&nbsp;Q&nbsp;/\&nbsp;P&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<a name="lab212"></a><h4 class="section">Exercise: 2 stars (and_assoc)</h4>
 In the following proof, notice how the <i>nested pattern</i> in the
    <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> breaks <span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode">(<span class="id" type="var">Q</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode"><span class="id" type="var">R</span>)</span> down into <span class="inlinecode"><span class="id" type="var">HP</span>:</span> <span class="inlinecode"><span class="id" type="var">P</span></span>, <span class="inlinecode"><span class="id" type="var">HQ</span></span> <span class="inlinecode">:</span>
    <span class="inlinecode"><span class="id" type="var">Q</span></span>, and <span class="inlinecode"><span class="id" type="var">HR</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">R</span></span>.  Finish the proof from there: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="and_assoc"><span class="id" type="lemma">and_assoc</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&and;</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">R</span>) <span style="font-family: arial;">&rarr;</span> (<span class="id" type="var">P</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">&and;</span> <span class="id" type="var">R</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HP</span> [<span class="id" type="var">HQ</span> <span class="id" type="var">HR</span>]].<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab213"></a><h4 class="section">Exercise: 2 stars, recommended (even_ev)</h4>
 Now we can prove the other direction of the equivalence of <span class="inlinecode"><span class="id" type="var">even</span></span>
   and <span class="inlinecode"><span class="id" type="var">ev</span></span>, which we left hanging in the last chapter.  Notice that
   the left-hand conjunct here is the statement we are actually
   interested in; the right-hand conjunct is needed in order to make
   the induction hypothesis strong enough that we can carry out the
   reasoning in the inductive step.  (To see why this is needed, try
   proving the left conjunct by itself and observe where things get
   stuck.) 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="even_ev"><span class="id" type="lemma">even_ev</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> : <span class="id" type="inductive">nat</span>,<br/>
&nbsp;&nbsp;(<a class="idref" href="Prop.html#even"><span class="id" type="definition">even</span></a> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span>) <span style="font-family: arial;">&and;</span> (<a class="idref" href="Prop.html#even"><span class="id" type="definition">even</span></a> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>) <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Hint:&nbsp;Use&nbsp;induction&nbsp;on&nbsp;<span class="inlinecode"><span class="id" type="var">n</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab214"></a><h4 class="section">Exercise: 2 stars</h4>
 Construct a proof object demonstrating the following proposition. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="conj_fact"><span class="id" type="definition">conj_fact</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span>, <span class="id" type="var">P</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">R</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">R</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab215"></a><h2 class="section">Iff</h2>

<div class="paragraph"> </div>

 The familiar logical "if and only if" is just the
    conjunction of two implications. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="iff"><span class="id" type="definition">iff</span></a> (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>) := (<span class="id" type="var">P</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">&and;</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span>).<br/>

<br/>
<span class="id" type="keyword">Notation</span> "P <span style="font-family: arial;">&harr;</span> Q" := (<a class="idref" href="Logic.html#iff"><span class="id" type="definition">iff</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 95, <span class="id" type="var">no</span> <span class="id" type="var">associativity</span>) : <span class="id" type="var">type_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="iff_implies"><span class="id" type="lemma">iff_implies</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>, <br/>
&nbsp;&nbsp;(<span class="id" type="var">P</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Q</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HAB</span> <span class="id" type="var">HBA</span>]. <span class="id" type="tactic">apply</span> <span class="id" type="var">HAB</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="iff_sym"><span class="id" type="lemma">iff_sym</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>, <br/>
&nbsp;&nbsp;(<span class="id" type="var">P</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">&rarr;</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">P</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HAB</span> <span class="id" type="var">HBA</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "<span style="font-family: arial;">&rarr;</span>". <span class="id" type="tactic">apply</span> <span class="id" type="var">HBA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "<span style="font-family: arial;">&larr;</span>". <span class="id" type="tactic">apply</span> <span class="id" type="var">HAB</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab216"></a><h4 class="section">Exercise: 1 star (iff_properties)</h4>
 Using the above proof that <span class="inlinecode"><span style="font-family: arial;">&harr;</span></span> is symmetric (<span class="inlinecode"><span class="id" type="var">iff_sym</span></span>) as
    a guide, prove that it is also reflexive and transitive. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="iff_refl"><span class="id" type="lemma">iff_refl</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="iff_trans"><span class="id" type="lemma">iff_trans</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>, <br/>
&nbsp;&nbsp;(<span class="id" type="var">P</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">&rarr;</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">R</span>) <span style="font-family: arial;">&rarr;</span> (<span class="id" type="var">P</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">R</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Hint: If you have an iff hypothesis in the context, you can use
    <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> to break it into two separate implications.  (Think
    about why this works.)  <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab217"></a><h4 class="section">Exercise: 2 stars (MyProp_iff_ev)</h4>
 We have seen that the families of propositions <span class="inlinecode"><span class="id" type="var">MyProp</span></span> and <span class="inlinecode"><span class="id" type="var">ev</span></span>
    actually characterize the same set of numbers (the even ones).
    Prove that <span class="inlinecode"><span class="id" type="var">MyProp</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span style="font-family: arial;">&harr;</span></span> <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> for all <span class="inlinecode"><span class="id" type="var">n</span></span>.  Just for fun, write
    your proof as an explicit proof object, rather than using
    tactics. (<i>Hint</i>: if you make use of previously defined thoerems,
    you should only need a single line!) 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="MyProp_iff_ev"><span class="id" type="definition">MyProp_iff_ev</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="Prop.html#MyProp"><span class="id" type="inductive">MyProp</span></a> <span class="id" type="var">n</span> <span style="font-family: arial;">&harr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Some of Coq's tactics treat <span class="inlinecode"><span class="id" type="var">iff</span></span> statements specially, thus
    avoiding the need for some low-level manipulation when reasoning
    with them.  In particular, <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> can be used with <span class="inlinecode"><span class="id" type="var">iff</span></span>
    statements, not just equalities. 
<div class="paragraph"> </div>

<a name="lab218"></a><h1 class="section">Disjunction</h1>

<div class="paragraph"> </div>

 Disjunction ("logical or") can also be defined as an
    inductive proposition. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="or"><span class="id" type="inductive">or</span></a> (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="or_introl"><span class="id" type="constructor">or_introl</span></a> : <span class="id" type="var">P</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#or"><span class="id" type="inductive">or</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span><br/>
&nbsp;&nbsp;| <a name="or_intror"><span class="id" type="constructor">or_intror</span></a> : <span class="id" type="var">Q</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#or"><span class="id" type="inductive">or</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> "P <span style="font-family: arial;">&or;</span> Q" := (<a class="idref" href="Logic.html#or"><span class="id" type="inductive">or</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) : <span class="id" type="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
Consider the "type" of the constructor <span class="inlinecode"><span class="id" type="var">or_introl</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Logic.html#or_introl"><span class="id" type="constructor">or_introl</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;&nbsp;forall&nbsp;P&nbsp;Q&nbsp;:&nbsp;Prop,&nbsp;P&nbsp;-&gt;&nbsp;P&nbsp;\/&nbsp;Q&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
It takes 3 inputs, namely the propositions <span class="inlinecode"><span class="id" type="var">P</span></span>,<span class="inlinecode"><span class="id" type="var">Q</span></span> and
    evidence of <span class="inlinecode"><span class="id" type="var">P</span></span>, and returns as output, the evidence of <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>.
    Next, look at the type of <span class="inlinecode"><span class="id" type="var">or_intror</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Logic.html#or_intror"><span class="id" type="constructor">or_intror</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;&nbsp;forall&nbsp;P&nbsp;Q&nbsp;:&nbsp;Prop,&nbsp;Q&nbsp;-&gt;&nbsp;P&nbsp;\/&nbsp;Q&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
It is like <span class="inlinecode"><span class="id" type="var">or_introl</span></span> but it requires evidence of <span class="inlinecode"><span class="id" type="var">Q</span></span>
    instead of evidence of <span class="inlinecode"><span class="id" type="var">P</span></span>. 
<div class="paragraph"> </div>

 Intuitively, there are two ways of giving evidence for <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&or;</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>:

<div class="paragraph"> </div>

<ul class="doclist">
<li> give evidence for <span class="inlinecode"><span class="id" type="var">P</span></span> (and say that it is <span class="inlinecode"><span class="id" type="var">P</span></span> you are giving
      evidence for! &mdash; this is the function of the <span class="inlinecode"><span class="id" type="var">or_introl</span></span>
      constructor), or

<div class="paragraph"> </div>


</li>
<li> give evidence for <span class="inlinecode"><span class="id" type="var">Q</span></span>, tagged with the <span class="inlinecode"><span class="id" type="var">or_intror</span></span>
      constructor. 
</li>
</ul>

<div class="paragraph"> </div>

 Since <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&or;</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span> has two constructors, doing <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> on a
    hypothesis of type <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&or;</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span> yields two subgoals. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="or_commut"><span class="id" type="lemma">or_commut</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">Q</span>  <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HP</span> | <span class="id" type="var">HQ</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "right". <span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#or_intror"><span class="id" type="constructor">or_intror</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "left". <span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#or_introl"><span class="id" type="constructor">or_introl</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">HQ</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
From here on, we'll use the shorthand tactics <span class="inlinecode"><span class="id" type="var">left</span></span> and <span class="inlinecode"><span class="id" type="var">right</span></span>
    in place of <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">or_introl</span></span> and <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">or_intror</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="or_commut'"><span class="id" type="lemma">or_commut'</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">Q</span>  <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HP</span> | <span class="id" type="var">HQ</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "right". <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "left". <span class="id" type="var">left</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">HQ</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab219"></a><h4 class="section">Exercise: 2 stars, optional (or_commut'')</h4>
 Try to write down an explicit proof object for <span class="inlinecode"><span class="id" type="var">or_commut</span></span> (without
    using <span class="inlinecode"><span class="id" type="keyword">Print</span></span> to peek at the ones we already defined!). 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="or_distributes_over_and_1"><span class="id" type="lemma">or_distributes_over_and_1</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">R</span>) <span style="font-family: arial;">&rarr;</span> (<span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">&and;</span> (<span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">R</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HP</span> | [<span class="id" type="var">HQ</span> <span class="id" type="var">HR</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "left". <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "left". <span class="id" type="var">left</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "right". <span class="id" type="var">left</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "right". <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "left". <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">HQ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "right". <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">HR</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab220"></a><h4 class="section">Exercise: 2 stars, recommended (or_distributes_over_and_2)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="or_distributes_over_and_2"><span class="id" type="lemma">or_distributes_over_and_2</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">&and;</span> (<span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">R</span>) <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">R</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab221"></a><h4 class="section">Exercise: 1 star (or_distributes_over_and)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="or_distributes_over_and"><span class="id" type="lemma">or_distributes_over_and</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">R</span>) <span style="font-family: arial;">&harr;</span> (<span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">&and;</span> (<span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">R</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab222"></a><h2 class="section">Relating <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> and <span class="inlinecode"><span style="font-family: arial;">&or;</span></span> with <span class="inlinecode"><span class="id" type="var">andb</span></span> and <span class="inlinecode"><span class="id" type="var">orb</span></span></h2>

<div class="paragraph"> </div>

 We've already seen several places where analogous structures
    can be found in Coq's computational (<span class="inlinecode"><span class="id" type="keyword">Type</span></span>) and logical (<span class="inlinecode"><span class="id" type="keyword">Prop</span></span>)
    worlds.  Here is one more: the boolean operators <span class="inlinecode"><span class="id" type="var">andb</span></span> and <span class="inlinecode"><span class="id" type="var">orb</span></span>
    are obviously analogs, in some sense, of the logical connectives
    <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> and <span class="inlinecode"><span style="font-family: arial;">&or;</span></span>.  This analogy can be made more precise by the
    following theorems, which show how to translate knowledge about
    <span class="inlinecode"><span class="id" type="var">andb</span></span> and <span class="inlinecode"><span class="id" type="var">orb</span></span>'s behaviors on certain inputs into propositional
    facts about those inputs. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="andb_true__and"><span class="id" type="lemma">andb_true__and</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#andb"><span class="id" type="definition">andb</span></a> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">b</span> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&and;</span> <span class="id" type="var">c</span> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "b = true". <span class="id" type="tactic">destruct</span> <span class="id" type="var">c</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "c = true". <span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#conj"><span class="id" type="constructor">conj</span></a>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "c = false". <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "b = false". <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="and__andb_true"><span class="id" type="lemma">and__andb_true</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">b</span> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&and;</span> <span class="id" type="var">c</span> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Basics.html#andb"><span class="id" type="definition">andb</span></a> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">H0</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H1</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab223"></a><h4 class="section">Exercise: 1 star (bool_prop)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="andb_false"><span class="id" type="lemma">andb_false</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#andb"><span class="id" type="definition">andb</span></a> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">b</span> = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a> <span style="font-family: arial;">&or;</span> <span class="id" type="var">c</span> = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="orb_true"><span class="id" type="lemma">orb_true</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#orb"><span class="id" type="definition">orb</span></a> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">b</span> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&or;</span> <span class="id" type="var">c</span> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="orb_false"><span class="id" type="lemma">orb_false</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#orb"><span class="id" type="definition">orb</span></a> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">b</span> = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a> <span style="font-family: arial;">&and;</span> <span class="id" type="var">c</span> = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab224"></a><h1 class="section">Falsehood</h1>

<div class="paragraph"> </div>

 Logical falsehood can be represented in Coq as an inductively
    defined proposition with no constructors. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="False"><span class="id" type="inductive">False</span></a> : <span class="id" type="keyword">Prop</span> := .<br/>

<br/>
</div>

<div class="doc">
Intuition: <span class="inlinecode"><span class="id" type="var">False</span></span> is a proposition for which there is no way
    to give evidence. 
<div class="paragraph"> </div>

<a name="lab225"></a><h4 class="section">Exercise: 1 star (False_ind_principle)</h4>
 Can you predict the induction principle for falsehood? 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;Check&nbsp;False_ind.&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Since <span class="inlinecode"><span class="id" type="var">False</span></span> has no constructors, inverting an assumption
    of type <span class="inlinecode"><span class="id" type="var">False</span></span> always yields zero subgoals, allowing us to
    immediately prove any goal. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="False_implies_nonsense"><span class="id" type="lemma">False_implies_nonsense</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#False"><span class="id" type="inductive">False</span></a> <span style="font-family: arial;">&rarr;</span> 2 + 2 = 5.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">contra</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">contra</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
How does this work? The <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> tactic breaks <span class="inlinecode"><span class="id" type="var">contra</span></span> into
    each of its possible cases, and yields a subgoal for each case.
    As <span class="inlinecode"><span class="id" type="var">contra</span></span> is evidence for <span class="inlinecode"><span class="id" type="var">False</span></span>, it has <i>no</i> possible cases,
    hence, there are no possible subgoals and the proof is done. 
<div class="paragraph"> </div>

 Conversely, the only way to prove <span class="inlinecode"><span class="id" type="var">False</span></span> is if there is already
    something nonsensical or contradictory in the context: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="nonsense_implies_False"><span class="id" type="lemma">nonsense_implies_False</span></a> :<br/>
&nbsp;&nbsp;2 + 2 = 5 <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#False"><span class="id" type="inductive">False</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">contra</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">contra</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Actually, since the proof of <span class="inlinecode"><span class="id" type="var">False_implies_nonsense</span></span>
    doesn't actually have anything to do with the specific nonsensical
    thing being proved; it can easily be generalized to work for an
    arbitrary <span class="inlinecode"><span class="id" type="var">P</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="ex_falso_quodlibet"><span class="id" type="lemma">ex_falso_quodlibet</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">P</span>:<span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#False"><span class="id" type="inductive">False</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">contra</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">contra</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The Latin <i>ex falso quodlibet</i> means, literally, "from
    falsehood follows whatever you please."  This theorem is also
    known as the <i>principle of explosion</i>. 
<div class="paragraph"> </div>

<a name="lab226"></a><h2 class="section">Truth</h2>

<div class="paragraph"> </div>

 Since we have defined falsehood in Coq, we might wonder whether it
    is possible to define truth in the same way.  Naturally, the
    answer is yes. 
<div class="paragraph"> </div>

<a name="lab227"></a><h4 class="section">Exercise: 2 stars (True_induction)</h4>
 Define <span class="inlinecode"><span class="id" type="var">True</span></span> as another inductively defined proposition.  What
    induction principle will Coq generate for your definition?  (The
    intution is that <span class="inlinecode"><span class="id" type="var">True</span></span> should be a proposition for which it is
    trivial to give evidence.  Alternatively, you may find it easiest
    to start with the induction principle and work backwards to the
    inductive definition.) 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 However, unlike <span class="inlinecode"><span class="id" type="var">False</span></span>, which we'll use extensively, <span class="inlinecode"><span class="id" type="var">True</span></span> is
    just a theoretical curiosity: it is trivial (and therefore
    uninteresting) to prove as a goal, and it carries no useful
    information as a hypothesis. 
<div class="paragraph"> </div>

<a name="lab228"></a><h1 class="section">Negation</h1>

<div class="paragraph"> </div>

 The logical complement of a proposition <span class="inlinecode"><span class="id" type="var">P</span></span> is written <span class="inlinecode"><span class="id" type="var">not</span></span>
    <span class="inlinecode"><span class="id" type="var">P</span></span> or, for shorthand, <span class="inlinecode">~<span class="id" type="var">P</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="not"><span class="id" type="definition">not</span></a> (<span class="id" type="var">P</span>:<span class="id" type="keyword">Prop</span>) := <span class="id" type="var">P</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#False"><span class="id" type="inductive">False</span></a>.<br/>

<br/>
</div>

<div class="doc">
The intuition is that, if <span class="inlinecode"><span class="id" type="var">P</span></span> is not true, then anything at
    all (even <span class="inlinecode"><span class="id" type="var">False</span></span>) follows from assuming <span class="inlinecode"><span class="id" type="var">P</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> "~ x" := (<a class="idref" href="Logic.html#not"><span class="id" type="definition">not</span></a> <span class="id" type="var">x</span>) : <span class="id" type="var">type_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Logic.html#not"><span class="id" type="definition">not</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Prop&nbsp;-&gt;&nbsp;Prop&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
It takes a little practice to get used to working with
    negation in Coq.  Even though you can see perfectly well why
    something is true, it can be a little hard at first to get things
    into the right configuration so that Coq can see it!  Here are
    proofs of a few familiar facts about negation to get you warmed
    up. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="not_False"><span class="id" type="lemma">not_False</span></a> : <br/>
&nbsp;&nbsp;~ <a class="idref" href="Logic.html#False"><span class="id" type="inductive">False</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="contradiction_implies_anything"><span class="id" type="lemma">contradiction_implies_anything</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="var">P</span> <span style="font-family: arial;">&and;</span> ~<span class="id" type="var">P</span>) <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Q</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HNA</span>]. <span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span> <span class="id" type="keyword">in</span> <span class="id" type="var">HNA</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">HNA</span> <span class="id" type="keyword">in</span> <span class="id" type="var">HP</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">HP</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="double_neg"><span class="id" type="lemma">double_neg</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&rarr;</span> ~~<span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">G</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">G</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab229"></a><h4 class="section">Exercise: 2 stars, recommended (double_neg_inf)</h4>
 Write an informal proof of <span class="inlinecode"><span class="id" type="var">double_neg</span></span>:

<div class="paragraph"> </div>

   <i>Theorem</i>: <span class="inlinecode"><span class="id" type="var">P</span></span> implies <span class="inlinecode">~~<span class="id" type="var">P</span></span>, for any proposition <span class="inlinecode"><span class="id" type="var">P</span></span>.

<div class="paragraph"> </div>

   <i>Proof</i>:
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
   <font size=-2>&#9744;</font>

<div class="paragraph"> </div>

<a name="lab230"></a><h4 class="section">Exercise: 2 stars, recommended (contrapositive)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="contrapositive"><span class="id" type="lemma">contrapositive</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="var">P</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">&rarr;</span> (~<span class="id" type="var">Q</span> <span style="font-family: arial;">&rarr;</span> ~<span class="id" type="var">P</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab231"></a><h4 class="section">Exercise: 1 star (not_both_true_and_false)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="not_both_true_and_false"><span class="id" type="lemma">not_both_true_and_false</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;~ (<span class="id" type="var">P</span> <span style="font-family: arial;">&and;</span> ~<span class="id" type="var">P</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="five_not_even"><span class="id" type="lemma">five_not_even</span></a> :  <br/>
&nbsp;&nbsp;~ <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> 5.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">Hev5</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">Hev5</span> <span class="id" type="keyword">as</span> [|<span class="id" type="var">n</span> <span class="id" type="var">Hev3</span> <span class="id" type="var">Heqn</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">Hev3</span> <span class="id" type="keyword">as</span> [|<span class="id" type="var">n'</span> <span class="id" type="var">Hev1</span> <span class="id" type="var">Heqn'</span>]. <span class="id" type="tactic">inversion</span> <span class="id" type="var">Hev1</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab232"></a><h4 class="section">Exercise: 1 star ev_not_ev_S</h4>
 Theorem <span class="inlinecode"><span class="id" type="var">five_not_even</span></span> confirms the unsurprising fact that five
    is not an even number.  Prove this more interesting fact: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="ev_not_ev_S"><span class="id" type="lemma">ev_not_ev_S</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> ~ <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">H</span>. <span class="comment">(*&nbsp;not&nbsp;n!&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab233"></a><h4 class="section">Exercise: 1 star (informal_not_PNP)</h4>
 Write an informal proof (in English) of the proposition <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span>
    <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span>,</span> <span class="inlinecode">~(<span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode">~<span class="id" type="var">P</span>)</span>. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Note that some theorems that are true in classical logic
    are <i>not</i> provable in Coq's "built in" constructive logic... 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="classic_double_neg"><span class="id" type="lemma">classic_double_neg</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;~~<span class="id" type="var">P</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;But&nbsp;now&nbsp;what?&nbsp;There&nbsp;is&nbsp;no&nbsp;way&nbsp;to&nbsp;"invent"&nbsp;evidence&nbsp;for&nbsp;<span class="inlinecode"><span class="id" type="var">P</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab234"></a><h4 class="section">Exercise: 5 stars, optional (classical_axioms)</h4>
 For those who like a challenge, here is an exercise
    taken from the Coq'Art book (p. 123).  The following five
    statements are often considered as characterizations of
    classical logic (as opposed to constructive logic, which is
    what is "built in" to Coq).  We can't prove them in Coq, but
    we can consistently add any one of them as an unproven axiom
    if we wish to work in classical logic.  Prove that these five
    propositions are equivalent. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="peirce"><span class="id" type="definition">peirce</span></a> := <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>: <span class="id" type="keyword">Prop</span>, <br/>
&nbsp;&nbsp;((<span class="id" type="var">P</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">Q</span>)<span style="font-family: arial;">&rarr;</span><span class="id" type="var">P</span>)<span style="font-family: arial;">&rarr;</span><span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Definition</span> <a name="classic"><span class="id" type="definition">classic</span></a> := <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span>:<span class="id" type="keyword">Prop</span>, <br/>
&nbsp;&nbsp;~~<span class="id" type="var">P</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Definition</span> <a name="excluded_middle"><span class="id" type="definition">excluded_middle</span></a> := <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span>:<span class="id" type="keyword">Prop</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> <span style="font-family: arial;">&or;</span> ~<span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Definition</span> <a name="de_morgan_not_and_not"><span class="id" type="definition">de_morgan_not_and_not</span></a> := <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>:<span class="id" type="keyword">Prop</span>, <br/>
&nbsp;&nbsp;~(~<span class="id" type="var">P</span>/\~<span class="id" type="var">Q</span>) <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span><span style="font-family: arial;">&or;</span><span class="id" type="var">Q</span>.<br/>
<span class="id" type="keyword">Definition</span> <a name="implies_to_or"><span class="id" type="definition">implies_to_or</span></a> := <span style="font-family: arial;">&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>:<span class="id" type="keyword">Prop</span>, <br/>
&nbsp;&nbsp;(<span class="id" type="var">P</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">Q</span>) <span style="font-family: arial;">&rarr;</span> (~<span class="id" type="var">P</span><span style="font-family: arial;">&or;</span><span class="id" type="var">Q</span>).<br/>

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab235"></a><h2 class="section">Inequality</h2>

<div class="paragraph"> </div>

 Saying <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">&lt;&gt;</span> <span class="inlinecode"><span class="id" type="var">y</span></span> is just the same as saying <span class="inlinecode">~(<span class="id" type="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">y</span>)</span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> "x &lt;&gt; y" := (~ (<span class="id" type="var">x</span> = <span class="id" type="var">y</span>)) : <span class="id" type="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
Since inequality involves a negation, it again requires
    a little practice to be able to work with it fluently.  Here
    is one very useful trick.  If you are trying to prove a goal
    that is nonsensical (e.g., the goal state is <span class="inlinecode"><span class="id" type="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span>),
    apply the lemma <span class="inlinecode"><span class="id" type="var">ex_falso_quodlibet</span></span> to change the goal to
    <span class="inlinecode"><span class="id" type="var">False</span></span>.  This makes it easier to use assumptions of the form
    <span class="inlinecode">~<span class="id" type="var">P</span></span> that are available in the context &mdash; in particular,
    assumptions of the form <span class="inlinecode"><span class="id" type="var">x</span>&lt;&gt;<span class="id" type="var">y</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="not_false_then_true"><span class="id" type="lemma">not_false_then_true</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">b</span> : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a>,<br/>
&nbsp;&nbsp;<span class="id" type="var">b</span> &lt;&gt; <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">b</span> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "b = true". <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "b = false".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#ex_falso_quodlibet"><span class="id" type="lemma">ex_falso_quodlibet</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab236"></a><h4 class="section">Exercise: 2 stars, recommended (not_eq_beq_false)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="not_eq_beq_false"><span class="id" type="lemma">not_eq_beq_false</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">n'</span> : <span class="id" type="inductive">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> &lt;&gt; <span class="id" type="var">n'</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">n'</span> = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab237"></a><h4 class="section">Exercise: 2 stars, optional (beq_false_not_eq)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="beq_false_not_eq"><span class="id" type="lemma">beq_false_not_eq</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a> = <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> &lt;&gt; <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab238"></a><h1 class="section">Existential Quantification</h1>

<div class="paragraph"> </div>

 Another critical logical connective is <i>existential
    quantification</i>.  We can capture what this means with the
    following definition: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="ex"><span class="id" type="inductive">ex</span></a> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">P</span> : <span class="id" type="var">X</span><span style="font-family: arial;">&rarr;</span><span class="id" type="keyword">Prop</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<a name="ex_intro"><span class="id" type="constructor">ex_intro</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">witness</span>:<span class="id" type="var">X</span>), <span class="id" type="var">P</span> <span class="id" type="var">witness</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#ex"><span class="id" type="inductive">ex</span></a> <span class="id" type="var">X</span> <span class="id" type="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
That is, <span class="inlinecode"><span class="id" type="var">ex</span></span> is a family of propositions indexed by a type <span class="inlinecode"><span class="id" type="var">X</span></span>
    and a property <span class="inlinecode"><span class="id" type="var">P</span></span> over <span class="inlinecode"><span class="id" type="var">X</span></span>.  In order to give evidence for the
    assertion "there exists an <span class="inlinecode"><span class="id" type="var">x</span></span> for which the property <span class="inlinecode"><span class="id" type="var">P</span></span> holds"
    we must actually name a <i>witness</i> &mdash; a specific value <span class="inlinecode"><span class="id" type="var">x</span></span> &mdash; and
    then give evidence for <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>, i.e., evidence that <span class="inlinecode"><span class="id" type="var">x</span></span> has the
    property <span class="inlinecode"><span class="id" type="var">P</span></span>. 

<div class="paragraph"> </div>

    For example, consider this existentially quantified proposition: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="some_nat_is_even"><span class="id" type="definition">some_nat_is_even</span></a> : <span class="id" type="keyword">Prop</span> := <br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#ex"><span class="id" type="inductive">ex</span></a> <span class="id" type="inductive">nat</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a>.<br/>

<br/>
</div>

<div class="doc">
To prove this proposition, we need to choose a particular number
    as witness &mdash; say, 4 &mdash; and give some evidence that that number is
    even. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="snie"><span class="id" type="definition">snie</span></a> : <a class="idref" href="Logic.html#some_nat_is_even"><span class="id" type="definition">some_nat_is_even</span></a> := <br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#ex_intro"><span class="id" type="constructor">ex_intro</span></a> <span class="id" type="var">_</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> 4 (<a class="idref" href="Prop.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> 2 (<a class="idref" href="Prop.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> 0 <a class="idref" href="Prop.html#ev_0"><span class="id" type="constructor">ev_0</span></a>)).<br/>

<br/>
</div>

<div class="doc">
Coq's notation definition facility can be used to introduce
    more familiar notation for writing existentially quantified
    propositions, exactly parallel to the built-in syntax for
    universally quantified propositions.  Instead of writing <span class="inlinecode"><span class="id" type="var">ex</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span>
    <span class="inlinecode"><span class="id" type="var">ev</span></span> to express the proposition that there exists some number that
    is even, for example, we can write <span class="inlinecode"><span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">x</span>:<span class="id" type="var">nat</span>,</span> <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>.  (It is
    not necessary to understand exactly how the <span class="inlinecode"><span class="id" type="keyword">Notation</span></span> definition
    works.) 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> "'exists' x , p" := (<a class="idref" href="Logic.html#ex"><span class="id" type="inductive">ex</span></a> <span class="id" type="var">_</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> =&gt; <span class="id" type="var">p</span>))<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 200, <span class="id" type="var">x</span> <span class="id" type="var">ident</span>, <span class="id" type="var">right</span> <span class="id" type="var">associativity</span>) : <span class="id" type="var">type_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> "'exists' x : X , p" := (<a class="idref" href="Logic.html#ex"><span class="id" type="inductive">ex</span></a> <span class="id" type="var">_</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span>:<span class="id" type="var">X</span> =&gt; <span class="id" type="var">p</span>))<br/>
&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 200, <span class="id" type="var">x</span> <span class="id" type="var">ident</span>, <span class="id" type="var">right</span> <span class="id" type="var">associativity</span>) : <span class="id" type="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
We can use the same set of tactics as always for
    manipulating existentials.  For example, if to prove an
    existential, we <span class="inlinecode"><span class="id" type="tactic">apply</span></span> the constructor <span class="inlinecode"><span class="id" type="var">ex_intro</span></span>.  Since the
    premise of <span class="inlinecode"><span class="id" type="var">ex_intro</span></span> involves a variable (<span class="inlinecode"><span class="id" type="var">witness</span></span>) that does
    not appear in its conclusion, we need to explicitly give its value
    when we use <span class="inlinecode"><span class="id" type="tactic">apply</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="exists_example_1"><span class="id" type="definition">exists_example_1</span></a> : <span style="font-family: arial;">&exist;</span> <span class="id" type="var">n</span>, <span class="id" type="var">n</span> + (<span class="id" type="var">n</span> * <span class="id" type="var">n</span>) = 6.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#ex_intro"><span class="id" type="constructor">ex_intro</span></a> <span class="id" type="keyword">with</span> (<span class="id" type="var">witness</span>:=2).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Note, again, that we have to explicitly give the witness. 
<div class="paragraph"> </div>

 Or, instead of writing <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">ex_intro</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode">(<span class="id" type="var">witness</span>:=<span class="id" type="var">e</span>)</span> all the
    time, we can use the convenient shorthand <span class="inlinecode"><span style="font-family: arial;">&exist;</span></span> <span class="inlinecode"><span class="id" type="var">e</span></span>, which means
    the same thing. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="exists_example_1'"><span class="id" type="definition">exists_example_1'</span></a> : <span style="font-family: arial;">&exist;</span> <span class="id" type="var">n</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> + (<span class="id" type="var">n</span> * <span class="id" type="var">n</span>) = 6.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&exist;</span> 2.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Conversely, if we have an existential hypothesis in the
    context, we can eliminate it with <span class="inlinecode"><span class="id" type="tactic">inversion</span></span>.  Note the use
    of the <span class="inlinecode"><span class="id" type="keyword">as</span>...</span> pattern to name the variable that Coq
    introduces to name the witness value and get evidence that
    the hypothesis holds for the witness.  (If we don't
    explicitly choose one, Coq will just call it <span class="inlinecode"><span class="id" type="var">witness</span></span>, which
    makes proofs confusing.) 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="exists_example_2"><span class="id" type="lemma">exists_example_2</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&exist;</span> <span class="id" type="var">m</span>, <span class="id" type="var">n</span> = 4 + <span class="id" type="var">m</span>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&exist;</span> <span class="id" type="var">o</span>, <span class="id" type="var">n</span> = 2 + <span class="id" type="var">o</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">m</span> <span class="id" type="var">Hm</span>].<br/>
&nbsp;&nbsp;<span style="font-family: arial;">&exist;</span> (2 + <span class="id" type="var">m</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">Hm</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab239"></a><h4 class="section">Exercise: 1 star (english_exists)</h4>
 In English, what does the proposition 

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ex</span>&nbsp;<span class="id" type="var">nat</span>&nbsp;(<span class="id" type="keyword">fun</span>&nbsp;<span class="id" type="var">n</span>&nbsp;=&gt;&nbsp;<span class="id" type="var">ev</span>&nbsp;(<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">n</span>))
<div class="paragraph"> </div>

</div>
    mean? 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Complete the definition of the following proof object: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="p"><span class="id" type="definition">p</span></a> : <a class="idref" href="Logic.html#ex"><span class="id" type="inductive">ex</span></a> <span class="id" type="inductive">nat</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">n</span> =&gt; <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>)) :=<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab240"></a><h4 class="section">Exercise: 1 star (dist_not_exists)</h4>
 Prove that "<span class="inlinecode"><span class="id" type="var">P</span></span> holds for all <span class="inlinecode"><span class="id" type="var">x</span></span>" and "there is no <span class="inlinecode"><span class="id" type="var">x</span></span> for
    which <span class="inlinecode"><span class="id" type="var">P</span></span> does not hold" are equivalent assertions. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="dist_not_exists"><span class="id" type="lemma">dist_not_exists</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">P</span> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span> <span class="id" type="var">x</span>, <span class="id" type="var">P</span> <span class="id" type="var">x</span>) <span style="font-family: arial;">&rarr;</span> ~ (<span style="font-family: arial;">&exist;</span> <span class="id" type="var">x</span>, ~ <span class="id" type="var">P</span> <span class="id" type="var">x</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab241"></a><h4 class="section">Exercise: 3 stars, optional (not_exists_dist)</h4>
 The other direction requires the classical "law of the excluded
    middle": 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="not_exists_dist"><span class="id" type="lemma">not_exists_dist</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#excluded_middle"><span class="id" type="definition">excluded_middle</span></a> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">P</span> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;~ (<span style="font-family: arial;">&exist;</span> <span class="id" type="var">x</span>, ~ <span class="id" type="var">P</span> <span class="id" type="var">x</span>) <span style="font-family: arial;">&rarr;</span> (<span style="font-family: arial;">&forall;</span> <span class="id" type="var">x</span>, <span class="id" type="var">P</span> <span class="id" type="var">x</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab242"></a><h4 class="section">Exercise: 2 stars (dist_exists_or)</h4>
 Prove that existential quantification distributes over
    disjunction. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="dist_exists_or"><span class="id" type="lemma">dist_exists_or</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;(<span style="font-family: arial;">&exist;</span> <span class="id" type="var">x</span>, <span class="id" type="var">P</span> <span class="id" type="var">x</span> <span style="font-family: arial;">&or;</span> <span class="id" type="var">Q</span> <span class="id" type="var">x</span>) <span style="font-family: arial;">&harr;</span> (<span style="font-family: arial;">&exist;</span> <span class="id" type="var">x</span>, <span class="id" type="var">P</span> <span class="id" type="var">x</span>) <span style="font-family: arial;">&or;</span> (<span style="font-family: arial;">&exist;</span> <span class="id" type="var">x</span>, <span class="id" type="var">Q</span> <span class="id" type="var">x</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;Print&nbsp;dist_exists_or.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<a name="lab243"></a><h1 class="section">Equality</h1>

<div class="paragraph"> </div>

 Even Coq's equality relation is not built in.  It has the
    following inductive definition.  (We enclose the definition in a
    module to avoid confusion with the standard library equality,
    which we have used extensively already.) 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Module</span> <a name="MyEquality"><span class="id" type="module">MyEquality</span></a>.<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <a name="MyEquality.eq"><span class="id" type="inductive">eq</span></a> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<a name="MyEquality.refl_equal"><span class="id" type="constructor">refl_equal</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">x</span>, <a class="idref" href="Logic.html#eq"><span class="id" type="inductive">eq</span></a> <span class="id" type="var">X</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
Standard infix notation (using Coq's type argument synthesis): 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> "x = y" := (<a class="idref" href="Logic.html#MyEquality.eq"><span class="id" type="inductive">eq</span></a> <span class="id" type="var">_</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 70, <span class="id" type="var">no</span> <span class="id" type="var">associativity</span>) : <span class="id" type="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
This is a bit subtle.  The way to think about it is that, given a
    set <span class="inlinecode"><span class="id" type="var">X</span></span>, it defines a <i>family</i> of propositions "<span class="inlinecode"><span class="id" type="var">x</span></span> is equal to
    <span class="inlinecode"><span class="id" type="var">y</span></span>," indexed by pairs of values (<span class="inlinecode"><span class="id" type="var">x</span></span> and <span class="inlinecode"><span class="id" type="var">y</span></span>) from <span class="inlinecode"><span class="id" type="var">X</span></span>.  There is
    just one way of constructing evidence for members of this family:
    applying the constructor <span class="inlinecode"><span class="id" type="var">refl_equal</span></span> to a type <span class="inlinecode"><span class="id" type="var">X</span></span> and a value <span class="inlinecode"><span class="id" type="var">x</span></span>
    <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">X</span></span> yields evidence that <span class="inlinecode"><span class="id" type="var">x</span></span> is equal to <span class="inlinecode"><span class="id" type="var">x</span></span>. 
<div class="paragraph"> </div>

 Here is a slightly different definition &mdash; the one that actually
    appears in the Coq standard library. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="MyEquality.eq'"><span class="id" type="inductive">eq'</span></a> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">x</span>:<span class="id" type="var">X</span>) : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="MyEquality.refl_equal'"><span class="id" type="constructor">refl_equal'</span></a> : <a class="idref" href="Logic.html#eq'"><span class="id" type="inductive">eq'</span></a> <span class="id" type="var">X</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> "x =' y" := (<a class="idref" href="Logic.html#MyEquality.eq'"><span class="id" type="inductive">eq'</span></a> <span class="id" type="var">_</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 70, <span class="id" type="var">no</span> <span class="id" type="var">associativity</span>) : <span class="id" type="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab244"></a><h4 class="section">Exercise: 3 stars, optional (two_defs_of_eq_coincide)</h4>
 Verify that the two definitions of equality are equivalent. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="MyEquality.two_defs_of_eq_coincide"><span class="id" type="lemma">two_defs_of_eq_coincide</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">x</span> <span class="id" type="var">y</span> : <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">x</span> = <span class="id" type="var">y</span> <span style="font-family: arial;">&harr;</span> <span class="id" type="var">x</span> =' <span class="id" type="var">y</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 The advantage of the second definition is that the induction
    principle that Coq derives for it is precisely the familiar
    principle of <i>Leibniz equality</i>: what we mean when we say "<span class="inlinecode"><span class="id" type="var">x</span></span> and
    <span class="inlinecode"><span class="id" type="var">y</span></span> are equal" is that every property on <span class="inlinecode"><span class="id" type="var">P</span></span> that is true of <span class="inlinecode"><span class="id" type="var">x</span></span>
    is also true of <span class="inlinecode"><span class="id" type="var">y</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Logic.html#MyEquality.eq'_ind"><span class="id" type="definition">eq'_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;&nbsp;forall&nbsp;(X&nbsp;:&nbsp;Type)&nbsp;(x&nbsp;:&nbsp;X)&nbsp;(P&nbsp;:&nbsp;X&nbsp;-&gt;&nbsp;Prop),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;x&nbsp;-&gt;&nbsp;forall&nbsp;y&nbsp;:&nbsp;X,&nbsp;x&nbsp;='&nbsp;y&nbsp;-&gt;&nbsp;P&nbsp;y&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
One important consideration remains.  Clearly, we can use
    <span class="inlinecode"><span class="id" type="var">refl_equal</span></span> to construct evidence that, for example, <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">2</span>.
    Can we also use it to construct evidence that <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> <span class="inlinecode">=</span> <span class="inlinecode">2</span>?  Yes.
    Indeed, it is the very same piece of evidence!  The reason is that
    Coq treats as "the same" any two terms that are <i>convertible</i>
    according to a simple set of computation rules.  These rules,
    which are similar to those used by <span class="inlinecode"><span class="id" type="keyword">Eval</span></span> <span class="inlinecode"><span class="id" type="tactic">simpl</span></span>, include
    evaluation of function application, inlining of definitions, and
    simplification of <span class="inlinecode"><span class="id" type="keyword">match</span></span>es.

<div class="paragraph"> </div>

    In tactic-based proofs of equality, the conversion rules are
    normally hidden in uses of <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> (either explicit or implicit in
    other tactics such as <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>).  But you can see them
    directly at work in the following explicit proof objects: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="MyEquality.four"><span class="id" type="definition">four</span></a> : 2 + 2 = 1 + 3 :=  <br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#MyEquality.refl_equal"><span class="id" type="constructor">refl_equal</span></a> <span class="id" type="inductive">nat</span> 4.<br/>
<span class="id" type="keyword">Definition</span> <a name="MyEquality.singleton"><span class="id" type="definition">singleton</span></a> : <span style="font-family: arial;">&forall;</span> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Set</span>) (<span class="id" type="var">x</span>:<span class="id" type="var">X</span>), []++[<span class="id" type="var">x</span>] = <span class="id" type="var">x</span>::[]  :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Set</span>) (<span class="id" type="var">x</span>:<span class="id" type="var">X</span>) =&gt; <a class="idref" href="Logic.html#MyEquality.refl_equal"><span class="id" type="constructor">refl_equal</span></a> (<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) [<span class="id" type="var">x</span>].<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Logic.html#"><span class="id" type="module">MyEquality</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab245"></a><h2 class="section">Inversion, Again</h2>

<div class="paragraph"> </div>

 We've seen <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> used with both equality hypotheses and
    hypotheses about inductively defined propositions.  Now that we've
    seen that these are actually the same thing, we're in a position
    to take a closer look at how <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> behaves...

<div class="paragraph"> </div>

    In general, the <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> tactic

<div class="paragraph"> </div>

<ul class="doclist">
<li> takes a hypothesis <span class="inlinecode"><span class="id" type="var">H</span></span> whose type <span class="inlinecode"><span class="id" type="var">P</span></span> is inductively defined,
      and

<div class="paragraph"> </div>


</li>
<li> for each constructor <span class="inlinecode"><span class="id" type="var">C</span></span> in <span class="inlinecode"><span class="id" type="var">P</span></span>'s definition,

<div class="paragraph"> </div>

<ul class="doclist">
<li> generates a new subgoal in which we assume <span class="inlinecode"><span class="id" type="var">H</span></span> was
        built with <span class="inlinecode"><span class="id" type="var">C</span></span>,

<div class="paragraph"> </div>


</li>
<li> adds the arguments (premises) of <span class="inlinecode"><span class="id" type="var">C</span></span> to the context of
        the subgoal as extra hypotheses,

<div class="paragraph"> </div>


</li>
<li> matches the conclusion (result type) of <span class="inlinecode"><span class="id" type="var">C</span></span> against the
        current goal and calculates a set of equalities that must
        hold in order for <span class="inlinecode"><span class="id" type="var">C</span></span> to be applicable,

<div class="paragraph"> </div>


</li>
<li> adds these equalities to the context of the subgoal, and

<div class="paragraph"> </div>


</li>
<li> if the equalities are not satisfiable (e.g., they involve
        things like <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">O</span></span>), immediately solves the subgoal.

</li>
</ul>

</li>
</ul>

<div class="paragraph"> </div>

   <i>Example</i>: If we invert a hypothesis built with <span class="inlinecode"><span class="id" type="var">or</span></span>, there are two
   constructors, so two subgoals get generated.  The
   conclusion (result type) of the constructor (<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&or;</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>) doesn't
   place any restrictions on the form of <span class="inlinecode"><span class="id" type="var">P</span></span> or <span class="inlinecode"><span class="id" type="var">Q</span></span>, so we don't get
   any extra equalities in the context of the subgoal.

<div class="paragraph"> </div>

   <i>Example</i>: If we invert a hypothesis built with <span class="inlinecode"><span class="id" type="var">and</span></span>, there is
   only one constructor, so only one subgoal gets generated.  Again,
   the conclusion (result type) of the constructor (<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>) doesn't
   place any restrictions on the form of <span class="inlinecode"><span class="id" type="var">P</span></span> or <span class="inlinecode"><span class="id" type="var">Q</span></span>, so we don't get
   any extra equalities in the context of the subgoal.  The
   constructor does have two arguments, though, and these can be seen
   in the context in the subgoal.

<div class="paragraph"> </div>

   <i>Example</i>: If we invert a hypothesis built with <span class="inlinecode"><span class="id" type="var">eq</span></span>, there is
   again only one constructor, so only one subgoal gets generated.
   Now, though, the form of the <span class="inlinecode"><span class="id" type="var">refl_equal</span></span> constructor does give us
   some extra information: it tells us that the two arguments to <span class="inlinecode"><span class="id" type="var">eq</span></span>
   must be the same!  The <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> tactic adds this fact to the
   context.  
<div class="paragraph"> </div>

<a name="lab246"></a><h1 class="section">Relations as Propositions</h1>

<div class="paragraph"> </div>

 A proposition parameterized numbers (such as <span class="inlinecode"><span class="id" type="var">ev</span></span>) can be
    thought of as a <i>property</i> &mdash; i.e., it defines a subset of <span class="inlinecode"><span class="id" type="var">nat</span></span>,
    namely those numbers for which the proposition is provable.  In
    the same way, a two-argument proposition can be thought of as a
    <i>relation</i> &mdash; i.e., it defines a set of pairs for which the
    proposition is provable. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Module</span> <a name="LeFirstTry"><span class="id" type="module">LeFirstTry</span></a>.<br/>

<br/>
</div>

<div class="doc">
We've already seen an inductive definition of one
    fundamental relation: equality.  Another useful one is the "less
    than or equal to" relation on numbers: 
<div class="paragraph"> </div>

 This definition should be fairly intuitive.  It says that
    there are two ways to give evidence that one number is less than
    or equal to another: either observe that they are the same number,
    or give evidence that the first is less than or equal to the
    predecessor of the second. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="LeFirstTry.le"><span class="id" type="inductive">le</span></a> : <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="LeFirstTry.le_n"><span class="id" type="constructor">le_n</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="Logic.html#le"><span class="id" type="inductive">le</span></a> <span class="id" type="var">n</span> <span class="id" type="var">n</span><br/>
&nbsp;&nbsp;| <a name="LeFirstTry.le_S"><span class="id" type="constructor">le_S</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>, (<a class="idref" href="Logic.html#le"><span class="id" type="inductive">le</span></a> <span class="id" type="var">n</span> <span class="id" type="var">m</span>) <span style="font-family: arial;">&rarr;</span> (<a class="idref" href="Logic.html#le"><span class="id" type="inductive">le</span></a> <span class="id" type="var">n</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">m</span>)).<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Logic.html#"><span class="id" type="module">LeFirstTry</span></a>.<br/>

<br/>
</div>

<div class="doc">
This is a reasonable definition of the <span class="inlinecode">&lt;=</span> relation, but we
    can streamline it a little by observing that the left-hand
    argument <span class="inlinecode"><span class="id" type="var">n</span></span> is the same everywhere in the definition, so we can
    actually make it a "general parameter" to the whole definition,
    rather than an argument to each constructor.  This is similar to
    what we did in our second definition of the <span class="inlinecode"><span class="id" type="var">eq</span></span> relation,
    above. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="le"><span class="id" type="inductive">le</span></a> (<span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>) : <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="le_n"><span class="id" type="constructor">le_n</span></a> : <a class="idref" href="Logic.html#le"><span class="id" type="inductive">le</span></a> <span class="id" type="var">n</span> <span class="id" type="var">n</span><br/>
&nbsp;&nbsp;| <a name="le_S"><span class="id" type="constructor">le_S</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">m</span>, (<a class="idref" href="Logic.html#le"><span class="id" type="inductive">le</span></a> <span class="id" type="var">n</span> <span class="id" type="var">m</span>) <span style="font-family: arial;">&rarr;</span> (<a class="idref" href="Logic.html#le"><span class="id" type="inductive">le</span></a> <span class="id" type="var">n</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">m</span>)).<br/>

<br/>
<span class="id" type="keyword">Notation</span> "m &lt;= n" := (<a class="idref" href="Logic.html#le"><span class="id" type="inductive">le</span></a> <span class="id" type="var">m</span> <span class="id" type="var">n</span>).<br/>

<br/>
</div>

<div class="doc">
The second one is better, even though it looks less symmetric.
    Why?  Because it gives us a simpler induction principle. 
    (The same was true of our second version of <span class="inlinecode"><span class="id" type="var">eq</span></span>.) 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Logic.html#le_ind"><span class="id" type="definition">le_ind</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;&nbsp;forall&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;(P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;n&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;&lt;=&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;m))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n0&nbsp;:&nbsp;nat,&nbsp;n&nbsp;&lt;=&nbsp;n0&nbsp;-&gt;&nbsp;P&nbsp;n0&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
By contrast, the induction principle that Coq calculates for the
    first definition has a lot of extra quantifiers, which makes it
    messier to work with when proving things by induction.  Here is
    the induction principle for the first <span class="inlinecode"><span class="id" type="var">le</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;le_ind&nbsp;:&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;n)&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;(S&nbsp;m))&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;n0&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;n0&nbsp;-&gt;&nbsp;P&nbsp;n&nbsp;n0&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Proofs of facts about <span class="inlinecode">&lt;=</span> using the constructors <span class="inlinecode"><span class="id" type="var">le_n</span></span> and
    <span class="inlinecode"><span class="id" type="var">le_S</span></span> follow the same patterns as proofs about properties, like
    <span class="inlinecode"><span class="id" type="var">ev</span></span> in the previous chapter.  We can <span class="inlinecode"><span class="id" type="tactic">apply</span></span> the constructors to
    prove <span class="inlinecode">&lt;=</span> goals (e.g., to show that <span class="inlinecode">3&lt;=3</span> or <span class="inlinecode">3&lt;=6</span>), and we can
    use tactics like <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> to extract information from <span class="inlinecode">&lt;=</span>
    hypotheses in the context (e.g., to prove that <span class="inlinecode">~(2</span> <span class="inlinecode">&lt;=</span> <span class="inlinecode">1)</span>.) 
<div class="paragraph"> </div>

 Here are some sanity checks on the definition.  (Notice that,
    although these are the same kind of simple "unit tests" as we gave
    for the testing functions we wrote in the first few lectures, we
    must construct their proofs explicitly &mdash; <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> and
    <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> don't do the job, because the proofs aren't just a
    matter of simplifying computations. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="test_le1"><span class="id" type="lemma">test_le1</span></a> :<br/>
&nbsp;&nbsp;3 &lt;= 3.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#le_n"><span class="id" type="constructor">le_n</span></a>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="test_le2"><span class="id" type="lemma">test_le2</span></a> :<br/>
&nbsp;&nbsp;3 &lt;= 6.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#le_S"><span class="id" type="constructor">le_S</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#le_S"><span class="id" type="constructor">le_S</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#le_S"><span class="id" type="constructor">le_S</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#le_n"><span class="id" type="constructor">le_n</span></a>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="test_le3"><span class="id" type="lemma">test_le3</span></a> :<br/>
&nbsp;&nbsp;~ (2 &lt;= 1).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORKED&nbsp;IN&nbsp;CLASS&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H1</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The "strictly less than" relation <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" type="var">m</span></span> can now be defined
    in terms of <span class="inlinecode"><span class="id" type="var">le</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <a name="lt"><span class="id" type="definition">lt</span></a> (<span class="id" type="var">n</span> <span class="id" type="var">m</span>:<span class="id" type="inductive">nat</span>) := <a class="idref" href="Logic.html#le"><span class="id" type="inductive">le</span></a> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>) <span class="id" type="var">m</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> "m &lt; n" := (<a class="idref" href="Logic.html#lt"><span class="id" type="definition">lt</span></a> <span class="id" type="var">m</span> <span class="id" type="var">n</span>).<br/>

<br/>
</div>

<div class="doc">
Here are a few more simple relations on numbers: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="square_of"><span class="id" type="inductive">square_of</span></a> : <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<a name="sq"><span class="id" type="constructor">sq</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>, <a class="idref" href="Logic.html#square_of"><span class="id" type="inductive">square_of</span></a> <span class="id" type="var">n</span> (<span class="id" type="var">n</span> * <span class="id" type="var">n</span>).<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <a name="next_nat"><span class="id" type="inductive">next_nat</span></a> (<span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>) : <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="nn"><span class="id" type="constructor">nn</span></a> : <a class="idref" href="Logic.html#next_nat"><span class="id" type="inductive">next_nat</span></a> <span class="id" type="var">n</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>).<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <a name="next_even"><span class="id" type="inductive">next_even</span></a> (<span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>) : <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="ne_1"><span class="id" type="constructor">ne_1</span></a> : <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>) <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#next_even"><span class="id" type="inductive">next_even</span></a> <span class="id" type="var">n</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;| <a name="ne_2"><span class="id" type="constructor">ne_2</span></a> : <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> (<span class="id" type="constructor">S</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>)) <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#next_even"><span class="id" type="inductive">next_even</span></a> <span class="id" type="var">n</span> (<span class="id" type="constructor">S</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>)).<br/>

<br/>
</div>

<div class="doc">
<a name="lab247"></a><h4 class="section">Exercise: 2 stars, recommended (total_relation)</h4>
 Define an inductive relation <span class="inlinecode"><span class="id" type="var">total_relation</span></span> that holds
    between every pair of natural numbers. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab248"></a><h4 class="section">Exercise: 2 stars (empty_relation)</h4>
 Define an inductive relation <span class="inlinecode"><span class="id" type="var">empty_relation</span></span> (on numbers)
    that never holds. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab249"></a><h4 class="section">Exercise: 3 stars, recommended (R_provability)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Module</span> <a name="R"><span class="id" type="module">R</span></a>.<br/>
</div>

<div class="doc">
We can define three-place relations, four-place relations,
    etc., in just the same way as binary relations.  For example,
    consider the following three-place relation on numbers: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="R.R"><span class="id" type="inductive">R</span></a> : <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;| <a name="R.c1"><span class="id" type="constructor">c1</span></a> : <a class="idref" href="Logic.html#R"><span class="id" type="inductive">R</span></a> 0 0 0 <br/>
&nbsp;&nbsp;&nbsp;| <a name="R.c2"><span class="id" type="constructor">c2</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <a class="idref" href="Logic.html#R"><span class="id" type="inductive">R</span></a> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#R"><span class="id" type="inductive">R</span></a> (<span class="id" type="constructor">S</span> <span class="id" type="var">m</span>) <span class="id" type="var">n</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">o</span>)<br/>
&nbsp;&nbsp;&nbsp;| <a name="R.c3"><span class="id" type="constructor">c3</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <a class="idref" href="Logic.html#R"><span class="id" type="inductive">R</span></a> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#R"><span class="id" type="inductive">R</span></a> <span class="id" type="var">m</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>) (<span class="id" type="constructor">S</span> <span class="id" type="var">o</span>)<br/>
&nbsp;&nbsp;&nbsp;| <a name="R.c4"><span class="id" type="constructor">c4</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <a class="idref" href="Logic.html#R"><span class="id" type="inductive">R</span></a> (<span class="id" type="constructor">S</span> <span class="id" type="var">m</span>) (<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>) (<span class="id" type="constructor">S</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">o</span>)) <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#R"><span class="id" type="inductive">R</span></a> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span><br/>
&nbsp;&nbsp;&nbsp;| <a name="R.c5"><span class="id" type="constructor">c5</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <a class="idref" href="Logic.html#R"><span class="id" type="inductive">R</span></a> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#R"><span class="id" type="inductive">R</span></a> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> Which of the following propositions are provable?
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">1</span> <span class="inlinecode">1</span> <span class="inlinecode">2</span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">2</span> <span class="inlinecode">2</span> <span class="inlinecode">6</span>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


</li>
</ul>

</li>
<li> If we dropped constructor <span class="inlinecode"><span class="id" type="var">c5</span></span> from the definition of <span class="inlinecode"><span class="id" type="var">R</span></span>,
      would the set of provable propositions change?  Briefly (1
      sentence) explain your answer.

<div class="paragraph"> </div>


</li>
<li> If we dropped constructor <span class="inlinecode"><span class="id" type="var">c4</span></span> from the definition of <span class="inlinecode"><span class="id" type="var">R</span></span>,
      would the set of provable propositions change?  Briefly (1
      sentence) explain your answer.

</li>
</ul>

<div class="paragraph"> </div>

<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>

<div class="paragraph"> </div>

<a name="lab250"></a><h4 class="section">Exercise: 3 stars, optional (R_fact)</h4>
 State and prove an equivalent characterization of the relation
    <span class="inlinecode"><span class="id" type="var">R</span></span>.  That is, if <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">o</span></span> is true, what can we say about <span class="inlinecode"><span class="id" type="var">m</span></span>,
    <span class="inlinecode"><span class="id" type="var">n</span></span>, and <span class="inlinecode"><span class="id" type="var">o</span></span>, and vice versa?

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Logic.html#"><span class="id" type="module">R</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab251"></a><h4 class="section">Exercise: 3 stars, recommended (all_forallb)</h4>
 Inductively define a property <span class="inlinecode"><span class="id" type="var">all</span></span> of lists, parameterized by a
    type <span class="inlinecode"><span class="id" type="var">X</span></span> and a property <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">X</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>, such that <span class="inlinecode"><span class="id" type="var">all</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span>
    asserts that <span class="inlinecode"><span class="id" type="var">P</span></span> is true for every element of the list <span class="inlinecode"><span class="id" type="var">l</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="all"><span class="id" type="inductive">all</span></a> (<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">P</span> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>) : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
.<br/>

<br/>
</div>

<div class="doc">
Recall the function <span class="inlinecode"><span class="id" type="var">forallb</span></span>, from the exercise
<span class="inlinecode"><span class="id" type="var">forall_exists_challenge</span></span> in <span class="inlinecode"><span class="id" type="var">Poly.v</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="forallb"><span class="id" type="definition">forallb</span></a> {<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">test</span> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a>) (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [] =&gt; <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">x</span> :: <span class="id" type="var">l'</span> =&gt; <a class="idref" href="Basics.html#andb"><span class="id" type="definition">andb</span></a> (<span class="id" type="var">test</span> <span class="id" type="var">x</span>) (<a class="idref" href="Logic.html#forallb"><span class="id" type="definition">forallb</span></a> <span class="id" type="var">test</span> <span class="id" type="var">l'</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Using the property <span class="inlinecode"><span class="id" type="var">all</span></span>, write down a specification for <span class="inlinecode"><span class="id" type="var">forallb</span></span>,
    and prove that it satisfies the specification. Try to make your 
    specification as precise as possible.

<div class="paragraph"> </div>

    Are there any important properties of the function <span class="inlinecode"><span class="id" type="var">forallb</span></span> which
    are not captured by your specification? 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab252"></a><h4 class="section">Exercise: 4 stars, optional (filter_challenge)</h4>
 One of the main purposes of Coq is to prove that programs match
    their specifications.  To this end, let's prove that our
    definition of <span class="inlinecode"><span class="id" type="var">filter</span></span> matches a specification.  Here is the
    specification, written out informally in English.

<div class="paragraph"> </div>

    Suppose we have a set <span class="inlinecode"><span class="id" type="var">X</span></span>, a function <span class="inlinecode"><span class="id" type="var">test</span>:</span> <span class="inlinecode"><span class="id" type="var">X</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">bool</span></span>, and a list
    <span class="inlinecode"><span class="id" type="var">l</span></span> of type <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span>.  Suppose further that <span class="inlinecode"><span class="id" type="var">l</span></span> is an "in-order
    merge" of two lists, <span class="inlinecode"><span class="id" type="var">l1</span></span> and <span class="inlinecode"><span class="id" type="var">l2</span></span>, such that every item in <span class="inlinecode"><span class="id" type="var">l1</span></span>
    satisfies <span class="inlinecode"><span class="id" type="var">test</span></span> and no item in <span class="inlinecode"><span class="id" type="var">l2</span></span> satisfies test.  Then <span class="inlinecode"><span class="id" type="var">filter</span></span>
    <span class="inlinecode"><span class="id" type="var">test</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">l1</span></span>.

<div class="paragraph"> </div>

    A list <span class="inlinecode"><span class="id" type="var">l</span></span> is an "in-order merge" of <span class="inlinecode"><span class="id" type="var">l1</span></span> and <span class="inlinecode"><span class="id" type="var">l2</span></span> if it contains
    all the same elements as <span class="inlinecode"><span class="id" type="var">l1</span></span> and <span class="inlinecode"><span class="id" type="var">l2</span></span>, in the same order as <span class="inlinecode"><span class="id" type="var">l1</span></span>
    and <span class="inlinecode"><span class="id" type="var">l2</span></span>, but possibly interleaved.  For example, 

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;[1,4,6,2,3]
<div class="paragraph"> </div>

</div>
    is an in-order merge of

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;[1,6,2]
<div class="paragraph"> </div>

</div>
    and

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;[4,3].
<div class="paragraph"> </div>

</div>
    Your job is to translate this specification into a Coq theorem and
    prove it.  (Hint: You'll need to begin by defining what it means
    for one list to be a merge of two others.  Do this with an
    inductive relation, not a <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>.)  
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab253"></a><h4 class="section">Exercise: 5 stars, optional (filter_challenge_2)</h4>
 A different way to formally characterize the behavior of <span class="inlinecode"><span class="id" type="var">filter</span></span>
    goes like this: Among all subsequences of <span class="inlinecode"><span class="id" type="var">l</span></span> with the property
    that <span class="inlinecode"><span class="id" type="var">test</span></span> evaluates to <span class="inlinecode"><span class="id" type="var">true</span></span> on all their members, <span class="inlinecode"><span class="id" type="var">filter</span></span> <span class="inlinecode"><span class="id" type="var">test</span></span>
    <span class="inlinecode"><span class="id" type="var">l</span></span> is the longest.  Express this claim formally and prove it. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab254"></a><h4 class="section">Exercise: 4 stars, optional (no_repeats)</h4>
 The following inductively defined proposition... 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="appears_in"><span class="id" type="inductive">appears_in</span></a> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} (<span class="id" type="var">a</span>:<span class="id" type="var">X</span>) : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="ai_here"><span class="id" type="constructor">ai_here</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">l</span>, <a class="idref" href="Logic.html#appears_in"><span class="id" type="inductive">appears_in</span></a> <span class="id" type="var">a</span> (<span class="id" type="var">a</span>::<span class="id" type="var">l</span>)<br/>
&nbsp;&nbsp;| <a name="ai_later"><span class="id" type="constructor">ai_later</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">b</span> <span class="id" type="var">l</span>, <a class="idref" href="Logic.html#appears_in"><span class="id" type="inductive">appears_in</span></a> <span class="id" type="var">a</span> <span class="id" type="var">l</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#appears_in"><span class="id" type="inductive">appears_in</span></a> <span class="id" type="var">a</span> (<span class="id" type="var">b</span>::<span class="id" type="var">l</span>).<br/>

<br/>
</div>

<div class="doc">
...gives us a precise way of saying that a value <span class="inlinecode"><span class="id" type="var">a</span></span> appears at
    least once as a member of a list <span class="inlinecode"><span class="id" type="var">l</span></span>. 

<div class="paragraph"> </div>

    Here's a pair of warm-ups about <span class="inlinecode"><span class="id" type="var">appears_in</span></span>.

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="appears_in_app"><span class="id" type="lemma">appears_in_app</span></a> : <span style="font-family: arial;">&forall;</span> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} (<span class="id" type="var">xs</span> <span class="id" type="var">ys</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) (<span class="id" type="var">x</span>:<span class="id" type="var">X</span>), <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Logic.html#appears_in"><span class="id" type="inductive">appears_in</span></a> <span class="id" type="var">x</span> (<span class="id" type="var">xs</span> ++ <span class="id" type="var">ys</span>) <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#appears_in"><span class="id" type="inductive">appears_in</span></a> <span class="id" type="var">x</span> <span class="id" type="var">xs</span> <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#appears_in"><span class="id" type="inductive">appears_in</span></a> <span class="id" type="var">x</span> <span class="id" type="var">ys</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="app_appears_in"><span class="id" type="lemma">app_appears_in</span></a> : <span style="font-family: arial;">&forall;</span> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} (<span class="id" type="var">xs</span> <span class="id" type="var">ys</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>) (<span class="id" type="var">x</span>:<span class="id" type="var">X</span>), <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Logic.html#appears_in"><span class="id" type="inductive">appears_in</span></a> <span class="id" type="var">x</span> <span class="id" type="var">xs</span> <span style="font-family: arial;">&or;</span> <a class="idref" href="Logic.html#appears_in"><span class="id" type="inductive">appears_in</span></a> <span class="id" type="var">x</span> <span class="id" type="var">ys</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#appears_in"><span class="id" type="inductive">appears_in</span></a> <span class="id" type="var">x</span> (<span class="id" type="var">xs</span> ++ <span class="id" type="var">ys</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Now use <span class="inlinecode"><span class="id" type="var">appears_in</span></span> to define a proposition <span class="inlinecode"><span class="id" type="var">disjoint</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> <span class="inlinecode"><span class="id" type="var">l1</span></span> <span class="inlinecode"><span class="id" type="var">l2</span></span>,
    which should be provable exactly when <span class="inlinecode"><span class="id" type="var">l1</span></span> and <span class="inlinecode"><span class="id" type="var">l2</span></span> are
    lists (with elements of type X) that have no elements in common. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Next, use <span class="inlinecode"><span class="id" type="var">appears_in</span></span> to define an inductive proposition
    <span class="inlinecode"><span class="id" type="var">no_repeats</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span>, which should be provable exactly when <span class="inlinecode"><span class="id" type="var">l</span></span> is a
    list (with elements of type <span class="inlinecode"><span class="id" type="var">X</span></span>) where every member is different
    from every other.  For example, <span class="inlinecode"><span class="id" type="var">no_repeats</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">[1,2,3,4]</span> and
    <span class="inlinecode"><span class="id" type="var">no_repeats</span></span> <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">[]</span> should be provable, while <span class="inlinecode"><span class="id" type="var">no_repeats</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span>
    <span class="inlinecode">[1,2,1]</span> and <span class="inlinecode"><span class="id" type="var">no_repeats</span></span> <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">[<span class="id" type="var">true</span>,<span class="id" type="var">true</span>]</span> should not be.  
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Finally, state and prove one or more interesting theorems relating
    <span class="inlinecode"><span class="id" type="var">disjoint</span></span>, <span class="inlinecode"><span class="id" type="var">no_repeats</span></span> and <span class="inlinecode">++</span> (list append).  
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab255"></a><h2 class="section">Digression: More Facts about <span class="inlinecode">&lt;=</span> and <span class="inlinecode">&lt;</span></h2>

<div class="paragraph"> </div>

 Let's pause briefly to record several facts about the <span class="inlinecode">&lt;=</span>
    and <span class="inlinecode">&lt;</span> relations that we are going to need later in the
    course.  The proofs make good practice exercises. 
<div class="paragraph"> </div>

<a name="lab256"></a><h4 class="section">Exercise: 2 stars, optional (le_exercises)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="O_le_n"><span class="id" type="lemma">O_le_n</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;0 &lt;= <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="n_le_m__Sn_le_Sm"><span class="id" type="lemma">n_le_m__Sn_le_Sm</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> &lt;= <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="constructor">S</span> <span class="id" type="var">n</span> &lt;= <span class="id" type="constructor">S</span> <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="Sn_le_Sm__n_le_m"><span class="id" type="lemma">Sn_le_Sm__n_le_m</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<span class="id" type="constructor">S</span> <span class="id" type="var">n</span> &lt;= <span class="id" type="constructor">S</span> <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> &lt;= <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>. <span class="id" type="tactic">generalize</span> <span class="id" type="tactic">dependent</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">m</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="le_plus_l"><span class="id" type="lemma">le_plus_l</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">a</span> &lt;= <span class="id" type="var">a</span> + <span class="id" type="var">b</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="plus_lt"><span class="id" type="lemma">plus_lt</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n1</span> <span class="id" type="var">n2</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">n1</span> + <span class="id" type="var">n2</span> &lt; <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<span class="id" type="var">n1</span> &lt; <span class="id" type="var">m</span> <span style="font-family: arial;">&and;</span> <span class="id" type="var">n2</span> &lt; <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="lt_S"><span class="id" type="lemma">lt_S</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> &lt; <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> &lt; <span class="id" type="constructor">S</span> <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="ble_nat_true"><span class="id" type="lemma">ble_nat_true</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">m</span> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> &lt;= <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="ble_nat_n_Sn_false"><span class="id" type="lemma">ble_nat_n_Sn_false</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> <span class="id" type="var">n</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">m</span>) = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">m</span> = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="ble_nat_false"><span class="id" type="lemma">ble_nat_false</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">m</span> = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a> <span style="font-family: arial;">&rarr;</span> ~(<span class="id" type="var">n</span> &lt;= <span class="id" type="var">m</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Hint:&nbsp;Do&nbsp;the&nbsp;right&nbsp;induction!&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab257"></a><h4 class="section">Exercise: 3 stars, recommended (nostutter)</h4>
 Formulating inductive definitions of predicates is an important skill
    you'll need in this course.

<div class="paragraph"> </div>

    Try to solve this exercise without any help at all.   If you do receive 
    assistance from anyone, please say so specifically in a comment.

<div class="paragraph"> </div>

    We say that a list of numbers "stutters" if it repeats the same
    number consecutively.  The predicate "<span class="inlinecode"><span class="id" type="var">nostutter</span></span> <span class="inlinecode"><span class="id" type="var">mylist</span></span>" means
    that <span class="inlinecode"><span class="id" type="var">mylist</span></span> does not stutter.  Formulate an inductive definition
    for <span class="inlinecode"><span class="id" type="var">nostutter</span></span>.  (This is different from the <span class="inlinecode"><span class="id" type="var">no_repeats</span></span>
    predicate in the exercise above; the sequence <span class="inlinecode">1,4,1</span> repeats but
    does not stutter.)

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="nostutter"><span class="id" type="inductive">nostutter</span></a>:  <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
.<br/>

<br/>
</div>

<div class="doc">
Make sure each of these tests succeeds, but you are free
    to change the proof if the given one doesn't work for you.
    Your definition might be different from mine and still correct,
    in which case the examples might need a different proof.

<div class="paragraph"> </div>

    The suggested proofs for the examples (in comments) use a number
    of tactics we haven't talked about, to try to make them robust
    with respect to different possible ways of defining <span class="inlinecode"><span class="id" type="var">nostutter</span></span>.
    You should be able to just uncomment and use them as-is, but if
    you prefer you can also prove each example with more basic
    tactics.  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <a name="test_nostutter_1"><span class="id" type="definition">test_nostutter_1</span></a>:      <a class="idref" href="Logic.html#nostutter"><span class="id" type="inductive">nostutter</span></a> [3,1,4,1,5,6].<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="comment">(*&nbsp;<br/>
&nbsp;&nbsp;Proof.&nbsp;repeat&nbsp;constructor;&nbsp;apply&nbsp;beq_false_not_eq;&nbsp;auto.&nbsp;Qed.<br/>
*)</span><br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="test_nostutter_2"><span class="id" type="definition">test_nostutter_2</span></a>:  <a class="idref" href="Logic.html#nostutter"><span class="id" type="inductive">nostutter</span></a> [].<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="comment">(*&nbsp;<br/>
&nbsp;&nbsp;Proof.&nbsp;repeat&nbsp;constructor;&nbsp;apply&nbsp;beq_false_not_eq;&nbsp;auto.&nbsp;Qed.<br/>
*)</span><br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="test_nostutter_3"><span class="id" type="definition">test_nostutter_3</span></a>:  <a class="idref" href="Logic.html#nostutter"><span class="id" type="inductive">nostutter</span></a> [5].<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="comment">(*&nbsp;<br/>
&nbsp;&nbsp;Proof.&nbsp;repeat&nbsp;constructor;&nbsp;apply&nbsp;beq_false_not_eq;&nbsp;auto.&nbsp;Qed.<br/>
*)</span><br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="test_nostutter_4"><span class="id" type="definition">test_nostutter_4</span></a>:      <a class="idref" href="Logic.html#not"><span class="id" type="definition">not</span></a> (<a class="idref" href="Logic.html#nostutter"><span class="id" type="inductive">nostutter</span></a> [3,1,1,4]).<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="comment">(*&nbsp;<br/>
&nbsp;&nbsp;Proof.&nbsp;intro.<br/>
&nbsp;&nbsp;repeat&nbsp;match&nbsp;goal&nbsp;with&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;h:&nbsp;nostutter&nbsp;_&nbsp;|-&nbsp;_&nbsp;=&gt;&nbsp;inversion&nbsp;h;&nbsp;clear&nbsp;h;&nbsp;subst&nbsp;<br/>
&nbsp;&nbsp;end.<br/>
&nbsp;&nbsp;contradiction&nbsp;H1;&nbsp;auto.&nbsp;Qed.<br/>
*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab258"></a><h4 class="section">Exercise: 4 stars, optional (pigeonhole principle)</h4>
 The "pigeonhole principle" states a basic fact about counting:
   if you distribute more than <span class="inlinecode"><span class="id" type="var">n</span></span> items into <span class="inlinecode"><span class="id" type="var">n</span></span> pigeonholes, some 
   pigeonhole must contain at least two items.  As is often the case,
   this apparently trivial fact about numbers requires non-trivial
   machinery to prove, but we now have enough... 
<div class="paragraph"> </div>

 First a pair of useful lemmas... (we already proved this for lists
    of naturals, but not for arbitrary lists.) 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="app_length"><span class="id" type="lemma">app_length</span></a> : <span style="font-family: arial;">&forall;</span> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} (<span class="id" type="var">l1</span> <span class="id" type="var">l2</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> (<span class="id" type="var">l1</span> ++ <span class="id" type="var">l2</span>) = <a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> <span class="id" type="var">l1</span> + <a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> <span class="id" type="var">l2</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="appears_in_app_split"><span class="id" type="lemma">appears_in_app_split</span></a> : <span style="font-family: arial;">&forall;</span> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} (<span class="id" type="var">x</span>:<span class="id" type="var">X</span>) (<span class="id" type="var">l</span>:<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#appears_in"><span class="id" type="inductive">appears_in</span></a> <span class="id" type="var">x</span> <span class="id" type="var">l</span> <span style="font-family: arial;">&rarr;</span> <br/>
&nbsp;&nbsp;<span style="font-family: arial;">&exist;</span> <span class="id" type="var">l1</span>, <span style="font-family: arial;">&exist;</span> <span class="id" type="var">l2</span>, <span class="id" type="var">l</span> = <span class="id" type="var">l1</span> ++ (<span class="id" type="var">x</span>::<span class="id" type="var">l2</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Now define a predicate <span class="inlinecode"><span class="id" type="var">repeats</span></span> (analogous to <span class="inlinecode"><span class="id" type="var">no_repeats</span></span> in the
   exercise above), such that <span class="inlinecode"><span class="id" type="var">repeats</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> asserts that <span class="inlinecode"><span class="id" type="var">l</span></span> contains
   at least one repeated element (of type <span class="inlinecode"><span class="id" type="var">X</span></span>).  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="repeats"><span class="id" type="inductive">repeats</span></a> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
.<br/>

<br/>
</div>

<div class="doc">
Now here's a way to formalize the pigeonhole principle. List <span class="inlinecode"><span class="id" type="var">l2</span></span>
   represents a list of pigeonhole labels, and list <span class="inlinecode"><span class="id" type="var">l1</span></span> represents an
   assignment of items to labels: if there are more items than labels,
   at least two items must have the same label.  You will almost
   certainly need to use the <span class="inlinecode"><span class="id" type="var">excluded_middle</span></span> hypothesis. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="pigeonhole_principle"><span class="id" type="lemma">pigeonhole_principle</span></a>: <span style="font-family: arial;">&forall;</span> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} (<span class="id" type="var">l1</span> <span class="id" type="var">l2</span>:<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#excluded_middle"><span class="id" type="definition">excluded_middle</span></a> <span style="font-family: arial;">&rarr;</span> <br/>
&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span> <span class="id" type="var">x</span>, <a class="idref" href="Logic.html#appears_in"><span class="id" type="inductive">appears_in</span></a> <span class="id" type="var">x</span> <span class="id" type="var">l1</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Logic.html#appears_in"><span class="id" type="inductive">appears_in</span></a> <span class="id" type="var">x</span> <span class="id" type="var">l2</span>) <span style="font-family: arial;">&rarr;</span> <br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> <span class="id" type="var">l2</span> &lt; <a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> <span class="id" type="var">l1</span> <span style="font-family: arial;">&rarr;</span> <br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#repeats"><span class="id" type="inductive">repeats</span></a> <span class="id" type="var">l1</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">X</span> <span class="id" type="var">l1</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l1</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab259"></a><h1 class="section">Optional Material</h1>

<div class="paragraph"> </div>

<a name="lab260"></a><h2 class="section">Induction Principles for <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> and <span class="inlinecode"><span style="font-family: arial;">&or;</span></span></h2>

<div class="paragraph"> </div>

 The induction principles for conjunction and disjunction are a
    good illustration of Coq's way of generating simplified induction
    principles for <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span>ly defined propositions, which we
    discussed in the last chapter.  You try first: 
<div class="paragraph"> </div>

<a name="lab261"></a><h4 class="section">Exercise: 1 star (and_ind_principle)</h4>
 See if you can predict the induction principle for conjunction. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;Check&nbsp;and_ind.&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab262"></a><h4 class="section">Exercise: 1 star (or_ind_principle)</h4>
 See if you can predict the induction principle for disjunction. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;Check&nbsp;or_ind.&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Logic.html#and_ind"><span class="id" type="definition">and_ind</span></a>.<br/>

<br/>
</div>

<div class="doc">
From the inductive definition of the proposition <span class="inlinecode"><span class="id" type="var">and</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Inductive</span>&nbsp;<span class="id" type="var">and</span>&nbsp;(<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">Q</span>&nbsp;:&nbsp;<span class="id" type="keyword">Prop</span>)&nbsp;:&nbsp;<span class="id" type="keyword">Prop</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">conj</span>&nbsp;:&nbsp;<span class="id" type="var">P</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">Q</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;(<span class="id" type="var">and</span>&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">Q</span>).
<div class="paragraph"> </div>

</div>
    we might expect Coq to generate this induction principle

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">and_ind_max</span>&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;(<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">Q</span>&nbsp;:&nbsp;<span class="id" type="keyword">Prop</span>)&nbsp;(<span class="id" type="var">P0</span>&nbsp;:&nbsp;<span class="id" type="var">P</span>&nbsp;<span style="font-family: arial;">&and;</span>&nbsp;<span class="id" type="var">Q</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;(<span class="id" type="var">a</span>&nbsp;:&nbsp;<span class="id" type="var">P</span>)&nbsp;(<span class="id" type="var">b</span>&nbsp;:&nbsp;<span class="id" type="var">Q</span>),&nbsp;<span class="id" type="var">P0</span>&nbsp;(<span class="id" type="var">conj</span>&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">Q</span>&nbsp;<span class="id" type="var">a</span>&nbsp;<span class="id" type="var">b</span>))&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">a</span>&nbsp;:&nbsp;<span class="id" type="var">P</span>&nbsp;<span style="font-family: arial;">&and;</span>&nbsp;<span class="id" type="var">Q</span>,&nbsp;<span class="id" type="var">P0</span>&nbsp;<span class="id" type="var">a</span>
<div class="paragraph"> </div>

</div>
    but actually it generates this simpler and more useful one:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">and_ind</span>&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">Q</span>&nbsp;<span class="id" type="var">P0</span>&nbsp;:&nbsp;<span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">P</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">Q</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">P0</span>)&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">P</span>&nbsp;<span style="font-family: arial;">&and;</span>&nbsp;<span class="id" type="var">Q</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">P0</span>
<div class="paragraph"> </div>

</div>
    In the same way, when given the inductive definition of <span class="inlinecode"><span class="id" type="var">or</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Inductive</span>&nbsp;<span class="id" type="var">or</span>&nbsp;(<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">Q</span>&nbsp;:&nbsp;<span class="id" type="keyword">Prop</span>)&nbsp;:&nbsp;<span class="id" type="keyword">Prop</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">or_introl</span>&nbsp;:&nbsp;<span class="id" type="var">P</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">or</span>&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">Q</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">or_intror</span>&nbsp;:&nbsp;<span class="id" type="var">Q</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">or</span>&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">Q</span>.
<div class="paragraph"> </div>

</div>
    instead of the "maximal induction principle"

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">or_ind_max</span>&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;(<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">Q</span>&nbsp;:&nbsp;<span class="id" type="keyword">Prop</span>)&nbsp;(<span class="id" type="var">P0</span>&nbsp;:&nbsp;<span class="id" type="var">P</span>&nbsp;<span style="font-family: arial;">&or;</span>&nbsp;<span class="id" type="var">Q</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">a</span>&nbsp;:&nbsp;<span class="id" type="var">P</span>,&nbsp;<span class="id" type="var">P0</span>&nbsp;(<span class="id" type="var">or_introl</span>&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">Q</span>&nbsp;<span class="id" type="var">a</span>))&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">b</span>&nbsp;:&nbsp;<span class="id" type="var">Q</span>,&nbsp;<span class="id" type="var">P0</span>&nbsp;(<span class="id" type="var">or_intror</span>&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">Q</span>&nbsp;<span class="id" type="var">b</span>))&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">o</span>&nbsp;:&nbsp;<span class="id" type="var">P</span>&nbsp;<span style="font-family: arial;">&or;</span>&nbsp;<span class="id" type="var">Q</span>,&nbsp;<span class="id" type="var">P0</span>&nbsp;<span class="id" type="var">o</span>
<div class="paragraph"> </div>

</div>
    what Coq actually generates is this:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">or_ind</span>&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">Q</span>&nbsp;<span class="id" type="var">P0</span>&nbsp;:&nbsp;<span class="id" type="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">P</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">P0</span>)&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">Q</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">P0</span>)&nbsp;<span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">P</span>&nbsp;<span style="font-family: arial;">&or;</span>&nbsp;<span class="id" type="var">Q</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">P0</span>
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

<a name="lab263"></a><h2 class="section">Explicit Proof Objects for Induction</h2>

<div class="paragraph"> </div>

 Although tactic-based proofs are normally much easier to
    work with, the ability to write a proof term directly is sometimes
    very handy, particularly when we want Coq to do something slightly
    non-standard.  
<div class="paragraph"> </div>

 Recall the induction principle on naturals that Coq generates for
    us automatically from the Inductive declation for <span class="inlinecode"><span class="id" type="var">nat</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;Check&nbsp;nat_ind.&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;nat_ind&nbsp;:&nbsp;forall&nbsp;P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;0%nat&nbsp;-&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;n))&nbsp;-&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
There's nothing magic about this induction lemma: it's just
   another Coq lemma that requires a proof.  Coq generates the proof
   automatically too...  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">nat_ind</span>. <span class="id" type="keyword">Print</span> <span class="id" type="var">nat_rect</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;(after&nbsp;some&nbsp;manual&nbsp;inlining)<br/>
&nbsp;&nbsp;&nbsp;nat_ind&nbsp;=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;(P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Type)&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;:&nbsp;P&nbsp;0%nat)&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f0&nbsp;:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;P&nbsp;n&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;n))&nbsp;=&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fix&nbsp;F&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;:&nbsp;P&nbsp;n&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;n&nbsp;as&nbsp;n0&nbsp;return&nbsp;(P&nbsp;n0)&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;0%nat&nbsp;=&gt;&nbsp;f<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;S&nbsp;n0&nbsp;=&gt;&nbsp;f0&nbsp;n0&nbsp;(F&nbsp;n0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end.<br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
We can read this as follows: 
     Suppose we have evidence <span class="inlinecode"><span class="id" type="var">f</span></span> that <span class="inlinecode"><span class="id" type="var">P</span></span> holds on 0,  and 
     evidence <span class="inlinecode"><span class="id" type="var">f0</span></span> that <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">n</span>:<span class="id" type="var">nat</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span>.  
     Then we can prove that <span class="inlinecode"><span class="id" type="var">P</span></span> holds of an arbitrary nat <span class="inlinecode"><span class="id" type="var">n</span></span> via 
     a recursive function <span class="inlinecode"><span class="id" type="var">F</span></span> (here defined using the expression 
     form <span class="inlinecode"><span class="id" type="keyword">Fix</span></span> rather than by a top-level <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span> 
     declaration).  <span class="inlinecode"><span class="id" type="var">F</span></span> pattern matches on <span class="inlinecode"><span class="id" type="var">n</span></span>: 

<div class="paragraph"> </div>

<ul class="doclist">
<li> If it finds 0, <span class="inlinecode"><span class="id" type="var">F</span></span> uses <span class="inlinecode"><span class="id" type="var">f</span></span> to show that <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> holds.

</li>
<li> If it finds <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n0</span></span>, <span class="inlinecode"><span class="id" type="var">F</span></span> applies itself recursively on <span class="inlinecode"><span class="id" type="var">n0</span></span> 
         to obtain evidence that <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n0</span></span> holds; then it applies <span class="inlinecode"><span class="id" type="var">f0</span></span> 
         on that evidence to show that <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> holds. 

</li>
</ul>
    <span class="inlinecode"><span class="id" type="var">F</span></span> is just an ordinary recursive function that happens to 
    operate on evidence in <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> rather than on terms in <span class="inlinecode"><span class="id" type="keyword">Set</span></span>.

<div class="paragraph"> </div>

    Aside to those interested in functional programming: You may
    notice that the <span class="inlinecode"><span class="id" type="keyword">match</span></span> in <span class="inlinecode"><span class="id" type="var">F</span></span> requires an annotation <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode"><span class="id" type="var">n0</span></span>
    <span class="inlinecode"><span class="id" type="keyword">return</span></span> <span class="inlinecode">(<span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n0</span>)</span> to help Coq's typechecker realize that the two arms
    of the <span class="inlinecode"><span class="id" type="keyword">match</span></span> actually return the same type (namely <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>).  This
    is essentially like matching over a GADT (generalized algebraic
    datatype) in Haskell.  In fact, <span class="inlinecode"><span class="id" type="var">F</span></span> has a <i>dependent</i> type: its
    result type depends on its argument; GADT's can be used to
    describe simple dependent types like this.

<div class="paragraph"> </div>

    We can adapt this approach to proving <span class="inlinecode"><span class="id" type="var">nat_ind</span></span> to help prove
    <i>non-standard</i> induction principles too.  Recall our desire to
    prove that

<div class="paragraph"> </div>

    <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span>,</span> <span class="inlinecode"><span class="id" type="var">even</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>.

<div class="paragraph"> </div>

    Attempts to do this by standard induction on <span class="inlinecode"><span class="id" type="var">n</span></span> fail, because the
    induction principle only lets us proceed when we can prove that
    <span class="inlinecode"><span class="id" type="var">even</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">even</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> &mdash; which is of course never provable.  What
    we did earlier in this chapter was a bit of a hack:

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" type="keyword">Theorem</span></span> <span class="inlinecode"><span class="id" type="var">even_ev</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span>,</span>
     <span class="inlinecode">(<span class="id" type="var">even</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> <span class="inlinecode"><span style="font-family: arial;">&and;</span></span> <span class="inlinecode">(<span class="id" type="var">even</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>))</span>.

<div class="paragraph"> </div>

    We can make a much better proof by defining and proving a
    non-standard induction principle that goes "by twos":

<div class="paragraph"> </div>

 
</div>
<div class="code code-tight">

<br/>
&nbsp;<span class="id" type="keyword">Definition</span> <a name="nat_ind2"><span class="id" type="definition">nat_ind2</span></a> : <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span> (<span class="id" type="var">P</span> : <span class="id" type="inductive">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>), <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">P</span> 0 <span style="font-family: arial;">&rarr;</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">P</span> 1 <span style="font-family: arial;">&rarr;</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> : <span class="id" type="inductive">nat</span>, <span class="id" type="var">P</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span> (<span class="id" type="constructor">S</span>(<span class="id" type="constructor">S</span> <span class="id" type="var">n</span>))) <span style="font-family: arial;">&rarr;</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span> : <span class="id" type="inductive">nat</span> , <span class="id" type="var">P</span> <span class="id" type="var">n</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">fun</span> <span class="id" type="var">P</span> =&gt; <span class="id" type="keyword">fun</span> <span class="id" type="var">P0</span> =&gt; <span class="id" type="keyword">fun</span> <span class="id" type="var">P1</span> =&gt; <span class="id" type="keyword">fun</span> <span class="id" type="var">PSS</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">fix</span> <span class="id" type="var">f</span> (<span class="id" type="var">n</span>:<span class="id" type="inductive">nat</span>) := <span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">return</span> <span class="id" type="var">P</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 =&gt; <span class="id" type="var">P0</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 1 =&gt; <span class="id" type="var">P1</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="constructor">S</span> (<span class="id" type="constructor">S</span> <span class="id" type="var">n'</span>) =&gt; <span class="id" type="var">PSS</span> <span class="id" type="var">n'</span> (<span class="id" type="var">f</span> <span class="id" type="var">n'</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Once you get the hang of it, it is entirely straightforward to
     give an explicit proof term for induction principles like this.
     Proving this as a lemma using tactics is much less intuitive (try
     it!).

<div class="paragraph"> </div>

     The <span class="inlinecode"><span class="id" type="tactic">induction</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" type="keyword">using</span></span> tactic gives a convenient way to
     specify a non-standard induction principle like this. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="even_ev'"><span class="id" type="lemma">even_ev'</span></a> : <span style="font-family: arial;">&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="Prop.html#even"><span class="id" type="definition">even</span></a> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [ | |<span class="id" type="var">n'</span>] <span class="id" type="keyword">using</span> <a class="idref" href="Logic.html#nat_ind2"><span class="id" type="definition">nat_ind2</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "even 0".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#ev_0"><span class="id" type="constructor">ev_0</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "even 1".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "even (S(S n'))".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHn'</span>. <span class="id" type="tactic">unfold</span> <span class="id" type="var">even</span>. <span class="id" type="tactic">unfold</span> <span class="id" type="var">even</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab264"></a><h2 class="section">The Coq Trusted Computing Base</h2>

<div class="paragraph"> </div>

 One issue that arises with any automated proof assistant is "why
    trust it?": what if there is a bug in the implementation that
    renders all its reasoning suspect?

<div class="paragraph"> </div>

    While it is impossible to allay such concerns completely, the fact
    that Coq is based on the Curry-Howard Correspondence gives it a
    strong foundation. Because propositions are just types and proofs
    are just terms, checking that an alleged proof of a proposition is
    valid just amounts to <i>type-checking</i> the term.  Type checkers are
    relatively small and straightforward programs, so the "trusted
    computing base" for Coq &mdash; the part of the code that we have to
    believe is operating correctly &mdash; is small too.

<div class="paragraph"> </div>

    What must a typechecker do?  Its primary job is to make sure that
    in each function application the expected and actual argument
    types match, that the arms of a <span class="inlinecode"><span class="id" type="keyword">match</span></span> expression are constructor
    patterns belonging to the inductive type being matched over and
    all arms of the <span class="inlinecode"><span class="id" type="keyword">match</span></span> return the same type, and so on.

<div class="paragraph"> </div>

    There are a few additional wrinkles:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Since Coq types can themselves be expressions, the checker must
      normalize these (by using the conversion rules) before
      comparing them.

<div class="paragraph"> </div>


</li>
<li> The checker must make sure that <span class="inlinecode"><span class="id" type="keyword">match</span></span> expressions are
      <i>exhaustive</i>.  That is, there must be an arm for every possible
      constructor.  To see why, consider the following alleged proof
      object:

<div class="paragraph"> </div>

<div class="code code-tight">
<span class="id" type="keyword">Definition</span>&nbsp;<span class="id" type="var">or_bogus</span>&nbsp;:&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">Q</span>,&nbsp;<span class="id" type="var">P</span>&nbsp;<span style="font-family: arial;">&or;</span>&nbsp;<span class="id" type="var">Q</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">P</span>&nbsp;:=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span>&nbsp;(<span class="id" type="var">P</span>&nbsp;<span class="id" type="var">Q</span>&nbsp;:&nbsp;<span class="id" type="keyword">Prop</span>)&nbsp;(<span class="id" type="var">A</span>&nbsp;:&nbsp;<span class="id" type="var">P</span>&nbsp;<span style="font-family: arial;">&or;</span>&nbsp;<span class="id" type="var">Q</span>)&nbsp;=&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span>&nbsp;<span class="id" type="var">A</span>&nbsp;<span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">or_introl</span>&nbsp;<span class="id" type="var">H</span>&nbsp;=&gt;&nbsp;<span class="id" type="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.
<div class="paragraph"> </div>

</div>
      All the types here match correctly, but the <span class="inlinecode"><span class="id" type="keyword">match</span></span> only
      considers one of the possible constructors for <span class="inlinecode"><span class="id" type="var">or</span></span>.  Coq's
      exhaustiveness check will reject this definition.

<div class="paragraph"> </div>


</li>
<li> The checker must make sure that each <span class="inlinecode"><span class="id" type="var">fix</span></span> expression
      terminates.  It does this using a syntactic check to make sure
      that each recursive call is on a subexpression of the original
      argument.  To see why this is essential, consider this alleged
      proof:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span>&nbsp;<span class="id" type="var">nat_false</span>&nbsp;:&nbsp;<span style="font-family: arial;">&forall;</span>&nbsp;(<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>),&nbsp;<span class="id" type="var">False</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">fix</span>&nbsp;<span class="id" type="var">f</span>&nbsp;(<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>)&nbsp;:&nbsp;<span class="id" type="var">False</span>&nbsp;:=&nbsp;<span class="id" type="var">f</span>&nbsp;<span class="id" type="var">n</span>.
<div class="paragraph"> </div>

</div>
      Again, this is perfectly well-typed, but (fortunately) Coq will
      reject it. 
</li>
</ul>

<div class="paragraph"> </div>

 Note that the soundness of Coq depends only on the correctness of
    this typechecking engine, not on the tactic machinery.  If there
    is a bug in a tactic implementation (and this certainly does
    happen!), that tactic might construct an invalid proof term.  But
    when you type <span class="inlinecode"><span class="id" type="keyword">Qed</span></span>, Coq checks the term for validity from
    scratch.  Only lemmas whose proofs pass the type-checker can be
    used in further proof developments.  
</div>
<div class="code code-tight">

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://www.lix.polytechnique.fr/coq/">coqdoc</a>
</div>

</div>

</body>
</html>